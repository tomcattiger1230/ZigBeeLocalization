###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             11/Jan/2016  16:35:10 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Comp #
#                          onents\stack\zdo\ZDSecMgr.c                        #
#    Command line       =  -f C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\P #
#                          rojects\zstack\Samples\SampleApp\CC2530DB\..\..\.. #
#                          \Tools\CC2530DB\f8wCoord.cfg (-DCPU32MHZ           #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f     #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\To #
#                          ols\CC2530DB\f8wConfig.cfg (-DSECURE=0             #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Comp #
#                          onents\stack\zdo\ZDSecMgr.c -D ZIGBEEPRO -D        #
#                          ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D            #
#                          xMT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -lC            #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\Coordinator #
#                          EB-Pro\List\ -lA C:\Users\ArnoldWorkStation\Deskto #
#                          p\ZigbeeTest\Projects\zstack\Samples\SampleApp\CC2 #
#                          530DB\CoordinatorEB-Pro\List\ --diag_suppress      #
#                          Pe001,Pa010 -o C:\Users\ArnoldWorkStation\Desktop\ #
#                          ZigbeeTest\Projects\zstack\Samples\SampleApp\CC253 #
#                          0DB\CoordinatorEB-Pro\Obj\ -e --no_cse             #
#                          --no_unroll --no_inline --no_code_motion           #
#                          --no_tbaa --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\P #
#                          rojects\zstack\Samples\SampleApp\CC2530DB\ -I      #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\SOURCE\  #
#                          -I C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\P #
#                          rojects\zstack\Samples\SampleApp\CC2530DB\..\..\.. #
#                          \ZMAIN\TI2530DB\ -I C:\Users\ArnoldWorkStation\Des #
#                          ktop\ZigbeeTest\Projects\zstack\Samples\SampleApp\ #
#                          CC2530DB\..\..\..\..\..\COMPONENTS\MT\ -I          #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\HAL\INCLUDE\ -I                     #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\HAL\TARGET\CC2530EB\ -I             #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\OSAL\MCU\CCSOC\ -I                  #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\OSAL\INCLUDE\ -I                    #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\STACK\AF\ -I                        #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\STACK\NWK\ -I                       #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\STACK\SEC\ -I                       #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\STACK\SAPI\ -I                      #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\STACK\SYS\ -I                       #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\STACK\ZDO\ -I                       #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\ZMAC\F8W\ -I                        #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\ZMAC\ -I C:\Users\ArnoldWorkStation #
#                          \Desktop\ZigbeeTest\Projects\zstack\Samples\Sample #
#                          App\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SA #
#                          DDR\ -I C:\Users\ArnoldWorkStation\Desktop\ZigbeeT #
#                          est\Projects\zstack\Samples\SampleApp\CC2530DB\..\ #
#                          ..\..\..\..\COMPONENTS\SERVICES\SDATA\ -I          #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\MAC\INCLUDE\ -I                     #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\MAC\HIGH_LEVEL\ -I                  #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\MAC\LOW_LEVEL\srf04\ -I             #
#                          C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\    #
#                          -On --require_prototypes                           #
#    List file          =  C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\Coordinator #
#                          EB-Pro\List\ZDSecMgr.lst                           #
#    Object file        =  C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\Coordinator #
#                          EB-Pro\Obj\ZDSecMgr.r51                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\ArnoldWorkStation\Desktop\ZigbeeTest\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2010-01-08 13:29:59 -0800 (Fri, 08 Jan 2010) $
      4            Revision:       $Revision: 21465 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          // Total number of preconfigured trust center link key
     93          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     94            #define ZDSECMGR_TC_DEVICE_MAX 1
     95          #endif
     96            
     97          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     98            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     99          #endif
    100            
    101          #define ZDSECMGR_CTRL_NONE       0
    102          #define ZDSECMGR_CTRL_INIT       1
    103          #define ZDSECMGR_CTRL_TK_MASTER  2
    104          #define ZDSECMGR_CTRL_SKKE_INIT  3
    105          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    106          #define ZDSECMGR_CTRL_SKKE_DONE  5
    107          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    108          #define ZDSECMGR_CTRL_TK_NWK     7
    109          
    110          #define ZDSECMGR_CTRL_BASE_CNTR      1
    111          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    112          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    113          
    114          // set SKA slot maximum
    115          #define ZDSECMGR_SKA_SLOT_MAX 1
    116          
    117          // APSME Stub Implementations
    118          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    119          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    120          #define ZDSecMgrLinkKeyDataGet APSME_LinkKeyDataGet
    121          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    122          
    123          #if !defined( MAX_APS_FRAMECOUNTER_CHANGES )
    124            // The number of times the frame counter can change before
    125            // saving to NV
    126            #define MAX_APS_FRAMECOUNTER_CHANGES    10
    127          #endif
    128          
    129          /******************************************************************************
    130           * TYPEDEFS
    131           */
    132          typedef struct
    133          {
    134            uint8 extAddr[Z_EXTADDR_LEN];
    135            uint8 key[SEC_KEY_LEN];
    136          } ZDSecMgrPreConfigData_t;
    137          
    138          typedef struct
    139          {
    140            uint16 ami;
    141            uint8  key[SEC_KEY_LEN];
    142          } ZDSecMgrMasterKeyData_t;
    143          
    144          //should match APSME_LinkKeyData_t;
    145          typedef struct
    146          {
    147            uint8               key[SEC_KEY_LEN];
    148            APSME_LinkKeyData_t apsmelkd;
    149          } ZDSecMgrLinkKeyData_t;
    150          
    151          typedef struct
    152          {
    153            uint16                ami;
    154            ZDSecMgrLinkKeyData_t lkd;
    155            ZDSecMgr_Authentication_Option authenticateOption;
    156          } ZDSecMgrEntry_t;
    157          
    158          typedef struct
    159          {
    160            ZDSecMgrEntry_t* entry;
    161            uint16           parentAddr;
    162            uint8            secure;
    163            uint8            state;
    164            uint8            cntr;
    165            //uint8          next;
    166          } ZDSecMgrCtrl_t;
    167          
    168          typedef struct
    169          {
    170            uint16          nwkAddr;
    171            uint8*          extAddr;
    172            uint16          parentAddr;
    173            uint8           secure;
    174            uint8           devStatus;
    175            ZDSecMgrCtrl_t* ctrl;
    176          } ZDSecMgrDevice_t;
    177          
    178          /******************************************************************************
    179           * LOCAL VARIABLES
    180           */
    181          #if 0 // Taken out because the following functionality is only used for test
    182                // purpose. A more efficient (above) way is used. It can be put
    183                // back in if customers request for a white/black list feature.
    184          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    185          {
    186            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    187            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    188            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    189          };
    190          #endif
    191          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    192          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    193            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    194          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    195          uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for ZDSecMgrTCMasterKey>`
   \   000010                REQUIRE __INIT_XDATA_I
    196            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    197             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    198          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    199          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    200          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    201          
    202          //devtag.pro.security - remove this
    203          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    204          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    205          {
    206            //---------------------------------------------------------------------------
    207            // DEVICE A
    208            //---------------------------------------------------------------------------
    209            {
    210              // extAddr
    211              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    212          
    213              // key
    214              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    215               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    216            },
    217            //---------------------------------------------------------------------------
    218            // DEVICE B
    219            //---------------------------------------------------------------------------
    220            {
    221              // extAddr
    222              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    223          
    224              // key
    225              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    226               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    227            },
    228            //---------------------------------------------------------------------------
    229            // DEVICE C
    230            //---------------------------------------------------------------------------
    231            {
    232              // extAddr
    233              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    234          
    235              // key
    236              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    237               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    238            },
    239          };
    240          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    241          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    242          ZDSecMgrMasterKeyData_t* ZDSecMgrMasterKeyData = NULL;
   \                     ZDSecMgrMasterKeyData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    243          ZDSecMgrEntry_t*         ZDSecMgrEntries       = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    244          ZDSecMgrCtrl_t*          ZDSecMgrCtrlData      = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    245          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    246          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    247          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    248          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    249          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    250          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    251          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    252          
    253          /******************************************************************************
    254           * PRIVATE FUNCTIONS
    255           *
    256           *   ZDSecMgrMasterKeyInit
    257           *   ZDSecMgrAddrStore
    258           *   ZDSecMgrExtAddrStore
    259           *   ZDSecMgrExtAddrLookup
    260           *   ZDSecMgrMasterKeyLookup
    261           *   ZDSecMgrMasterKeyStore
    262           *   ZDSecMgrEntryInit
    263           *   ZDSecMgrEntryLookup
    264           *   ZDSecMgrEntryLookupAMI
    265           *   ZDSecMgrEntryLookupExt
    266           *   ZDSecMgrEntryFree
    267           *   ZDSecMgrEntryNew
    268           *   ZDSecMgrCtrlInit
    269           *   ZDSecMgrCtrlRelease
    270           *   ZDSecMgrCtrlLookup
    271           *   ZDSecMgrCtrlSet
    272           *   ZDSecMgrCtrlAdd
    273           *   ZDSecMgrCtrlTerm
    274           *   ZDSecMgrCtrlReset
    275           *   ZDSecMgrMasterKeyLoad
    276           *   ZDSecMgrAppKeyGet
    277           *   ZDSecMgrAppKeyReq
    278           *   ZDSecMgrEstablishKey
    279           *   ZDSecMgrSendMasterKey
    280           *   ZDSecMgrSendNwkKey
    281           *   ZDSecMgrDeviceEntryRemove
    282           *   ZDSecMgrDeviceEntryAdd
    283           *   ZDSecMgrDeviceCtrlHandler
    284           *   ZDSecMgrDeviceCtrlSetup
    285           *   ZDSecMgrDeviceCtrlUpdate
    286           *   ZDSecMgrDeviceRemove
    287           *   ZDSecMgrDeviceValidateSKKE
    288           *   ZDSecMgrDeviceValidateRM
    289           *   ZDSecMgrDeviceValidateCM
    290           *   ZDSecMgrDeviceValidate
    291           *   ZDSecMgrDeviceJoin
    292           *   ZDSecMgrDeviceJoinDirect
    293           *   ZDSecMgrDeviceJoinFwd
    294           *   ZDSecMgrDeviceNew
    295           *   ZDSecMgrAssocDeviceAuth
    296           *   ZDSecMgrAuthInitiate
    297           *   ZDSecMgrAuthNwkKey
    298           *   APSME_TCLinkKeyInit
    299           *   APSME_IsDefaultTCLK
    300           */
    301          //-----------------------------------------------------------------------------
    302          // master key data
    303          //-----------------------------------------------------------------------------
    304          void ZDSecMgrMasterKeyInit( void );
    305          
    306          //-----------------------------------------------------------------------------
    307          // address management
    308          //-----------------------------------------------------------------------------
    309          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    310          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    311          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    312          
    313          //-----------------------------------------------------------------------------
    314          // MASTER key data
    315          //-----------------------------------------------------------------------------
    316          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key );
    317          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    318          
    319          //-----------------------------------------------------------------------------
    320          // entry data
    321          //-----------------------------------------------------------------------------
    322          void ZDSecMgrEntryInit(uint8 state);
    323          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    324          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    325          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    326          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    327          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    328          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    329          
    330          //-----------------------------------------------------------------------------
    331          // control data
    332          //-----------------------------------------------------------------------------
    333          void ZDSecMgrCtrlInit( void );
    334          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    335          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    336          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    337                                ZDSecMgrEntry_t*  entry,
    338                                ZDSecMgrCtrl_t*   ctrl );
    339          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    340          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    341          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    342                                       ZDSecMgrEntry_t*  entry );
    343          
    344          //-----------------------------------------------------------------------------
    345          // key support
    346          //-----------------------------------------------------------------------------
    347          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    348          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    349                                       uint8*  initExtAddr,
    350                                       uint16  partNwkAddr,
    351                                       uint8*  partExtAddr,
    352                                       uint8** key,
    353                                       uint8*  keyType );
    354          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    355          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    356          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    357          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    358          
    359          //-----------------------------------------------------------------------------
    360          // device entry
    361          //-----------------------------------------------------------------------------
    362          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    363          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    364          #if defined NV_RESTORE
    365          static void ZDSecMgrWriteNV(void);
    366          static void ZDSecMgrRestoreFromNV(void);
    367          #endif
    368          
    369          //-----------------------------------------------------------------------------
    370          // device control
    371          //-----------------------------------------------------------------------------
    372          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    373          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    374          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    375          
    376          //-----------------------------------------------------------------------------
    377          // device management
    378          //-----------------------------------------------------------------------------
    379          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    382          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    383          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    384          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    385          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    386          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    387          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    388          
    389          //-----------------------------------------------------------------------------
    390          // association management
    391          //-----------------------------------------------------------------------------
    392          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    393          
    394          //-----------------------------------------------------------------------------
    395          // authentication management
    396          //-----------------------------------------------------------------------------
    397          void ZDSecMgrAuthInitiate( uint8* responder );
    398          void ZDSecMgrAuthNwkKey( void );
    399          
    400          //-----------------------------------------------------------------------------
    401          // APSME function
    402          //-----------------------------------------------------------------------------
    403          void APSME_TCLinkKeyInit( void );
    404          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    405          
    406          /******************************************************************************
    407           * @fn          ZDSecMgrMasterKeyInit                     ]
    408           *
    409           * @brief       Initialize master key data.
    410           *
    411           * @param       none
    412           *
    413           * @return      none
    414           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    415          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    416          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    417            uint16 index;
    418            uint16 size;
    419          
    420            // allocate MASTER key data
    421            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
   \   000005   75..36       MOV     ?V0 + 0,#0x36
   \   000008   75..00       MOV     ?V0 + 1,#0x0
    422          
    423            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   AA..         MOV     R2,?V0 + 0
   \   00000D   AB..         MOV     R3,?V0 + 1
   \   00000F   12....       LCALL   ??osal_mem_alloc?relay
   \   000012   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000015   EA           MOV     A,R2
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   EB           MOV     A,R3
   \   000019   F0           MOVX    @DPTR,A
    424          
    425            // initialize MASTER key data
    426            if ( ZDSecMgrMasterKeyData != NULL )
   \   00001A   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   49           ORL     A,R1
   \   000024   6044         JZ      ??ZDSecMgrMasterKeyInit_0
    427            {
    428              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   000026   7E00         MOV     R6,#0x0
   \   000028   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   00002A   C3           CLR     C
   \   00002B   EE           MOV     A,R6
   \   00002C   9403         SUBB    A,#0x3
   \   00002E   EF           MOV     A,R7
   \   00002F   9400         SUBB    A,#0x0
   \   000031   5037         JNC     ??ZDSecMgrMasterKeyInit_0
    429              {
    430                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
   \   000033   EE           MOV     A,R6
   \   000034   F8           MOV     R0,A
   \   000035   EF           MOV     A,R7
   \   000036   F9           MOV     R1,A
   \   000037   E8           MOV     A,R0
   \   000038   75F012       MOV     B,#0x12
   \   00003B   A4           MUL     AB
   \   00003C   C8           XCH     A,R0
   \   00003D   AAF0         MOV     R2,B
   \   00003F   75F000       MOV     B,#0x0
   \   000042   A4           MUL     AB
   \   000043   2A           ADD     A,R2
   \   000044   FA           MOV     R2,A
   \   000045   75F012       MOV     B,#0x12
   \   000048   E9           MOV     A,R1
   \   000049   A4           MUL     AB
   \   00004A   2A           ADD     A,R2
   \   00004B   F9           MOV     R1,A
   \   00004C   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   28           ADD     A,R0
   \   000051   FA           MOV     R2,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   39           ADDC    A,R1
   \   000055   8A82         MOV     DPL,R2
   \   000057   F583         MOV     DPH,A
   \   000059   74FE         MOV     A,#-0x2
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   74FF         MOV     A,#-0x1
   \   00005F   F0           MOVX    @DPTR,A
    431              }
   \   000060   EE           MOV     A,R6
   \   000061   2401         ADD     A,#0x1
   \   000063   FE           MOV     R6,A
   \   000064   EF           MOV     A,R7
   \   000065   3400         ADDC    A,#0x0
   \   000067   FF           MOV     R7,A
   \   000068   80C0         SJMP    ??ZDSecMgrMasterKeyInit_1
    432            }
    433          }
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00006A   7F02         MOV     R7,#0x2
   \   00006C   02....       LJMP    ?BANKED_LEAVE_XDATA
    434          //devtag.pro.security
    435          #if 0
    436          void ZDSecMgrMasterKeyInit( void )
    437          {
    438            uint16         index;
    439            uint16         size;
    440            AddrMgrEntry_t entry;
    441          
    442          
    443            // allocate MASTER key data
    444            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    445          
    446            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
    447          
    448            // initialize MASTER key data
    449            if ( ZDSecMgrMasterKeyData != NULL )
    450            {
    451              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    452              {
    453                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
    454              }
    455          
    456              // check if preconfigured keys are enabled
    457              //-------------------------------------------------------------------------
    458              #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    459              //-------------------------------------------------------------------------
    460              if ( zgPreConfigKeys == TRUE )
    461              {
    462                // sync configured data
    463                entry.user = ADDRMGR_USER_SECURITY;
    464          
    465                for ( index = 0; index < ZDSECMGR_PRECONFIG_MAX; index++ )
    466                {
    467                  // check for Address Manager entry
    468                  AddrMgrExtAddrSet( entry.extAddr,
    469                                     (uint8*)ZDSecMgrPreConfigData[index].extAddr );
    470          
    471                  if ( AddrMgrEntryLookupExt( &entry ) != TRUE )
    472                  {
    473                    // update Address Manager
    474                    AddrMgrEntryUpdate( &entry );
    475                  }
    476          
    477                  if ( entry.index != INVALID_NODE_ADDR )
    478                  {
    479                    // sync MASTER keys with Address Manager index
    480                    ZDSecMgrMasterKeyData[index].ami = entry.index;
    481          
    482                    osal_memcpy( ZDSecMgrMasterKeyData[index].key,
    483                             (void*)ZDSecMgrPreConfigData[index].key, SEC_KEY_LEN );
    484                  }
    485                }
    486              }
    487              //-------------------------------------------------------------------------
    488              #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    489              //-------------------------------------------------------------------------
    490            }
    491          }
    492          #endif
    493          
    494          /******************************************************************************
    495           * @fn          ZDSecMgrAddrStore
    496           *
    497           * @brief       Store device addresses.
    498           *
    499           * @param       nwkAddr - [in] NWK address
    500           * @param       extAddr - [in] EXT address
    501           * @param       ami     - [out] Address Manager index
    502           *
    503           * @return      ZStatus_t
    504           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    505          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    506          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   741A         MOV     A,#0x1a
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
    507            ZStatus_t      status;
    508            AddrMgrEntry_t entry;
    509          
    510          
    511            // add entry
    512            entry.user    = ADDRMGR_USER_SECURITY;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
    513            entry.nwkAddr = nwkAddr;
   \   000027   7401         MOV     A,#0x1
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E5..         MOV     A,?V0 + 2
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   E5..         MOV     A,?V0 + 3
   \   000032   F0           MOVX    @DPTR,A
    514            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000033                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000033   EE           MOV     A,R6
   \   000034   FC           MOV     R4,A
   \   000035   EF           MOV     A,R7
   \   000036   FD           MOV     R5,A
   \   000037   7403         MOV     A,#0x3
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   12....       LCALL   ??AddrMgrExtAddrSet?relay
    515          
    516            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000043                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   AA82         MOV     R2,DPL
   \   00004B   AB83         MOV     R3,DPH
   \   00004D   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000050   E9           MOV     A,R1
   \   000051   6401         XRL     A,#0x1
   \   000053   701A         JNZ     ??ZDSecMgrAddrStore_0
    517            {
    518              // return successful results
    519              *ami   = entry.index;
   \   000055   740B         MOV     A,#0xb
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F8           MOV     R0,A
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F9           MOV     R1,A
   \   00005F   85..82       MOV     DPL,?V0 + 0
   \   000062   85..83       MOV     DPH,?V0 + 1
   \   000065   E8           MOV     A,R0
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E9           MOV     A,R1
   \   000069   F0           MOVX    @DPTR,A
    520              status = ZSuccess;
   \   00006A   75..00       MOV     ?V0 + 4,#0x0
   \   00006D   8018         SJMP    ??ZDSecMgrAddrStore_1
    521            }
    522            else
    523            {
    524              // return failed results
    525              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00006F   740B         MOV     A,#0xb
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F8           MOV     R0,A
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F9           MOV     R1,A
   \   000079   85..82       MOV     DPL,?V0 + 0
   \   00007C   85..83       MOV     DPH,?V0 + 1
   \   00007F   E8           MOV     A,R0
   \   000080   F0           MOVX    @DPTR,A
   \   000081   A3           INC     DPTR
   \   000082   E9           MOV     A,R1
   \   000083   F0           MOVX    @DPTR,A
    526              status = ZNwkUnknownDevice;
   \   000084   75..C8       MOV     ?V0 + 4,#-0x38
    527            }
    528          
    529            return status;
   \                     ??ZDSecMgrAddrStore_1:
   \   000087   A9..         MOV     R1,?V0 + 4
   \   000089   740D         MOV     A,#0xd
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008E   7F05         MOV     R7,#0x5
   \   000090   02....       LJMP    ?BANKED_LEAVE_XDATA
    530          }
    531          
    532          /******************************************************************************
    533           * @fn          ZDSecMgrExtAddrStore
    534           *
    535           * @brief       Store EXT address.
    536           *
    537           * @param       extAddr - [in] EXT address
    538           * @param       ami     - [out] Address Manager index
    539           *
    540           * @return      ZStatus_t
    541           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    542          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    543          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   741A         MOV     A,#0x1a
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
    544            ZStatus_t      status;
    545            AddrMgrEntry_t entry;
    546          
    547          
    548            // add entry
    549            entry.user    = ADDRMGR_USER_SECURITY;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
    550            entry.nwkAddr = nwkAddr;
   \   000027   7401         MOV     A,#0x1
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E5..         MOV     A,?V0 + 2
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   E5..         MOV     A,?V0 + 3
   \   000032   F0           MOVX    @DPTR,A
    551            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000033                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000033   EE           MOV     A,R6
   \   000034   FC           MOV     R4,A
   \   000035   EF           MOV     A,R7
   \   000036   FD           MOV     R5,A
   \   000037   7403         MOV     A,#0x3
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   12....       LCALL   ??AddrMgrExtAddrSet?relay
    552          
    553            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000043                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   AA82         MOV     R2,DPL
   \   00004B   AB83         MOV     R3,DPH
   \   00004D   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000050   E9           MOV     A,R1
   \   000051   6401         XRL     A,#0x1
   \   000053   701A         JNZ     ??ZDSecMgrExtAddrStore_0
    554            {
    555              // return successful results
    556              *ami   = entry.index;
   \   000055   740B         MOV     A,#0xb
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F8           MOV     R0,A
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F9           MOV     R1,A
   \   00005F   85..82       MOV     DPL,?V0 + 0
   \   000062   85..83       MOV     DPH,?V0 + 1
   \   000065   E8           MOV     A,R0
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E9           MOV     A,R1
   \   000069   F0           MOVX    @DPTR,A
    557              status = ZSuccess;
   \   00006A   75..00       MOV     ?V0 + 4,#0x0
   \   00006D   8018         SJMP    ??ZDSecMgrExtAddrStore_1
    558            }
    559            else
    560            {
    561              // return failed results
    562              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00006F   740B         MOV     A,#0xb
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F8           MOV     R0,A
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F9           MOV     R1,A
   \   000079   85..82       MOV     DPL,?V0 + 0
   \   00007C   85..83       MOV     DPH,?V0 + 1
   \   00007F   E8           MOV     A,R0
   \   000080   F0           MOVX    @DPTR,A
   \   000081   A3           INC     DPTR
   \   000082   E9           MOV     A,R1
   \   000083   F0           MOVX    @DPTR,A
    563              status = ZNwkUnknownDevice;
   \   000084   75..C8       MOV     ?V0 + 4,#-0x38
    564            }
    565          
    566            return status;
   \                     ??ZDSecMgrExtAddrStore_1:
   \   000087   A9..         MOV     R1,?V0 + 4
   \   000089   740D         MOV     A,#0xd
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008E   7F05         MOV     R7,#0x5
   \   000090   02....       LJMP    ?BANKED_LEAVE_XDATA
    567          }
    568          
    569          /******************************************************************************
    570           * @fn          ZDSecMgrExtAddrLookup
    571           *
    572           * @brief       Lookup index for specified EXT address.
    573           *
    574           * @param       extAddr - [in] EXT address
    575           * @param       ami     - [out] Address Manager index
    576           *
    577           * @return      ZStatus_t
    578           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    579          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    580          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
    581            ZStatus_t      status;
    582            AddrMgrEntry_t entry;
    583          
    584          
    585            // lookup entry
    586            entry.user = ADDRMGR_USER_SECURITY;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7402         MOV     A,#0x2
   \   00001A   F0           MOVX    @DPTR,A
    587            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   00001B                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001B   EE           MOV     A,R6
   \   00001C   FC           MOV     R4,A
   \   00001D   EF           MOV     A,R7
   \   00001E   FD           MOV     R5,A
   \   00001F   7403         MOV     A,#0x3
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   AA82         MOV     R2,DPL
   \   000026   AB83         MOV     R3,DPH
   \   000028   12....       LCALL   ??AddrMgrExtAddrSet?relay
    588          
    589            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   00002B                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00002B   85..82       MOV     DPL,?XSP + 0
   \   00002E   85..83       MOV     DPH,?XSP + 1
   \   000031   AA82         MOV     R2,DPL
   \   000033   AB83         MOV     R3,DPH
   \   000035   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000038   E9           MOV     A,R1
   \   000039   6401         XRL     A,#0x1
   \   00003B   701A         JNZ     ??ZDSecMgrExtAddrLookup_0
    590            {
    591              // return successful results
    592              *ami   = entry.index;
   \   00003D   740B         MOV     A,#0xb
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F9           MOV     R1,A
   \   000047   85..82       MOV     DPL,?V0 + 0
   \   00004A   85..83       MOV     DPH,?V0 + 1
   \   00004D   E8           MOV     A,R0
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   E9           MOV     A,R1
   \   000051   F0           MOVX    @DPTR,A
    593              status = ZSuccess;
   \   000052   75..00       MOV     ?V0 + 2,#0x0
   \   000055   8018         SJMP    ??ZDSecMgrExtAddrLookup_1
    594            }
    595            else
    596            {
    597              // return failed results
    598              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000057   740B         MOV     A,#0xb
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F8           MOV     R0,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   F9           MOV     R1,A
   \   000061   85..82       MOV     DPL,?V0 + 0
   \   000064   85..83       MOV     DPH,?V0 + 1
   \   000067   E8           MOV     A,R0
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   E9           MOV     A,R1
   \   00006B   F0           MOVX    @DPTR,A
    599              status = ZNwkUnknownDevice;
   \   00006C   75..C8       MOV     ?V0 + 2,#-0x38
    600            }
    601          
    602            return status;
   \                     ??ZDSecMgrExtAddrLookup_1:
   \   00006F   A9..         MOV     R1,?V0 + 2
   \   000071   740D         MOV     A,#0xd
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   \   000076   7F03         MOV     R7,#0x3
   \   000078   02....       LJMP    ?BANKED_LEAVE_XDATA
    603          }
    604          
    605          /******************************************************************************
    606           * @fn          ZDSecMgrMasterKeyLookup
    607           *
    608           * @brief       Lookup MASTER key for specified address index.
    609           *
    610           * @param       ami - [in] Address Manager index
    611           * @param       key - [out] valid MASTER key
    612           *
    613           * @return      ZStatus_t
    614           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    615          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key )
   \                     ZDSecMgrMasterKeyLookup:
    616          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
    617            ZStatus_t status;
    618            uint16    index;
    619          
    620          
    621            // initialize results
    622            *key   = NULL;
   \   00000D   85..82       MOV     DPL,?V0 + 0
   \   000010   85..83       MOV     DPH,?V0 + 1
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
    623            status = ZNwkUnknownDevice;
   \   00001A   79C8         MOV     R1,#-0x38
    624          
    625            // verify data is available
    626            if ( ZDSecMgrMasterKeyData != NULL )
   \   00001C   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   FC           MOV     R4,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FD           MOV     R5,A
   \   000024   EC           MOV     A,R4
   \   000025   4D           ORL     A,R5
   \   000026   7003         JNZ     $+5
   \   000028   02....       LJMP    ??ZDSecMgrMasterKeyLookup_0 & 0xFFFF
    627            {
    628              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   00002B   7A00         MOV     R2,#0x0
   \   00002D   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   00002F   C3           CLR     C
   \   000030   EA           MOV     A,R2
   \   000031   9403         SUBB    A,#0x3
   \   000033   EB           MOV     A,R3
   \   000034   9400         SUBB    A,#0x0
   \   000036   5076         JNC     ??ZDSecMgrMasterKeyLookup_0
    629              {
    630                if ( ZDSecMgrMasterKeyData[index].ami == ami )
   \   000038   EA           MOV     A,R2
   \   000039   FC           MOV     R4,A
   \   00003A   EB           MOV     A,R3
   \   00003B   FD           MOV     R5,A
   \   00003C   EC           MOV     A,R4
   \   00003D   75F012       MOV     B,#0x12
   \   000040   A4           MUL     AB
   \   000041   CC           XCH     A,R4
   \   000042   A8F0         MOV     R0,B
   \   000044   75F000       MOV     B,#0x0
   \   000047   A4           MUL     AB
   \   000048   28           ADD     A,R0
   \   000049   F8           MOV     R0,A
   \   00004A   75F012       MOV     B,#0x12
   \   00004D   ED           MOV     A,R5
   \   00004E   A4           MUL     AB
   \   00004F   28           ADD     A,R0
   \   000050   FD           MOV     R5,A
   \   000051   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000054   E0           MOVX    A,@DPTR
   \   000055   2C           ADD     A,R4
   \   000056   F8           MOV     R0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   3D           ADDC    A,R5
   \   00005A   8882         MOV     DPL,R0
   \   00005C   F583         MOV     DPH,A
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   6E           XRL     A,R6
   \   000060   7003         JNZ     ??ZDSecMgrMasterKeyLookup_2
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   6F           XRL     A,R7
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   000065   703D         JNZ     ??ZDSecMgrMasterKeyLookup_3
    631                {
    632                  // return successful results
    633                  *key   = ZDSecMgrMasterKeyData[index].key;
   \   000067   EA           MOV     A,R2
   \   000068   FC           MOV     R4,A
   \   000069   EB           MOV     A,R3
   \   00006A   FD           MOV     R5,A
   \   00006B   EC           MOV     A,R4
   \   00006C   75F012       MOV     B,#0x12
   \   00006F   A4           MUL     AB
   \   000070   CC           XCH     A,R4
   \   000071   A8F0         MOV     R0,B
   \   000073   75F000       MOV     B,#0x0
   \   000076   A4           MUL     AB
   \   000077   28           ADD     A,R0
   \   000078   F8           MOV     R0,A
   \   000079   75F012       MOV     B,#0x12
   \   00007C   ED           MOV     A,R5
   \   00007D   A4           MUL     AB
   \   00007E   28           ADD     A,R0
   \   00007F   FD           MOV     R5,A
   \   000080   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000083   E0           MOVX    A,@DPTR
   \   000084   2C           ADD     A,R4
   \   000085   F8           MOV     R0,A
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   3D           ADDC    A,R5
   \   000089   8882         MOV     DPL,R0
   \   00008B   F583         MOV     DPH,A
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   AC82         MOV     R4,DPL
   \   000091   AD83         MOV     R5,DPH
   \   000093   85..82       MOV     DPL,?V0 + 0
   \   000096   85..83       MOV     DPH,?V0 + 1
   \   000099   EC           MOV     A,R4
   \   00009A   F0           MOVX    @DPTR,A
   \   00009B   A3           INC     DPTR
   \   00009C   ED           MOV     A,R5
   \   00009D   F0           MOVX    @DPTR,A
    634                  status = ZSuccess;
   \   00009E   7900         MOV     R1,#0x0
    635          
    636                  // break from loop
    637                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   0000A0   7A03         MOV     R2,#0x3
   \   0000A2   7B00         MOV     R3,#0x0
    638                }
    639              }
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   0000A4   EA           MOV     A,R2
   \   0000A5   2401         ADD     A,#0x1
   \   0000A7   FA           MOV     R2,A
   \   0000A8   EB           MOV     A,R3
   \   0000A9   3400         ADDC    A,#0x0
   \   0000AB   FB           MOV     R3,A
   \   0000AC   8081         SJMP    ??ZDSecMgrMasterKeyLookup_1
    640            }
    641          
    642            return status;
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   0000AE   7F02         MOV     R7,#0x2
   \   0000B0   02....       LJMP    ?BANKED_LEAVE_XDATA
    643          }
    644          
    645          /******************************************************************************
    646           * @fn          ZDSecMgrMasterKeyStore
    647           *
    648           * @brief       Store MASTER key for specified address index.
    649           *
    650           * @param       ami - [in] Address Manager index
    651           * @param       key - [in] valid key to store
    652           *
    653           * @return      ZStatus_t
    654           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    655          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    656          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 8,R2
   \   000007   8B..         MOV     ?V0 + 9,R3
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
    657            ZStatus_t status;
    658            uint16    index;
    659            uint8*    entry;
    660          
    661          
    662            // initialize results
    663            status = ZNwkUnknownDevice;
   \   00000D   75..C8       MOV     ?V0 + 7,#-0x38
    664          
    665            // verify data is available
    666            if ( ZDSecMgrMasterKeyData != NULL )
   \   000010   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    667            {
    668              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   000023   C3           CLR     C
   \   000024   EE           MOV     A,R6
   \   000025   9403         SUBB    A,#0x3
   \   000027   EF           MOV     A,R7
   \   000028   9400         SUBB    A,#0x0
   \   00002A   4003         JC      $+5
   \   00002C   02....       LJMP    ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    669              {
    670                if ( ZDSecMgrMasterKeyData[index].ami == INVALID_NODE_ADDR )
   \   00002F   EE           MOV     A,R6
   \   000030   F8           MOV     R0,A
   \   000031   EF           MOV     A,R7
   \   000032   F9           MOV     R1,A
   \   000033   E8           MOV     A,R0
   \   000034   75F012       MOV     B,#0x12
   \   000037   A4           MUL     AB
   \   000038   C8           XCH     A,R0
   \   000039   AAF0         MOV     R2,B
   \   00003B   75F000       MOV     B,#0x0
   \   00003E   A4           MUL     AB
   \   00003F   2A           ADD     A,R2
   \   000040   FA           MOV     R2,A
   \   000041   75F012       MOV     B,#0x12
   \   000044   E9           MOV     A,R1
   \   000045   A4           MUL     AB
   \   000046   2A           ADD     A,R2
   \   000047   F9           MOV     R1,A
   \   000048   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   28           ADD     A,R0
   \   00004D   FA           MOV     R2,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   39           ADDC    A,R1
   \   000051   8A82         MOV     DPL,R2
   \   000053   F583         MOV     DPH,A
   \   000055   E0           MOVX    A,@DPTR
   \   000056   64FE         XRL     A,#0xfe
   \   000058   7004         JNZ     ??ZDSecMgrMasterKeyStore_2
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   00005E   6003         JZ      $+5
   \   000060   02....       LJMP    ??ZDSecMgrMasterKeyStore_3 & 0xFFFF
    671                {
    672                  // store EXT address index
    673                  ZDSecMgrMasterKeyData[index].ami = ami;
   \   000063   EE           MOV     A,R6
   \   000064   F8           MOV     R0,A
   \   000065   EF           MOV     A,R7
   \   000066   F9           MOV     R1,A
   \   000067   E8           MOV     A,R0
   \   000068   75F012       MOV     B,#0x12
   \   00006B   A4           MUL     AB
   \   00006C   C8           XCH     A,R0
   \   00006D   AAF0         MOV     R2,B
   \   00006F   75F000       MOV     B,#0x0
   \   000072   A4           MUL     AB
   \   000073   2A           ADD     A,R2
   \   000074   FA           MOV     R2,A
   \   000075   75F012       MOV     B,#0x12
   \   000078   E9           MOV     A,R1
   \   000079   A4           MUL     AB
   \   00007A   2A           ADD     A,R2
   \   00007B   F9           MOV     R1,A
   \   00007C   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   28           ADD     A,R0
   \   000081   FA           MOV     R2,A
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   39           ADDC    A,R1
   \   000085   8A82         MOV     DPL,R2
   \   000087   F583         MOV     DPH,A
   \   000089   E5..         MOV     A,?V0 + 8
   \   00008B   F0           MOVX    @DPTR,A
   \   00008C   A3           INC     DPTR
   \   00008D   E5..         MOV     A,?V0 + 9
   \   00008F   F0           MOVX    @DPTR,A
    674          
    675                  entry = ZDSecMgrMasterKeyData[index].key;
   \   000090   EE           MOV     A,R6
   \   000091   F8           MOV     R0,A
   \   000092   EF           MOV     A,R7
   \   000093   F9           MOV     R1,A
   \   000094   E8           MOV     A,R0
   \   000095   75F012       MOV     B,#0x12
   \   000098   A4           MUL     AB
   \   000099   C8           XCH     A,R0
   \   00009A   AAF0         MOV     R2,B
   \   00009C   75F000       MOV     B,#0x0
   \   00009F   A4           MUL     AB
   \   0000A0   2A           ADD     A,R2
   \   0000A1   FA           MOV     R2,A
   \   0000A2   75F012       MOV     B,#0x12
   \   0000A5   E9           MOV     A,R1
   \   0000A6   A4           MUL     AB
   \   0000A7   2A           ADD     A,R2
   \   0000A8   F9           MOV     R1,A
   \   0000A9   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   28           ADD     A,R0
   \   0000AE   FA           MOV     R2,A
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   39           ADDC    A,R1
   \   0000B2   8A82         MOV     DPL,R2
   \   0000B4   F583         MOV     DPH,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   8582..       MOV     ?V0 + 2,DPL
   \   0000BB   8583..       MOV     ?V0 + 3,DPH
    676          
    677                  if ( key != NULL )
   \   0000BE   E5..         MOV     A,?V0 + 0
   \   0000C0   45..         ORL     A,?V0 + 1
   \   0000C2   6020         JZ      ??ZDSecMgrMasterKeyStore_4
    678                  {
    679                    osal_memcpy( entry, key,  SEC_KEY_LEN );
   \   0000C4                ; Setup parameters for call to function osal_memcpy
   \   0000C4   85....       MOV     ?V0 + 4,?V0 + 0
   \   0000C7   85....       MOV     ?V0 + 5,?V0 + 1
   \   0000CA   75..00       MOV     ?V0 + 6,#0x0
   \   0000CD   78..         MOV     R0,#?V0 + 4
   \   0000CF   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D2   7C10         MOV     R4,#0x10
   \   0000D4   7D00         MOV     R5,#0x0
   \   0000D6   AA..         MOV     R2,?V0 + 2
   \   0000D8   AB..         MOV     R3,?V0 + 3
   \   0000DA   12....       LCALL   ??osal_memcpy?relay
   \   0000DD   7403         MOV     A,#0x3
   \   0000DF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E2   800D         SJMP    ??ZDSecMgrMasterKeyStore_5
    680                  }
    681                  else
    682                  {
    683                    osal_memset( entry, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   0000E4                ; Setup parameters for call to function osal_memset
   \   0000E4   7C10         MOV     R4,#0x10
   \   0000E6   7D00         MOV     R5,#0x0
   \   0000E8   7900         MOV     R1,#0x0
   \   0000EA   AA..         MOV     R2,?V0 + 2
   \   0000EC   AB..         MOV     R3,?V0 + 3
   \   0000EE   12....       LCALL   ??osal_memset?relay
    684                  }
    685          
    686                  // return successful results
    687                  status = ZSuccess;
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   0000F1   75..00       MOV     ?V0 + 7,#0x0
    688          
    689                  // break from loop
    690                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   0000F4   7E03         MOV     R6,#0x3
   \   0000F6   7F00         MOV     R7,#0x0
    691                }
    692              }
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   0000F8   EE           MOV     A,R6
   \   0000F9   2401         ADD     A,#0x1
   \   0000FB   FE           MOV     R6,A
   \   0000FC   EF           MOV     A,R7
   \   0000FD   3400         ADDC    A,#0x0
   \   0000FF   FF           MOV     R7,A
   \   000100   02....       LJMP    ??ZDSecMgrMasterKeyStore_1 & 0xFFFF
    693            }
    694          
    695            return status;
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000103   A9..         MOV     R1,?V0 + 7
   \   000105   7F0A         MOV     R7,#0xa
   \   000107   02....       LJMP    ?BANKED_LEAVE_XDATA
    696          }
    697          
    698          /******************************************************************************
    699           * @fn          ZDSecMgrEntryInit
    700           *
    701           * @brief       Initialize entry sub module
    702           *
    703           * @param       state - device initialization state
    704           *
    705           * @return      none
    706           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    707          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    708          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
    709            if (ZDSecMgrEntries == NULL)
   \   000007   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   E8           MOV     A,R0
   \   000010   49           ORL     A,R1
   \   000011   705F         JNZ     ??ZDSecMgrEntryInit_0
    710            {
    711              uint16 index;
    712          
    713              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   000013                ; Setup parameters for call to function osal_mem_alloc
   \   000013   7A57         MOV     R2,#0x57
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   ??osal_mem_alloc?relay
   \   00001A   8A..         MOV     ?V0 + 2,R2
   \   00001C   8B..         MOV     ?V0 + 3,R3
   \   00001E   A8..         MOV     R0,?V0 + 2
   \   000020   A9..         MOV     R1,?V0 + 3
   \   000022   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000025   E8           MOV     A,R0
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   E9           MOV     A,R1
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   E8           MOV     A,R0
   \   00002B   49           ORL     A,R1
   \   00002C   6044         JZ      ??ZDSecMgrEntryInit_0
    714              {
    715                return;
    716              }
    717          
    718              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   00002E   7E00         MOV     R6,#0x0
   \   000030   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryInit_1:
   \   000032   C3           CLR     C
   \   000033   EE           MOV     A,R6
   \   000034   9403         SUBB    A,#0x3
   \   000036   EF           MOV     A,R7
   \   000037   9400         SUBB    A,#0x0
   \   000039   5037         JNC     ??ZDSecMgrEntryInit_0
    719              {
    720                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \   00003B   EE           MOV     A,R6
   \   00003C   F8           MOV     R0,A
   \   00003D   EF           MOV     A,R7
   \   00003E   F9           MOV     R1,A
   \   00003F   E8           MOV     A,R0
   \   000040   75F01D       MOV     B,#0x1d
   \   000043   A4           MUL     AB
   \   000044   C8           XCH     A,R0
   \   000045   AAF0         MOV     R2,B
   \   000047   75F000       MOV     B,#0x0
   \   00004A   A4           MUL     AB
   \   00004B   2A           ADD     A,R2
   \   00004C   FA           MOV     R2,A
   \   00004D   75F01D       MOV     B,#0x1d
   \   000050   E9           MOV     A,R1
   \   000051   A4           MUL     AB
   \   000052   2A           ADD     A,R2
   \   000053   F9           MOV     R1,A
   \   000054   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000057   E0           MOVX    A,@DPTR
   \   000058   28           ADD     A,R0
   \   000059   FA           MOV     R2,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   39           ADDC    A,R1
   \   00005D   8A82         MOV     DPL,R2
   \   00005F   F583         MOV     DPH,A
   \   000061   74FE         MOV     A,#-0x2
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   74FF         MOV     A,#-0x1
   \   000067   F0           MOVX    @DPTR,A
    721              }
   \   000068   EE           MOV     A,R6
   \   000069   2401         ADD     A,#0x1
   \   00006B   FE           MOV     R6,A
   \   00006C   EF           MOV     A,R7
   \   00006D   3400         ADDC    A,#0x0
   \   00006F   FF           MOV     R7,A
   \   000070   80C0         SJMP    ??ZDSecMgrEntryInit_1
    722            }
    723          
    724          #if defined NV_RESTORE
    725            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    726            {
    727              ZDSecMgrRestoreFromNV();
    728            }
    729          #else
    730            (void)state;
    731          #endif
    732          }
   \                     ??ZDSecMgrEntryInit_0:
   \   000072   7F04         MOV     R7,#0x4
   \   000074   02....       LJMP    ?BANKED_LEAVE_XDATA
    733          
    734          /******************************************************************************
    735           * @fn          ZDSecMgrEntryLookup
    736           *
    737           * @brief       Lookup entry index using specified NWK address.
    738           *
    739           * @param       nwkAddr - [in] NWK address
    740           * @param       entry   - [out] valid entry
    741           *
    742           * @return      ZStatus_t
    743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    744          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    745          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
    746            ZStatus_t      status;
    747            uint16         index;
    748            AddrMgrEntry_t addrMgrEntry;
    749          
    750          
    751            // initialize results
    752            *entry = NULL;
   \   000012   85..82       MOV     DPL,?V0 + 0
   \   000015   85..83       MOV     DPH,?V0 + 1
   \   000018   7400         MOV     A,#0x0
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   7400         MOV     A,#0x0
   \   00001E   F0           MOVX    @DPTR,A
    753            status = ZNwkUnknownDevice;
   \   00001F   75..C8       MOV     ?V0 + 4,#-0x38
    754          
    755            // verify data is available
    756            if ( ZDSecMgrEntries != NULL )
   \   000022   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F8           MOV     R0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   E8           MOV     A,R0
   \   00002B   49           ORL     A,R1
   \   00002C   7003         JNZ     $+5
   \   00002E   02....       LJMP    ??ZDSecMgrEntryLookup_0 & 0xFFFF
    757            {
    758              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   7402         MOV     A,#0x2
   \   000039   F0           MOVX    @DPTR,A
    759              addrMgrEntry.nwkAddr = nwkAddr;
   \   00003A   7401         MOV     A,#0x1
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E5..         MOV     A,?V0 + 2
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   E5..         MOV     A,?V0 + 3
   \   000045   F0           MOVX    @DPTR,A
    760          
    761              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \   000046                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   AA82         MOV     R2,DPL
   \   00004E   AB83         MOV     R3,DPH
   \   000050   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000053   E9           MOV     A,R1
   \   000054   6401         XRL     A,#0x1
   \   000056   6003         JZ      $+5
   \   000058   02....       LJMP    ??ZDSecMgrEntryLookup_0 & 0xFFFF
    762              {
    763                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00005B   7E00         MOV     R6,#0x0
   \   00005D   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryLookup_1:
   \   00005F   C3           CLR     C
   \   000060   EE           MOV     A,R6
   \   000061   9403         SUBB    A,#0x3
   \   000063   EF           MOV     A,R7
   \   000064   9400         SUBB    A,#0x0
   \   000066   5079         JNC     ??ZDSecMgrEntryLookup_0
    764                {
    765                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \   000068   740B         MOV     A,#0xb
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FA           MOV     R2,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FB           MOV     R3,A
   \   000072   EE           MOV     A,R6
   \   000073   F8           MOV     R0,A
   \   000074   EF           MOV     A,R7
   \   000075   F9           MOV     R1,A
   \   000076   E8           MOV     A,R0
   \   000077   75F01D       MOV     B,#0x1d
   \   00007A   A4           MUL     AB
   \   00007B   C8           XCH     A,R0
   \   00007C   ACF0         MOV     R4,B
   \   00007E   75F000       MOV     B,#0x0
   \   000081   A4           MUL     AB
   \   000082   2C           ADD     A,R4
   \   000083   FC           MOV     R4,A
   \   000084   75F01D       MOV     B,#0x1d
   \   000087   E9           MOV     A,R1
   \   000088   A4           MUL     AB
   \   000089   2C           ADD     A,R4
   \   00008A   F9           MOV     R1,A
   \   00008B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   28           ADD     A,R0
   \   000090   FC           MOV     R4,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   39           ADDC    A,R1
   \   000094   8C82         MOV     DPL,R4
   \   000096   F583         MOV     DPH,A
   \   000098   E0           MOVX    A,@DPTR
   \   000099   6A           XRL     A,R2
   \   00009A   7003         JNZ     ??ZDSecMgrEntryLookup_2
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookup_2:
   \   00009F   7035         JNZ     ??ZDSecMgrEntryLookup_3
    766                  {
    767                    // return successful results
    768                    *entry = &ZDSecMgrEntries[index];
   \   0000A1   EE           MOV     A,R6
   \   0000A2   F8           MOV     R0,A
   \   0000A3   EF           MOV     A,R7
   \   0000A4   F9           MOV     R1,A
   \   0000A5   E8           MOV     A,R0
   \   0000A6   75F01D       MOV     B,#0x1d
   \   0000A9   A4           MUL     AB
   \   0000AA   C8           XCH     A,R0
   \   0000AB   AAF0         MOV     R2,B
   \   0000AD   75F000       MOV     B,#0x0
   \   0000B0   A4           MUL     AB
   \   0000B1   2A           ADD     A,R2
   \   0000B2   FA           MOV     R2,A
   \   0000B3   75F01D       MOV     B,#0x1d
   \   0000B6   E9           MOV     A,R1
   \   0000B7   A4           MUL     AB
   \   0000B8   2A           ADD     A,R2
   \   0000B9   F9           MOV     R1,A
   \   0000BA   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   28           ADD     A,R0
   \   0000BF   F8           MOV     R0,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   39           ADDC    A,R1
   \   0000C3   F9           MOV     R1,A
   \   0000C4   85..82       MOV     DPL,?V0 + 0
   \   0000C7   85..83       MOV     DPH,?V0 + 1
   \   0000CA   E8           MOV     A,R0
   \   0000CB   F0           MOVX    @DPTR,A
   \   0000CC   A3           INC     DPTR
   \   0000CD   E9           MOV     A,R1
   \   0000CE   F0           MOVX    @DPTR,A
    769                    status = ZSuccess;
   \   0000CF   75..00       MOV     ?V0 + 4,#0x0
    770          
    771                    // break from loop
    772                    index = ZDSECMGR_ENTRY_MAX;
   \   0000D2   7E03         MOV     R6,#0x3
   \   0000D4   7F00         MOV     R7,#0x0
    773                  }
    774                }
   \                     ??ZDSecMgrEntryLookup_3:
   \   0000D6   EE           MOV     A,R6
   \   0000D7   2401         ADD     A,#0x1
   \   0000D9   FE           MOV     R6,A
   \   0000DA   EF           MOV     A,R7
   \   0000DB   3400         ADDC    A,#0x0
   \   0000DD   FF           MOV     R7,A
   \   0000DE   02....       LJMP    ??ZDSecMgrEntryLookup_1 & 0xFFFF
    775              }
    776            }
    777          
    778            return status;
   \                     ??ZDSecMgrEntryLookup_0:
   \   0000E1   A9..         MOV     R1,?V0 + 4
   \   0000E3   740D         MOV     A,#0xd
   \   0000E5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E8   7F05         MOV     R7,#0x5
   \   0000EA   02....       LJMP    ?BANKED_LEAVE_XDATA
    779          }
    780          
    781          /******************************************************************************
    782           * @fn          ZDSecMgrEntryLookupAMI
    783           *
    784           * @brief       Lookup entry using specified address index
    785           *
    786           * @param       ami   - [in] Address Manager index
    787           * @param       entry - [out] valid entry
    788           *
    789           * @return      ZStatus_t
    790           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    791          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    792          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
    793            ZStatus_t status;
    794            uint16    index;
    795          
    796          
    797            // initialize results
    798            *entry = NULL;
   \   00000D   85..82       MOV     DPL,?V0 + 0
   \   000010   85..83       MOV     DPH,?V0 + 1
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
    799            status = ZNwkUnknownDevice;
   \   00001A   79C8         MOV     R1,#-0x38
    800          
    801            // verify data is available
    802            if ( ZDSecMgrEntries != NULL )
   \   00001C   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   FC           MOV     R4,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FD           MOV     R5,A
   \   000024   EC           MOV     A,R4
   \   000025   4D           ORL     A,R5
   \   000026   607A         JZ      ??ZDSecMgrEntryLookupAMI_0
    803            {
    804              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000028   7A00         MOV     R2,#0x0
   \   00002A   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   00002C   C3           CLR     C
   \   00002D   EA           MOV     A,R2
   \   00002E   9403         SUBB    A,#0x3
   \   000030   EB           MOV     A,R3
   \   000031   9400         SUBB    A,#0x0
   \   000033   506D         JNC     ??ZDSecMgrEntryLookupAMI_0
    805              {
    806                if ( ZDSecMgrEntries[index].ami == ami )
   \   000035   EA           MOV     A,R2
   \   000036   FC           MOV     R4,A
   \   000037   EB           MOV     A,R3
   \   000038   FD           MOV     R5,A
   \   000039   EC           MOV     A,R4
   \   00003A   75F01D       MOV     B,#0x1d
   \   00003D   A4           MUL     AB
   \   00003E   CC           XCH     A,R4
   \   00003F   A8F0         MOV     R0,B
   \   000041   75F000       MOV     B,#0x0
   \   000044   A4           MUL     AB
   \   000045   28           ADD     A,R0
   \   000046   F8           MOV     R0,A
   \   000047   75F01D       MOV     B,#0x1d
   \   00004A   ED           MOV     A,R5
   \   00004B   A4           MUL     AB
   \   00004C   28           ADD     A,R0
   \   00004D   FD           MOV     R5,A
   \   00004E   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2C           ADD     A,R4
   \   000053   F8           MOV     R0,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   3D           ADDC    A,R5
   \   000057   8882         MOV     DPL,R0
   \   000059   F583         MOV     DPH,A
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   6E           XRL     A,R6
   \   00005D   7003         JNZ     ??ZDSecMgrEntryLookupAMI_2
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   6F           XRL     A,R7
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000062   7034         JNZ     ??ZDSecMgrEntryLookupAMI_3
    807                {
    808                  // return successful results
    809                  *entry = &ZDSecMgrEntries[index];
   \   000064   EA           MOV     A,R2
   \   000065   FC           MOV     R4,A
   \   000066   EB           MOV     A,R3
   \   000067   FD           MOV     R5,A
   \   000068   EC           MOV     A,R4
   \   000069   75F01D       MOV     B,#0x1d
   \   00006C   A4           MUL     AB
   \   00006D   CC           XCH     A,R4
   \   00006E   A8F0         MOV     R0,B
   \   000070   75F000       MOV     B,#0x0
   \   000073   A4           MUL     AB
   \   000074   28           ADD     A,R0
   \   000075   F8           MOV     R0,A
   \   000076   75F01D       MOV     B,#0x1d
   \   000079   ED           MOV     A,R5
   \   00007A   A4           MUL     AB
   \   00007B   28           ADD     A,R0
   \   00007C   FD           MOV     R5,A
   \   00007D   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000080   E0           MOVX    A,@DPTR
   \   000081   2C           ADD     A,R4
   \   000082   FC           MOV     R4,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   3D           ADDC    A,R5
   \   000086   FD           MOV     R5,A
   \   000087   85..82       MOV     DPL,?V0 + 0
   \   00008A   85..83       MOV     DPH,?V0 + 1
   \   00008D   EC           MOV     A,R4
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   A3           INC     DPTR
   \   000090   ED           MOV     A,R5
   \   000091   F0           MOVX    @DPTR,A
    810                  status = ZSuccess;
   \   000092   7900         MOV     R1,#0x0
    811          
    812                  // break from loop
    813                  index = ZDSECMGR_ENTRY_MAX;
   \   000094   7A03         MOV     R2,#0x3
   \   000096   7B00         MOV     R3,#0x0
    814                }
    815              }
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000098   EA           MOV     A,R2
   \   000099   2401         ADD     A,#0x1
   \   00009B   FA           MOV     R2,A
   \   00009C   EB           MOV     A,R3
   \   00009D   3400         ADDC    A,#0x0
   \   00009F   FB           MOV     R3,A
   \   0000A0   808A         SJMP    ??ZDSecMgrEntryLookupAMI_1
    816            }
    817          
    818            return status;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   0000A2   7F02         MOV     R7,#0x2
   \   0000A4   02....       LJMP    ?BANKED_LEAVE_XDATA
    819          }
    820          
    821          /******************************************************************************
    822           * @fn          ZDSecMgrEntryLookupExt
    823           *
    824           * @brief       Lookup entry index using specified EXT address.
    825           *
    826           * @param       extAddr - [in] EXT address
    827           * @param       entry   - [out] valid entry
    828           *
    829           * @return      ZStatus_t
    830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    831          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    832          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
    833            ZStatus_t status;
    834            uint16    ami;
    835          
    836          
    837            // initialize results
    838            *entry = NULL;
   \   000012   8E82         MOV     DPL,R6
   \   000014   8F83         MOV     DPH,R7
   \   000016   7400         MOV     A,#0x0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   7400         MOV     A,#0x0
   \   00001C   F0           MOVX    @DPTR,A
    839            status = ZNwkUnknownDevice;
   \   00001D   75..C8       MOV     ?V0 + 2,#-0x38
    840          
    841            // lookup address index
    842            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000020                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   AC82         MOV     R4,DPL
   \   000028   AD83         MOV     R5,DPH
   \   00002A   AA..         MOV     R2,?V0 + 0
   \   00002C   AB..         MOV     R3,?V0 + 1
   \   00002E   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000031   E9           MOV     A,R1
   \   000032   7015         JNZ     ??ZDSecMgrEntryLookupExt_0
    843            {
    844              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000034                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000034   EE           MOV     A,R6
   \   000035   FC           MOV     R4,A
   \   000036   EF           MOV     A,R7
   \   000037   FD           MOV     R5,A
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FA           MOV     R2,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   FB           MOV     R3,A
   \   000043   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000046   E9           MOV     A,R1
   \   000047   F5..         MOV     ?V0 + 2,A
    845            }
    846          
    847            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000049   A9..         MOV     R1,?V0 + 2
   \   00004B   7402         MOV     A,#0x2
   \   00004D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000050   7F03         MOV     R7,#0x3
   \   000052   02....       LJMP    ?BANKED_LEAVE_XDATA
    848          }
    849          
    850          /******************************************************************************
    851           * @fn          ZDSecMgrEntryFree
    852           *
    853           * @brief       Free entry.
    854           *
    855           * @param       entry - [in] valid entry
    856           *
    857           * @return      ZStatus_t
    858           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    859          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    860          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    861            entry->ami = INVALID_NODE_ADDR;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   74FE         MOV     A,#-0x2
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   74FF         MOV     A,#-0x1
   \   00000E   F0           MOVX    @DPTR,A
    862          }
   \   00000F   D083         POP     DPH
   \   000011   D082         POP     DPL
   \   000013   02....       LJMP    ?BRET
    863          
    864          /******************************************************************************
    865           * @fn          ZDSecMgrEntryNew
    866           *
    867           * @brief       Get a new entry.
    868           *
    869           * @param       entry - [out] valid entry
    870           *
    871           * @return      ZStatus_t
    872           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    873          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    874          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    875            ZStatus_t status;
    876            uint16    index;
    877          
    878          
    879            // initialize results
    880            *entry = NULL;
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
    881            status = ZNwkUnknownDevice;
   \   000014   79C8         MOV     R1,#-0x38
    882          
    883            // verify data is available
    884            if ( ZDSecMgrEntries != NULL )
   \   000016   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FC           MOV     R4,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FD           MOV     R5,A
   \   00001E   EC           MOV     A,R4
   \   00001F   4D           ORL     A,R5
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??ZDSecMgrEntryNew_0 & 0xFFFF
    885            {
    886              // find available entry
    887              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrEntryNew_1:
   \   000029   C3           CLR     C
   \   00002A   EA           MOV     A,R2
   \   00002B   9403         SUBB    A,#0x3
   \   00002D   EB           MOV     A,R3
   \   00002E   9400         SUBB    A,#0x0
   \   000030   4003         JC      $+5
   \   000032   02....       LJMP    ??ZDSecMgrEntryNew_0 & 0xFFFF
    888              {
    889                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \   000035   EA           MOV     A,R2
   \   000036   FC           MOV     R4,A
   \   000037   EB           MOV     A,R3
   \   000038   FD           MOV     R5,A
   \   000039   EC           MOV     A,R4
   \   00003A   75F01D       MOV     B,#0x1d
   \   00003D   A4           MUL     AB
   \   00003E   CC           XCH     A,R4
   \   00003F   A8F0         MOV     R0,B
   \   000041   75F000       MOV     B,#0x0
   \   000044   A4           MUL     AB
   \   000045   28           ADD     A,R0
   \   000046   F8           MOV     R0,A
   \   000047   75F01D       MOV     B,#0x1d
   \   00004A   ED           MOV     A,R5
   \   00004B   A4           MUL     AB
   \   00004C   28           ADD     A,R0
   \   00004D   FD           MOV     R5,A
   \   00004E   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2C           ADD     A,R4
   \   000053   F8           MOV     R0,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   3D           ADDC    A,R5
   \   000057   8882         MOV     DPL,R0
   \   000059   F583         MOV     DPH,A
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   64FE         XRL     A,#0xfe
   \   00005E   7004         JNZ     ??ZDSecMgrEntryNew_2
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrEntryNew_2:
   \   000064   7062         JNZ     ??ZDSecMgrEntryNew_3
    890                {
    891                  // return successful result
    892                  *entry = &ZDSecMgrEntries[index];
   \   000066   EA           MOV     A,R2
   \   000067   FC           MOV     R4,A
   \   000068   EB           MOV     A,R3
   \   000069   FD           MOV     R5,A
   \   00006A   EC           MOV     A,R4
   \   00006B   75F01D       MOV     B,#0x1d
   \   00006E   A4           MUL     AB
   \   00006F   CC           XCH     A,R4
   \   000070   A8F0         MOV     R0,B
   \   000072   75F000       MOV     B,#0x0
   \   000075   A4           MUL     AB
   \   000076   28           ADD     A,R0
   \   000077   F8           MOV     R0,A
   \   000078   75F01D       MOV     B,#0x1d
   \   00007B   ED           MOV     A,R5
   \   00007C   A4           MUL     AB
   \   00007D   28           ADD     A,R0
   \   00007E   FD           MOV     R5,A
   \   00007F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2C           ADD     A,R4
   \   000084   FC           MOV     R4,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   3D           ADDC    A,R5
   \   000088   FD           MOV     R5,A
   \   000089   8E82         MOV     DPL,R6
   \   00008B   8F83         MOV     DPH,R7
   \   00008D   EC           MOV     A,R4
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   A3           INC     DPTR
   \   000090   ED           MOV     A,R5
   \   000091   F0           MOVX    @DPTR,A
    893                  status = ZSuccess;
   \   000092   7900         MOV     R1,#0x0
    894          
    895                  // Set the authentication option to default
    896                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000094   EA           MOV     A,R2
   \   000095   FC           MOV     R4,A
   \   000096   EB           MOV     A,R3
   \   000097   FD           MOV     R5,A
   \   000098   EC           MOV     A,R4
   \   000099   75F01D       MOV     B,#0x1d
   \   00009C   A4           MUL     AB
   \   00009D   CC           XCH     A,R4
   \   00009E   A8F0         MOV     R0,B
   \   0000A0   75F000       MOV     B,#0x0
   \   0000A3   A4           MUL     AB
   \   0000A4   28           ADD     A,R0
   \   0000A5   F8           MOV     R0,A
   \   0000A6   75F01D       MOV     B,#0x1d
   \   0000A9   ED           MOV     A,R5
   \   0000AA   A4           MUL     AB
   \   0000AB   28           ADD     A,R0
   \   0000AC   FD           MOV     R5,A
   \   0000AD   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   2C           ADD     A,R4
   \   0000B2   FC           MOV     R4,A
   \   0000B3   A3           INC     DPTR
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   3D           ADDC    A,R5
   \   0000B6   FD           MOV     R5,A
   \   0000B7   EC           MOV     A,R4
   \   0000B8   241C         ADD     A,#0x1c
   \   0000BA   F582         MOV     DPL,A
   \   0000BC   ED           MOV     A,R5
   \   0000BD   3400         ADDC    A,#0x0
   \   0000BF   F583         MOV     DPH,A
   \   0000C1   7400         MOV     A,#0x0
   \   0000C3   F0           MOVX    @DPTR,A
    897          
    898                  // break from loop
    899                  index = ZDSECMGR_ENTRY_MAX;
   \   0000C4   7A03         MOV     R2,#0x3
   \   0000C6   7B00         MOV     R3,#0x0
    900                }
    901              }
   \                     ??ZDSecMgrEntryNew_3:
   \   0000C8   EA           MOV     A,R2
   \   0000C9   2401         ADD     A,#0x1
   \   0000CB   FA           MOV     R2,A
   \   0000CC   EB           MOV     A,R3
   \   0000CD   3400         ADDC    A,#0x0
   \   0000CF   FB           MOV     R3,A
   \   0000D0   02....       LJMP    ??ZDSecMgrEntryNew_1 & 0xFFFF
    902            }
    903          
    904            return status;
   \                     ??ZDSecMgrEntryNew_0:
   \   0000D3   7F01         MOV     R7,#0x1
   \   0000D5   02....       LJMP    ?BANKED_LEAVE_XDATA
    905          }
    906          
    907          /******************************************************************************
    908           * @fn          ZDSecMgrCtrlInit
    909           *
    910           * @brief       Initialize control sub module
    911           *
    912           * @param       none
    913           *
    914           * @return      none
    915           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    916          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    917          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    918            uint16 size;
    919            uint16 index;
    920          
    921            // allocate entry data
    922            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
   \   000005   75..15       MOV     ?V0 + 0,#0x15
   \   000008   75..00       MOV     ?V0 + 1,#0x0
    923          
    924            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   AA..         MOV     R2,?V0 + 0
   \   00000D   AB..         MOV     R3,?V0 + 1
   \   00000F   12....       LCALL   ??osal_mem_alloc?relay
   \   000012   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000015   EA           MOV     A,R2
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   EB           MOV     A,R3
   \   000019   F0           MOVX    @DPTR,A
    925          
    926            // initialize data
    927            if ( ZDSecMgrCtrlData != NULL )
   \   00001A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   49           ORL     A,R1
   \   000024   6045         JZ      ??ZDSecMgrCtrlInit_0
    928            {
    929              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000026   7E00         MOV     R6,#0x0
   \   000028   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrCtrlInit_1:
   \   00002A   C3           CLR     C
   \   00002B   EE           MOV     A,R6
   \   00002C   9403         SUBB    A,#0x3
   \   00002E   EF           MOV     A,R7
   \   00002F   9400         SUBB    A,#0x0
   \   000031   5038         JNC     ??ZDSecMgrCtrlInit_0
    930              {
    931                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \   000033   EE           MOV     A,R6
   \   000034   F8           MOV     R0,A
   \   000035   EF           MOV     A,R7
   \   000036   F9           MOV     R1,A
   \   000037   E8           MOV     A,R0
   \   000038   75F007       MOV     B,#0x7
   \   00003B   A4           MUL     AB
   \   00003C   C8           XCH     A,R0
   \   00003D   AAF0         MOV     R2,B
   \   00003F   75F000       MOV     B,#0x0
   \   000042   A4           MUL     AB
   \   000043   2A           ADD     A,R2
   \   000044   FA           MOV     R2,A
   \   000045   75F007       MOV     B,#0x7
   \   000048   E9           MOV     A,R1
   \   000049   A4           MUL     AB
   \   00004A   2A           ADD     A,R2
   \   00004B   F9           MOV     R1,A
   \   00004C   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   28           ADD     A,R0
   \   000051   FA           MOV     R2,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   39           ADDC    A,R1
   \   000055   8A82         MOV     DPL,R2
   \   000057   F583         MOV     DPH,A
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   7400         MOV     A,#0x0
   \   000060   F0           MOVX    @DPTR,A
    932              }
   \   000061   EE           MOV     A,R6
   \   000062   2401         ADD     A,#0x1
   \   000064   FE           MOV     R6,A
   \   000065   EF           MOV     A,R7
   \   000066   3400         ADDC    A,#0x0
   \   000068   FF           MOV     R7,A
   \   000069   80BF         SJMP    ??ZDSecMgrCtrlInit_1
    933            }
    934          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   00006B   7F02         MOV     R7,#0x2
   \   00006D   02....       LJMP    ?BANKED_LEAVE_XDATA
    935          
    936          /******************************************************************************
    937           * @fn          ZDSecMgrCtrlRelease
    938           *
    939           * @brief       Release control data.
    940           *
    941           * @param       ctrl - [in] valid control data
    942           *
    943           * @return      none
    944           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    945          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    946          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    947            // should always be enough entry control data
    948            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
    949          }
   \   000010   D083         POP     DPH
   \   000012   D082         POP     DPL
   \   000014   02....       LJMP    ?BRET
    950          
    951          /******************************************************************************
    952           * @fn          ZDSecMgrCtrlLookup
    953           *
    954           * @brief       Lookup control data.
    955           *
    956           * @param       entry - [in] valid entry data
    957           * @param       ctrl  - [out] control data - NULL if not found
    958           *
    959           * @return      none
    960           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    961          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    962          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    963            uint16 index;
    964          
    965          
    966            // initialize search results
    967            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
    968          
    969            // verify data is available
    970            if ( ZDSecMgrCtrlData != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FB           MOV     R3,A
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrCtrlLookup_0 & 0xFFFF
    971            {
    972              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000023   7800         MOV     R0,#0x0
   \   000025   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrCtrlLookup_1:
   \   000027   C3           CLR     C
   \   000028   E8           MOV     A,R0
   \   000029   9403         SUBB    A,#0x3
   \   00002B   E9           MOV     A,R1
   \   00002C   9400         SUBB    A,#0x0
   \   00002E   4003         JC      $+5
   \   000030   02....       LJMP    ??ZDSecMgrCtrlLookup_0 & 0xFFFF
    973              {
    974                // make sure control data is in use
    975                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \   000033   E8           MOV     A,R0
   \   000034   FA           MOV     R2,A
   \   000035   E9           MOV     A,R1
   \   000036   FB           MOV     R3,A
   \   000037   EA           MOV     A,R2
   \   000038   75F007       MOV     B,#0x7
   \   00003B   A4           MUL     AB
   \   00003C   CA           XCH     A,R2
   \   00003D   85F0..       MOV     ?V0 + 0,B
   \   000040   75F000       MOV     B,#0x0
   \   000043   A4           MUL     AB
   \   000044   25..         ADD     A,?V0 + 0
   \   000046   F5..         MOV     ?V0 + 0,A
   \   000048   75F007       MOV     B,#0x7
   \   00004B   EB           MOV     A,R3
   \   00004C   A4           MUL     AB
   \   00004D   25..         ADD     A,?V0 + 0
   \   00004F   FB           MOV     R3,A
   \   000050   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000053   E0           MOVX    A,@DPTR
   \   000054   2A           ADD     A,R2
   \   000055   F5..         MOV     ?V0 + 0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   3B           ADDC    A,R3
   \   00005A   85..82       MOV     DPL,?V0 + 0
   \   00005D   F583         MOV     DPH,A
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   606D         JZ      ??ZDSecMgrCtrlLookup_2
    976                {
    977                  // check for entry match
    978                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000067   E8           MOV     A,R0
   \   000068   FA           MOV     R2,A
   \   000069   E9           MOV     A,R1
   \   00006A   FB           MOV     R3,A
   \   00006B   EA           MOV     A,R2
   \   00006C   75F007       MOV     B,#0x7
   \   00006F   A4           MUL     AB
   \   000070   CA           XCH     A,R2
   \   000071   85F0..       MOV     ?V0 + 0,B
   \   000074   75F000       MOV     B,#0x0
   \   000077   A4           MUL     AB
   \   000078   25..         ADD     A,?V0 + 0
   \   00007A   F5..         MOV     ?V0 + 0,A
   \   00007C   75F007       MOV     B,#0x7
   \   00007F   EB           MOV     A,R3
   \   000080   A4           MUL     AB
   \   000081   25..         ADD     A,?V0 + 0
   \   000083   FB           MOV     R3,A
   \   000084   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000087   E0           MOVX    A,@DPTR
   \   000088   2A           ADD     A,R2
   \   000089   F5..         MOV     ?V0 + 0,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   3B           ADDC    A,R3
   \   00008E   85..82       MOV     DPL,?V0 + 0
   \   000091   F583         MOV     DPH,A
   \   000093   E0           MOVX    A,@DPTR
   \   000094   FA           MOV     R2,A
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   FB           MOV     R3,A
   \   000098   EE           MOV     A,R6
   \   000099   6A           XRL     A,R2
   \   00009A   7002         JNZ     ??ZDSecMgrCtrlLookup_3
   \   00009C   EF           MOV     A,R7
   \   00009D   6B           XRL     A,R3
   \                     ??ZDSecMgrCtrlLookup_3:
   \   00009E   7034         JNZ     ??ZDSecMgrCtrlLookup_2
    979                  {
    980                    // return this control data
    981                    *ctrl = &ZDSecMgrCtrlData[index];
   \   0000A0   E8           MOV     A,R0
   \   0000A1   FA           MOV     R2,A
   \   0000A2   E9           MOV     A,R1
   \   0000A3   FB           MOV     R3,A
   \   0000A4   EA           MOV     A,R2
   \   0000A5   75F007       MOV     B,#0x7
   \   0000A8   A4           MUL     AB
   \   0000A9   CA           XCH     A,R2
   \   0000AA   85F0..       MOV     ?V0 + 0,B
   \   0000AD   75F000       MOV     B,#0x0
   \   0000B0   A4           MUL     AB
   \   0000B1   25..         ADD     A,?V0 + 0
   \   0000B3   F5..         MOV     ?V0 + 0,A
   \   0000B5   75F007       MOV     B,#0x7
   \   0000B8   EB           MOV     A,R3
   \   0000B9   A4           MUL     AB
   \   0000BA   25..         ADD     A,?V0 + 0
   \   0000BC   FB           MOV     R3,A
   \   0000BD   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   2A           ADD     A,R2
   \   0000C2   FA           MOV     R2,A
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   3B           ADDC    A,R3
   \   0000C6   FB           MOV     R3,A
   \   0000C7   8C82         MOV     DPL,R4
   \   0000C9   8D83         MOV     DPH,R5
   \   0000CB   EA           MOV     A,R2
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   EB           MOV     A,R3
   \   0000CF   F0           MOVX    @DPTR,A
    982          
    983                    // break from loop
    984                    index = ZDSECMGR_CTRL_MAX;
   \   0000D0   7803         MOV     R0,#0x3
   \   0000D2   7900         MOV     R1,#0x0
    985                  }
    986                }
    987              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   0000D4   E8           MOV     A,R0
   \   0000D5   2401         ADD     A,#0x1
   \   0000D7   F8           MOV     R0,A
   \   0000D8   E9           MOV     A,R1
   \   0000D9   3400         ADDC    A,#0x0
   \   0000DB   F9           MOV     R1,A
   \   0000DC   02....       LJMP    ??ZDSecMgrCtrlLookup_1 & 0xFFFF
    988            }
    989          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   0000DF   7F01         MOV     R7,#0x1
   \   0000E1   02....       LJMP    ?BANKED_LEAVE_XDATA
    990          
    991          /******************************************************************************
    992           * @fn          ZDSecMgrCtrlSet
    993           *
    994           * @brief       Set control data.
    995           *
    996           * @param       device - [in] valid device data
    997           * @param       entry  - [in] valid entry data
    998           * @param       ctrl   - [in] valid control data
    999           *
   1000           * @return      none
   1001           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1002          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1003                                ZDSecMgrEntry_t*  entry,
   1004                                ZDSecMgrCtrl_t*   ctrl )
   1005          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   1006            // set control date
   1007            ctrl->parentAddr = device->parentAddr;
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
   1008            ctrl->secure     = device->secure;
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   8882         MOV     DPL,R0
   \   000034   8983         MOV     DPH,R1
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   F0           MOVX    @DPTR,A
   1009            ctrl->entry      = entry;
   \   00003B   8882         MOV     DPL,R0
   \   00003D   8983         MOV     DPH,R1
   \   00003F   EC           MOV     A,R4
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   ED           MOV     A,R5
   \   000043   F0           MOVX    @DPTR,A
   1010            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \   000044   8882         MOV     DPL,R0
   \   000046   8983         MOV     DPH,R1
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   7401         MOV     A,#0x1
   \   00004F   F0           MOVX    @DPTR,A
   1011            ctrl->cntr       = 0;
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   7400         MOV     A,#0x0
   \   00005C   F0           MOVX    @DPTR,A
   1012          
   1013            // set device pointer
   1014            device->ctrl = ctrl;
   \   00005D   8A82         MOV     DPL,R2
   \   00005F   8B83         MOV     DPH,R3
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   E8           MOV     A,R0
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   A3           INC     DPTR
   \   00006C   E9           MOV     A,R1
   \   00006D   F0           MOVX    @DPTR,A
   1015          }
   \   00006E   7F01         MOV     R7,#0x1
   \   000070   02....       LJMP    ?BANKED_LEAVE_XDATA
   1016          
   1017          /******************************************************************************
   1018           * @fn          ZDSecMgrCtrlAdd
   1019           *
   1020           * @brief       Add control data.
   1021           *
   1022           * @param       device - [in] valid device data
   1023           * @param       entry  - [in] valid entry data
   1024           *
   1025           * @return      ZStatus_t
   1026           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1027          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1028          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   1029            ZStatus_t status;
   1030            uint16    index;
   1031          
   1032          
   1033            // initialize results
   1034            status = ZNwkUnknownDevice;
   \   00000D   75..C8       MOV     ?V0 + 4,#-0x38
   1035          
   1036            // verify data is available
   1037            if ( ZDSecMgrCtrlData != NULL )
   \   000010   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??ZDSecMgrCtrlAdd_0 & 0xFFFF
   1038            {
   1039              // look for an empty slot
   1040              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrCtrlAdd_1:
   \   000023   C3           CLR     C
   \   000024   EE           MOV     A,R6
   \   000025   9403         SUBB    A,#0x3
   \   000027   EF           MOV     A,R7
   \   000028   9400         SUBB    A,#0x0
   \   00002A   507A         JNC     ??ZDSecMgrCtrlAdd_0
   1041              {
   1042                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \   00002C   EE           MOV     A,R6
   \   00002D   F8           MOV     R0,A
   \   00002E   EF           MOV     A,R7
   \   00002F   F9           MOV     R1,A
   \   000030   E8           MOV     A,R0
   \   000031   75F007       MOV     B,#0x7
   \   000034   A4           MUL     AB
   \   000035   C8           XCH     A,R0
   \   000036   AAF0         MOV     R2,B
   \   000038   75F000       MOV     B,#0x0
   \   00003B   A4           MUL     AB
   \   00003C   2A           ADD     A,R2
   \   00003D   FA           MOV     R2,A
   \   00003E   75F007       MOV     B,#0x7
   \   000041   E9           MOV     A,R1
   \   000042   A4           MUL     AB
   \   000043   2A           ADD     A,R2
   \   000044   F9           MOV     R1,A
   \   000045   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000048   E0           MOVX    A,@DPTR
   \   000049   28           ADD     A,R0
   \   00004A   FA           MOV     R2,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   39           ADDC    A,R1
   \   00004E   8A82         MOV     DPL,R2
   \   000050   F583         MOV     DPH,A
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   7041         JNZ     ??ZDSecMgrCtrlAdd_2
   1043                {
   1044                  // return successful results
   1045                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   00005A                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   00005A   EE           MOV     A,R6
   \   00005B   F8           MOV     R0,A
   \   00005C   EF           MOV     A,R7
   \   00005D   F9           MOV     R1,A
   \   00005E   E8           MOV     A,R0
   \   00005F   75F007       MOV     B,#0x7
   \   000062   A4           MUL     AB
   \   000063   C8           XCH     A,R0
   \   000064   AAF0         MOV     R2,B
   \   000066   75F000       MOV     B,#0x0
   \   000069   A4           MUL     AB
   \   00006A   2A           ADD     A,R2
   \   00006B   FA           MOV     R2,A
   \   00006C   75F007       MOV     B,#0x7
   \   00006F   E9           MOV     A,R1
   \   000070   A4           MUL     AB
   \   000071   2A           ADD     A,R2
   \   000072   F9           MOV     R1,A
   \   000073   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000076   E0           MOVX    A,@DPTR
   \   000077   28           ADD     A,R0
   \   000078   F5..         MOV     ?V0 + 6,A
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   39           ADDC    A,R1
   \   00007D   F5..         MOV     ?V0 + 7,A
   \   00007F   78..         MOV     R0,#?V0 + 6
   \   000081   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000084   AC..         MOV     R4,?V0 + 0
   \   000086   AD..         MOV     R5,?V0 + 1
   \   000088   AA..         MOV     R2,?V0 + 2
   \   00008A   AB..         MOV     R3,?V0 + 3
   \   00008C   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   00008F   7402         MOV     A,#0x2
   \   000091   12....       LCALL   ?DEALLOC_XSTACK8
   1046          
   1047                  status = ZSuccess;
   \   000094   75..00       MOV     ?V0 + 4,#0x0
   1048          
   1049                  // break from loop
   1050                  index = ZDSECMGR_CTRL_MAX;
   \   000097   7E03         MOV     R6,#0x3
   \   000099   7F00         MOV     R7,#0x0
   1051                }
   1052              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   00009B   EE           MOV     A,R6
   \   00009C   2401         ADD     A,#0x1
   \   00009E   FE           MOV     R6,A
   \   00009F   EF           MOV     A,R7
   \   0000A0   3400         ADDC    A,#0x0
   \   0000A2   FF           MOV     R7,A
   \   0000A3   02....       LJMP    ??ZDSecMgrCtrlAdd_1 & 0xFFFF
   1053            }
   1054          
   1055            return status;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   0000A6   A9..         MOV     R1,?V0 + 4
   \   0000A8   7F08         MOV     R7,#0x8
   \   0000AA   02....       LJMP    ?BANKED_LEAVE_XDATA
   1056          }
   1057          
   1058          /******************************************************************************
   1059           * @fn          ZDSecMgrCtrlTerm
   1060           *
   1061           * @brief       Terminate device control.
   1062           *
   1063           * @param       entry - [in] valid entry data
   1064           *
   1065           * @return      none
   1066           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1067          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1068          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1069            ZDSecMgrCtrl_t* ctrl;
   1070          
   1071            // remove device from control data
   1072            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   00000E                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1073          
   1074            if ( ctrl != NULL )
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F8           MOV     R0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   E8           MOV     A,R0
   \   00002B   49           ORL     A,R1
   \   00002C   600E         JZ      ??ZDSecMgrCtrlTerm_0
   1075            {
   1076              ZDSecMgrCtrlRelease ( ctrl );
   \   00002E                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   E0           MOVX    A,@DPTR
   \   000035   FA           MOV     R2,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??ZDSecMgrCtrlRelease?relay
   1077            }
   1078          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000041   7F01         MOV     R7,#0x1
   \   000043   02....       LJMP    ?BANKED_LEAVE_XDATA
   1079          
   1080          /******************************************************************************
   1081           * @fn          ZDSecMgrCtrlReset
   1082           *
   1083           * @brief       Reset control data.
   1084           *
   1085           * @param       device - [in] valid device data
   1086           * @param       entry  - [in] valid entry data
   1087           *
   1088           * @return      ZStatus_t
   1089           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1090          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1091          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1092            ZStatus_t       status;
   1093            ZDSecMgrCtrl_t* ctrl;
   1094          
   1095          
   1096            // initialize results
   1097            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 2,#-0x38
   1098          
   1099            // look for a match for the entry
   1100            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000015                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   AC82         MOV     R4,DPL
   \   00001D   AD83         MOV     R5,DPH
   \   00001F   EE           MOV     A,R6
   \   000020   FA           MOV     R2,A
   \   000021   EF           MOV     A,R7
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1101          
   1102            if ( ctrl != NULL )
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F8           MOV     R0,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F9           MOV     R1,A
   \   000031   E8           MOV     A,R0
   \   000032   49           ORL     A,R1
   \   000033   601E         JZ      ??ZDSecMgrCtrlReset_0
   1103            {
   1104              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000035                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000035   85..82       MOV     DPL,?XSP + 0
   \   000038   85..83       MOV     DPH,?XSP + 1
   \   00003B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003E   EE           MOV     A,R6
   \   00003F   FC           MOV     R4,A
   \   000040   EF           MOV     A,R7
   \   000041   FD           MOV     R5,A
   \   000042   AA..         MOV     R2,?V0 + 0
   \   000044   AB..         MOV     R3,?V0 + 1
   \   000046   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   1105          
   1106              status = ZSuccess;
   \   00004E   75..00       MOV     ?V0 + 2,#0x0
   \   000051   800E         SJMP    ??ZDSecMgrCtrlReset_1
   1107            }
   1108            else
   1109            {
   1110              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   000053                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   000053   EE           MOV     A,R6
   \   000054   FC           MOV     R4,A
   \   000055   EF           MOV     A,R7
   \   000056   FD           MOV     R5,A
   \   000057   AA..         MOV     R2,?V0 + 0
   \   000059   AB..         MOV     R3,?V0 + 1
   \   00005B   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   \   00005E   E9           MOV     A,R1
   \   00005F   F5..         MOV     ?V0 + 2,A
   1111            }
   1112          
   1113            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   000061   A9..         MOV     R1,?V0 + 2
   \   000063   7402         MOV     A,#0x2
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   7F03         MOV     R7,#0x3
   \   00006A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1114          }
   1115          
   1116          /******************************************************************************
   1117           * @fn          ZDSecMgrMasterKeyLoad
   1118           *
   1119           * @brief       Load the MASTER key for device with specified EXT
   1120           *              address.
   1121           *
   1122           * @param       extAddr - [in] EXT address of device
   1123           * @param       key     - [in] MASTER key shared with device
   1124           *
   1125           * @return      ZStatus_t
   1126           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1127          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1128          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   1129            ZStatus_t status;
   1130            uint8*    loaded;
   1131            uint16    ami;
   1132          
   1133          
   1134            // set status based on policy
   1135            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   000012                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000023   E9           MOV     A,R1
   \   000024   F5..         MOV     ?V0 + 2,A
   1136          
   1137            if ( status == ZSuccess )
   \   000026   E5..         MOV     A,?V0 + 2
   \   000028   7055         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1138            {
   1139              // get the address index
   1140              if ( ZDSecMgrMasterKeyLookup( ami, &loaded ) == ZSuccess )
   \   00002A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00002A   7402         MOV     A,#0x2
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   AC82         MOV     R4,DPL
   \   000031   AD83         MOV     R5,DPH
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FA           MOV     R2,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000041   E9           MOV     A,R1
   \   000042   7026         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1141              {
   1142                // overwrite old key
   1143                osal_memcpy( loaded, key, SEC_KEY_LEN );
   \   000044                ; Setup parameters for call to function osal_memcpy
   \   000044   85....       MOV     ?V0 + 4,?V0 + 0
   \   000047   85....       MOV     ?V0 + 5,?V0 + 1
   \   00004A   75..00       MOV     ?V0 + 6,#0x0
   \   00004D   78..         MOV     R0,#?V0 + 4
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000052   7C10         MOV     R4,#0x10
   \   000054   7D00         MOV     R5,#0x0
   \   000056   7405         MOV     A,#0x5
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   FA           MOV     R2,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   FB           MOV     R3,A
   \   000060   12....       LCALL   ??osal_memcpy?relay
   \   000063   7403         MOV     A,#0x3
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   8015         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1144              }
   1145              else
   1146              {
   1147                // store new key -- NULL will zero key
   1148                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   00006A                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00006A   AC..         MOV     R4,?V0 + 0
   \   00006C   AD..         MOV     R5,?V0 + 1
   \   00006E   85..82       MOV     DPL,?XSP + 0
   \   000071   85..83       MOV     DPH,?XSP + 1
   \   000074   E0           MOVX    A,@DPTR
   \   000075   FA           MOV     R2,A
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   FB           MOV     R3,A
   \   000079   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   00007C   E9           MOV     A,R1
   \   00007D   F5..         MOV     ?V0 + 2,A
   1149              }
   1150            }
   1151          
   1152            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   00007F   A9..         MOV     R1,?V0 + 2
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?DEALLOC_XSTACK8
   \   000086   7F07         MOV     R7,#0x7
   \   000088   02....       LJMP    ?BANKED_LEAVE_XDATA
   1153          }
   1154          
   1155          /******************************************************************************
   1156           * @fn          ZDSecMgrAppKeyGet
   1157           *
   1158           * @brief       get an APP key - option APP(MASTER or LINK) key
   1159           *
   1160           * @param       initNwkAddr - [in] NWK address of initiator device
   1161           * @param       initExtAddr - [in] EXT address of initiator device
   1162           * @param       partNwkAddr - [in] NWK address of partner device
   1163           * @param       partExtAddr - [in] EXT address of partner device
   1164           * @param       key         - [out] APP(MASTER or LINK) key
   1165           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1166           *
   1167           * @return      ZStatus_t
   1168           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1169          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1170                                                           // to KEY_TYPE_APP_LINK since
   1171                                                           // only specific requirement
   1172                                                           // right now comes from SE profile
   1173          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1174          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1175                                       uint8*  initExtAddr,
   1176                                       uint16  partNwkAddr,
   1177                                       uint8*  partExtAddr,
   1178                                       uint8** key,
   1179                                       uint8*  keyType )
   1180          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 8,R4
   \   00000B   8D..         MOV     ?V0 + 9,R5
   \   00000D   7412         MOV     A,#0x12
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 6,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 7,A
   \   000019   7414         MOV     A,#0x14
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F5..         MOV     ?V0 + 0,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 1,A
   \   000025   7416         MOV     A,#0x16
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 2,A
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F5..         MOV     ?V0 + 3,A
   \   000031   7418         MOV     A,#0x18
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F5..         MOV     ?V0 + 4,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V0 + 5,A
   1181            // Intentionally unreferenced parameters
   1182            (void)initNwkAddr;
   1183            (void)initExtAddr;
   1184            (void)partNwkAddr;
   1185            (void)partExtAddr;
   1186            
   1187            //---------------------------------------------------------------------------
   1188            // note:
   1189            // should use a robust mechanism to generate keys, for example
   1190            // combine EXT addresses and call a hash function
   1191            //---------------------------------------------------------------------------
   1192            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   00003D                ; Setup parameters for call to function SSP_GetTrueRand
   \   00003D   85..82       MOV     DPL,?V0 + 2
   \   000040   85..83       MOV     DPH,?V0 + 3
   \   000043   E0           MOVX    A,@DPTR
   \   000044   FA           MOV     R2,A
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   FB           MOV     R3,A
   \   000048   7910         MOV     R1,#0x10
   \   00004A   12....       LCALL   ??SSP_GetTrueRand?relay
   1193          
   1194            *keyType = ZDSecMgrAppKeyType;
   \   00004D   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000050   E0           MOVX    A,@DPTR
   \   000051   85..82       MOV     DPL,?V0 + 4
   \   000054   85..83       MOV     DPH,?V0 + 5
   \   000057   F0           MOVX    @DPTR,A
   1195          
   1196            return ZSuccess;
   \   000058   7900         MOV     R1,#0x0
   \   00005A   7F0A         MOV     R7,#0xa
   \   00005C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1197          }
   1198          
   1199          /******************************************************************************
   1200           * @fn          ZDSecMgrAppKeyReq
   1201           *
   1202           * @brief       Process request for APP key between two devices.
   1203           *
   1204           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1205           *
   1206           * @return      none
   1207           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1208          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1209          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1210            APSME_TransportKeyReq_t req;
   1211            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1212            uint16                  partNwkAddr;
   1213            uint8                   key[SEC_KEY_LEN];
   1214          
   1215          
   1216            // validate initiator and partner
   1217            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1218                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   2405         ADD     A,#0x5
   \   00001B   FA           MOV     R2,A
   \   00001C   EF           MOV     A,R7
   \   00001D   3400         ADDC    A,#0x0
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000023   E9           MOV     A,R1
   \   000024   6401         XRL     A,#0x1
   \   000026   6003         JZ      $+5
   \   000028   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   00002B                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002B   740F         MOV     A,#0xf
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   AC82         MOV     R4,DPL
   \   000032   AD83         MOV     R5,DPH
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   FA           MOV     R2,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   000042   E9           MOV     A,R1
   \   000043   6401         XRL     A,#0x1
   \   000045   6003         JZ      $+5
   \   000047   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1219            {
   1220              // point the key to some memory
   1221              req.key = key;
   \   00004A   7417         MOV     A,#0x17
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   A882         MOV     R0,DPL
   \   000051   A983         MOV     R1,DPH
   \   000053   7406         MOV     A,#0x6
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   E8           MOV     A,R0
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   E9           MOV     A,R1
   \   00005C   F0           MOVX    @DPTR,A
   1222          
   1223              // get an APP key - option APP (MASTER or LINK) key
   1224              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1225                                      initExtAddr,
   1226                                      partNwkAddr,
   1227                                      ind->partExtAddr,
   1228                                      &req.key,
   1229                                      &req.keyType ) == ZSuccess )
   \   00005D                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   00005D   7404         MOV     A,#0x4
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   8582..       MOV     ?V0 + 0,DPL
   \   000065   8583..       MOV     ?V0 + 1,DPH
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006D   7408         MOV     A,#0x8
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   8582..       MOV     ?V0 + 0,DPL
   \   000075   8583..       MOV     ?V0 + 1,DPH
   \   000078   78..         MOV     R0,#?V0 + 0
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007D   EE           MOV     A,R6
   \   00007E   2405         ADD     A,#0x5
   \   000080   F5..         MOV     ?V0 + 0,A
   \   000082   EF           MOV     A,R7
   \   000083   3400         ADDC    A,#0x0
   \   000085   F5..         MOV     ?V0 + 1,A
   \   000087   78..         MOV     R0,#?V0 + 0
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008C   7406         MOV     A,#0x6
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000094   7417         MOV     A,#0x17
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   AC82         MOV     R4,DPL
   \   00009B   AD83         MOV     R5,DPH
   \   00009D   8E82         MOV     DPL,R6
   \   00009F   8F83         MOV     DPH,R7
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   FA           MOV     R2,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   FB           MOV     R3,A
   \   0000A8   12....       LCALL   ??ZDSecMgrAppKeyGet?relay
   \   0000AB   7408         MOV     A,#0x8
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B0   E9           MOV     A,R1
   \   0000B1   6003         JZ      $+5
   \   0000B3   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1230              {
   1231                // always secure
   1232                req.nwkSecure = TRUE;
   \   0000B6   740C         MOV     A,#0xc
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   7401         MOV     A,#0x1
   \   0000BD   F0           MOVX    @DPTR,A
   1233                req.apsSecure = TRUE;
   \   0000BE   740B         MOV     A,#0xb
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   7401         MOV     A,#0x1
   \   0000C5   F0           MOVX    @DPTR,A
   1234                req.tunnel    = NULL;
   \   0000C6   740D         MOV     A,#0xd
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   7400         MOV     A,#0x0
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   7400         MOV     A,#0x0
   \   0000D1   F0           MOVX    @DPTR,A
   1235          
   1236                // send key to initiator device
   1237                req.dstAddr   = ind->srcAddr;
   \   0000D2   8E82         MOV     DPL,R6
   \   0000D4   8F83         MOV     DPH,R7
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   F8           MOV     R0,A
   \   0000DA   A3           INC     DPTR
   \   0000DB   E0           MOVX    A,@DPTR
   \   0000DC   F9           MOV     R1,A
   \   0000DD   7402         MOV     A,#0x2
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   E8           MOV     A,R0
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   A3           INC     DPTR
   \   0000E5   E9           MOV     A,R1
   \   0000E6   F0           MOVX    @DPTR,A
   1238                req.extAddr   = ind->partExtAddr;
   \   0000E7   EE           MOV     A,R6
   \   0000E8   2405         ADD     A,#0x5
   \   0000EA   F8           MOV     R0,A
   \   0000EB   EF           MOV     A,R7
   \   0000EC   3400         ADDC    A,#0x0
   \   0000EE   F9           MOV     R1,A
   \   0000EF   7408         MOV     A,#0x8
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   E8           MOV     A,R0
   \   0000F5   F0           MOVX    @DPTR,A
   \   0000F6   A3           INC     DPTR
   \   0000F7   E9           MOV     A,R1
   \   0000F8   F0           MOVX    @DPTR,A
   1239                req.initiator = TRUE;
   \   0000F9   740A         MOV     A,#0xa
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   7401         MOV     A,#0x1
   \   000100   F0           MOVX    @DPTR,A
   1240                APSME_TransportKeyReq( &req );
   \   000101                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000101   7402         MOV     A,#0x2
   \   000103   12....       LCALL   ?XSTACK_DISP0_8
   \   000106   AA82         MOV     R2,DPL
   \   000108   AB83         MOV     R3,DPH
   \   00010A   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   00010D   E9           MOV     A,R1
   1241          
   1242                // send key to partner device
   1243                req.dstAddr   = partNwkAddr;
   \   00010E   85..82       MOV     DPL,?XSP + 0
   \   000111   85..83       MOV     DPH,?XSP + 1
   \   000114   E0           MOVX    A,@DPTR
   \   000115   F8           MOV     R0,A
   \   000116   A3           INC     DPTR
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F9           MOV     R1,A
   \   000119   7402         MOV     A,#0x2
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   E8           MOV     A,R0
   \   00011F   F0           MOVX    @DPTR,A
   \   000120   A3           INC     DPTR
   \   000121   E9           MOV     A,R1
   \   000122   F0           MOVX    @DPTR,A
   1244                req.extAddr   = initExtAddr;
   \   000123   740F         MOV     A,#0xf
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   A882         MOV     R0,DPL
   \   00012A   A983         MOV     R1,DPH
   \   00012C   7408         MOV     A,#0x8
   \   00012E   12....       LCALL   ?XSTACK_DISP0_8
   \   000131   E8           MOV     A,R0
   \   000132   F0           MOVX    @DPTR,A
   \   000133   A3           INC     DPTR
   \   000134   E9           MOV     A,R1
   \   000135   F0           MOVX    @DPTR,A
   1245                req.initiator = FALSE;
   \   000136   740A         MOV     A,#0xa
   \   000138   12....       LCALL   ?XSTACK_DISP0_8
   \   00013B   7400         MOV     A,#0x0
   \   00013D   F0           MOVX    @DPTR,A
   1246          
   1247                APSME_TransportKeyReq( &req );
   \   00013E                ; Setup parameters for call to function APSME_TransportKeyReq
   \   00013E   7402         MOV     A,#0x2
   \   000140   12....       LCALL   ?XSTACK_DISP0_8
   \   000143   AA82         MOV     R2,DPL
   \   000145   AB83         MOV     R3,DPH
   \   000147   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   00014A   E9           MOV     A,R1
   1248              }
   1249            }
   1250          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   00014B   7427         MOV     A,#0x27
   \   00014D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000150   7F02         MOV     R7,#0x2
   \   000152   02....       LJMP    ?BANKED_LEAVE_XDATA
   1251          
   1252          /******************************************************************************
   1253           * @fn          ZDSecMgrEstablishKey
   1254           *
   1255           * @brief       Start SKKE with device joining network.
   1256           *
   1257           * @param       device - [in] ZDSecMgrDevice_t, device info
   1258           *
   1259           * @return      ZStatus_t
   1260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1261          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1262          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1263            ZStatus_t               status;
   1264            APSME_EstablishKeyReq_t req;
   1265          
   1266          
   1267            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E8           MOV     A,R0
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   E9           MOV     A,R1
   \   000022   F0           MOVX    @DPTR,A
   1268            req.method      = APSME_SKKE_METHOD;
   \   000023   7404         MOV     A,#0x4
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   7400         MOV     A,#0x0
   \   00002A   F0           MOVX    @DPTR,A
   1269          
   1270            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   C082         PUSH    DPL
   \   000035   C083         PUSH    DPH
   \   000037                ; Setup parameters for call to function NLME_GetShortAddr
   \   000037   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00003A   8A..         MOV     ?V0 + 2,R2
   \   00003C   8B..         MOV     ?V0 + 3,R3
   \   00003E   D083         POP     DPH
   \   000040   D082         POP     DPL
   \   000042   E0           MOVX    A,@DPTR
   \   000043   65..         XRL     A,?V0 + 2
   \   000045   7004         JNZ     ??ZDSecMgrEstablishKey_0
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrEstablishKey_0:
   \   00004B   7026         JNZ     ??ZDSecMgrEstablishKey_1
   1271            {
   1272              req.dstAddr   = device->nwkAddr;
   \   00004D   8E82         MOV     DPL,R6
   \   00004F   8F83         MOV     DPH,R7
   \   000051   E0           MOVX    A,@DPTR
   \   000052   F8           MOV     R0,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F9           MOV     R1,A
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   E8           MOV     A,R0
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E9           MOV     A,R1
   \   000060   F0           MOVX    @DPTR,A
   1273              //devtag.0604.todo - remove obsolete
   1274              req.apsSecure = FALSE;
   \   000061   7405         MOV     A,#0x5
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   7400         MOV     A,#0x0
   \   000068   F0           MOVX    @DPTR,A
   1275              req.nwkSecure = FALSE;
   \   000069   7406         MOV     A,#0x6
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   7400         MOV     A,#0x0
   \   000070   F0           MOVX    @DPTR,A
   \   000071   8028         SJMP    ??ZDSecMgrEstablishKey_2
   1276            }
   1277            else
   1278            {
   1279              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000073   8E82         MOV     DPL,R6
   \   000075   8F83         MOV     DPH,R7
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F8           MOV     R0,A
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F9           MOV     R1,A
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   E8           MOV     A,R0
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   E9           MOV     A,R1
   \   00008A   F0           MOVX    @DPTR,A
   1280              //devtag.0604.todo - remove obsolete
   1281              req.apsSecure = TRUE;
   \   00008B   7405         MOV     A,#0x5
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   7401         MOV     A,#0x1
   \   000092   F0           MOVX    @DPTR,A
   1282              req.nwkSecure = TRUE;
   \   000093   7406         MOV     A,#0x6
   \   000095   12....       LCALL   ?XSTACK_DISP0_8
   \   000098   7401         MOV     A,#0x1
   \   00009A   F0           MOVX    @DPTR,A
   1283            }
   1284          
   1285            status = APSME_EstablishKeyReq( &req );
   \                     ??ZDSecMgrEstablishKey_2:
   \   00009B                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   00009B   85..82       MOV     DPL,?XSP + 0
   \   00009E   85..83       MOV     DPH,?XSP + 1
   \   0000A1   AA82         MOV     R2,DPL
   \   0000A3   AB83         MOV     R3,DPH
   \   0000A5   12....       LCALL   ??APSME_EstablishKeyReq?relay
   \   0000A8   E9           MOV     A,R1
   \   0000A9   F5..         MOV     ?V0 + 0,A
   1286          
   1287            return status;
   \   0000AB   A9..         MOV     R1,?V0 + 0
   \   0000AD   7407         MOV     A,#0x7
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B2   7F04         MOV     R7,#0x4
   \   0000B4   02....       LJMP    ?BANKED_LEAVE_XDATA
   1288          }
   1289          
   1290          /******************************************************************************
   1291           * @fn          ZDSecMgrSendMasterKey
   1292           *
   1293           * @brief       Send MASTER key to device joining network.
   1294           *
   1295           * @param       device - [in] ZDSecMgrDevice_t, device info
   1296           *
   1297           * @return      ZStatus_t
   1298           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1299          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1300          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1301            ZStatus_t               status;
   1302            APSME_TransportKeyReq_t req;
   1303          
   1304          
   1305            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
   1306            req.extAddr = device->extAddr;
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   7406         MOV     A,#0x6
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E8           MOV     A,R0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   E9           MOV     A,R1
   \   00002A   F0           MOVX    @DPTR,A
   1307            req.tunnel  = NULL;
   \   00002B   740B         MOV     A,#0xb
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   7400         MOV     A,#0x0
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   7400         MOV     A,#0x0
   \   000036   F0           MOVX    @DPTR,A
   1308          
   1309            ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &req.key );
   \   000037                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000037   7404         MOV     A,#0x4
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   AC82         MOV     R4,DPL
   \   00003E   AD83         MOV     R5,DPH
   \   000040   8E82         MOV     DPL,R6
   \   000042   8F83         MOV     DPH,R7
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F8           MOV     R0,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F583         MOV     DPH,A
   \   000052   8882         MOV     DPL,R0
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F8           MOV     R0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F583         MOV     DPH,A
   \   00005A   8882         MOV     DPL,R0
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   FA           MOV     R2,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   FB           MOV     R3,A
   \   000061   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000064   E9           MOV     A,R1
   1310          
   1311            //check if using secure hop to to parent
   1312            if ( device->parentAddr != NLME_GetShortAddr() )
   \   000065   8E82         MOV     DPL,R6
   \   000067   8F83         MOV     DPH,R7
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   C082         PUSH    DPL
   \   00006F   C083         PUSH    DPH
   \   000071                ; Setup parameters for call to function NLME_GetShortAddr
   \   000071   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000074   8A..         MOV     ?V0 + 2,R2
   \   000076   8B..         MOV     ?V0 + 3,R3
   \   000078   D083         POP     DPH
   \   00007A   D082         POP     DPL
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   65..         XRL     A,?V0 + 2
   \   00007F   7004         JNZ     ??ZDSecMgrSendMasterKey_0
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000085   602A         JZ      ??ZDSecMgrSendMasterKey_1
   1313            {
   1314              //send to parent with security
   1315              req.dstAddr   = device->parentAddr;
   \   000087   8E82         MOV     DPL,R6
   \   000089   8F83         MOV     DPH,R7
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F8           MOV     R0,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   F9           MOV     R1,A
   \   000094   85..82       MOV     DPL,?XSP + 0
   \   000097   85..83       MOV     DPH,?XSP + 1
   \   00009A   E8           MOV     A,R0
   \   00009B   F0           MOVX    @DPTR,A
   \   00009C   A3           INC     DPTR
   \   00009D   E9           MOV     A,R1
   \   00009E   F0           MOVX    @DPTR,A
   1316              req.nwkSecure = TRUE;
   \   00009F   740A         MOV     A,#0xa
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   7401         MOV     A,#0x1
   \   0000A6   F0           MOVX    @DPTR,A
   1317              req.apsSecure = TRUE;
   \   0000A7   7409         MOV     A,#0x9
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   7401         MOV     A,#0x1
   \   0000AE   F0           MOVX    @DPTR,A
   \   0000AF   8024         SJMP    ??ZDSecMgrSendMasterKey_2
   1318            }
   1319            else
   1320            {
   1321              //direct with no security
   1322              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   0000B1   8E82         MOV     DPL,R6
   \   0000B3   8F83         MOV     DPH,R7
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   F8           MOV     R0,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F9           MOV     R1,A
   \   0000BA   85..82       MOV     DPL,?XSP + 0
   \   0000BD   85..83       MOV     DPH,?XSP + 1
   \   0000C0   E8           MOV     A,R0
   \   0000C1   F0           MOVX    @DPTR,A
   \   0000C2   A3           INC     DPTR
   \   0000C3   E9           MOV     A,R1
   \   0000C4   F0           MOVX    @DPTR,A
   1323              req.nwkSecure = FALSE;
   \   0000C5   740A         MOV     A,#0xa
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   7400         MOV     A,#0x0
   \   0000CC   F0           MOVX    @DPTR,A
   1324              req.apsSecure = FALSE;
   \   0000CD   7409         MOV     A,#0x9
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   7400         MOV     A,#0x0
   \   0000D4   F0           MOVX    @DPTR,A
   1325            }
   1326          
   1327            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendMasterKey_2:
   \   0000D5                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000D5   85..82       MOV     DPL,?XSP + 0
   \   0000D8   85..83       MOV     DPH,?XSP + 1
   \   0000DB   AA82         MOV     R2,DPL
   \   0000DD   AB83         MOV     R3,DPH
   \   0000DF   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000E2   E9           MOV     A,R1
   \   0000E3   F5..         MOV     ?V0 + 0,A
   1328          
   1329            return status;
   \   0000E5   A9..         MOV     R1,?V0 + 0
   \   0000E7   740D         MOV     A,#0xd
   \   0000E9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EC   7F04         MOV     R7,#0x4
   \   0000EE   02....       LJMP    ?BANKED_LEAVE_XDATA
   1330          }
   1331          
   1332          /******************************************************************************
   1333           * @fn          ZDSecMgrSendNwkKey
   1334           *
   1335           * @brief       Send NWK key to device joining network.
   1336           *
   1337           * @param       device - [in] ZDSecMgrDevice_t, device info
   1338           *
   1339           * @return      ZStatus_t
   1340           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1341          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1342          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1343            ZStatus_t               status;
   1344            APSME_TransportKeyReq_t req;
   1345            APSDE_FrameTunnel_t     tunnel;
   1346          
   1347            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   E8           MOV     A,R0
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   E9           MOV     A,R1
   \   000021   F0           MOVX    @DPTR,A
   1348            req.extAddr   = device->extAddr;
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F8           MOV     R0,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   7406         MOV     A,#0x6
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E8           MOV     A,R0
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   E9           MOV     A,R1
   \   000036   F0           MOVX    @DPTR,A
   1349          
   1350            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1351              req.keyType   = KEY_TYPE_NWK_HIGH;
   1352            else
   1353              req.keyType   = KEY_TYPE_NWK;
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   7401         MOV     A,#0x1
   \   00003E   F0           MOVX    @DPTR,A
   1354          
   1355            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1356                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1357            {
   1358              // set values
   1359              req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   1360              req.key       = _NIB.nwkActiveKey.key;
   1361              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1362              //key isn't used to secure the frame at the APS layer -- since the receiving
   1363              //device may not have a NWK key yet
   1364              req.apsSecure = TRUE;
   1365          
   1366              // check if using secure hop to to parent
   1367              if ( device->parentAddr == NLME_GetShortAddr() )
   1368              {
   1369                req.nwkSecure = FALSE;
   1370                req.tunnel    = NULL;
   1371              }
   1372              else
   1373              {
   1374                req.nwkSecure   = TRUE;
   1375                req.tunnel      = &tunnel;
   1376                req.tunnel->tna = device->parentAddr;
   1377                req.tunnel->dea = device->extAddr;
   1378              }
   1379            }
   1380            else
   1381            {
   1382              // default values
   1383              //devtag.0604.verify
   1384              req.nwkSecure = TRUE;
   \   00003F   740A         MOV     A,#0xa
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   7401         MOV     A,#0x1
   \   000046   F0           MOVX    @DPTR,A
   1385              req.apsSecure = FALSE;
   \   000047   7409         MOV     A,#0x9
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   7400         MOV     A,#0x0
   \   00004E   F0           MOVX    @DPTR,A
   1386              req.tunnel    = NULL;
   \   00004F   740B         MOV     A,#0xb
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   7400         MOV     A,#0x0
   \   000056   F0           MOVX    @DPTR,A
   \   000057   A3           INC     DPTR
   \   000058   7400         MOV     A,#0x0
   \   00005A   F0           MOVX    @DPTR,A
   1387          
   1388              if ( device->parentAddr != NLME_GetShortAddr() )
   \   00005B   8E82         MOV     DPL,R6
   \   00005D   8F83         MOV     DPH,R7
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   C082         PUSH    DPL
   \   000065   C083         PUSH    DPH
   \   000067                ; Setup parameters for call to function NLME_GetShortAddr
   \   000067   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00006A   8A..         MOV     ?V0 + 2,R2
   \   00006C   8B..         MOV     ?V0 + 3,R3
   \   00006E   D083         POP     DPH
   \   000070   D082         POP     DPL
   \   000072   E0           MOVX    A,@DPTR
   \   000073   65..         XRL     A,?V0 + 2
   \   000075   7004         JNZ     ??ZDSecMgrSendNwkKey_0
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrSendNwkKey_0:
   \   00007B   6018         JZ      ??ZDSecMgrSendNwkKey_1
   1389              {
   1390                req.dstAddr = device->parentAddr;
   \   00007D   8E82         MOV     DPL,R6
   \   00007F   8F83         MOV     DPH,R7
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   F8           MOV     R0,A
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F9           MOV     R1,A
   \   00008A   85..82       MOV     DPL,?XSP + 0
   \   00008D   85..83       MOV     DPH,?XSP + 1
   \   000090   E8           MOV     A,R0
   \   000091   F0           MOVX    @DPTR,A
   \   000092   A3           INC     DPTR
   \   000093   E9           MOV     A,R1
   \   000094   F0           MOVX    @DPTR,A
   1391              }
   1392          
   1393              // special cases
   1394              //devtag.0604.todo - modify to preconfig flag
   1395              if ( device->secure == FALSE )
   \                     ??ZDSecMgrSendNwkKey_1:
   \   000095   8E82         MOV     DPL,R6
   \   000097   8F83         MOV     DPH,R7
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   7046         JNZ     ??ZDSecMgrSendNwkKey_2
   1396              {
   1397                req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   \   0000A2   90....       MOV     DPTR,#_NIB + 62
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   C0E0         PUSH    A
   \   0000A8   7403         MOV     A,#0x3
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   D0E0         POP     A
   \   0000AF   F0           MOVX    @DPTR,A
   1398                req.key       = _NIB.nwkActiveKey.key;
   \   0000B0   7404         MOV     A,#0x4
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   74..         MOV     A,#(_NIB + 63) & 0xff
   \   0000B7   F0           MOVX    @DPTR,A
   \   0000B8   A3           INC     DPTR
   \   0000B9   74..         MOV     A,#((_NIB + 63) >> 8) & 0xff
   \   0000BB   F0           MOVX    @DPTR,A
   1399          
   1400                // check if using secure hop to to parent
   1401                if ( device->parentAddr == NLME_GetShortAddr() )
   \   0000BC   8E82         MOV     DPL,R6
   \   0000BE   8F83         MOV     DPH,R7
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   C082         PUSH    DPL
   \   0000C6   C083         PUSH    DPH
   \   0000C8                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000C8   12....       LCALL   ??NLME_GetShortAddr?relay
   \   0000CB   8A..         MOV     ?V0 + 2,R2
   \   0000CD   8B..         MOV     ?V0 + 3,R3
   \   0000CF   D083         POP     DPH
   \   0000D1   D082         POP     DPL
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   65..         XRL     A,?V0 + 2
   \   0000D6   7004         JNZ     ??ZDSecMgrSendNwkKey_3
   \   0000D8   A3           INC     DPTR
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000DC   701E         JNZ     ??ZDSecMgrSendNwkKey_4
   1402                {
   1403                  req.nwkSecure = FALSE;
   \   0000DE   740A         MOV     A,#0xa
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   7400         MOV     A,#0x0
   \   0000E5   F0           MOVX    @DPTR,A
   \   0000E6   8014         SJMP    ??ZDSecMgrSendNwkKey_4
   1404                }
   1405              }
   1406              else
   1407              {
   1408                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000E8   7404         MOV     A,#0x4
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   7400         MOV     A,#0x0
   \   0000EF   F0           MOVX    @DPTR,A
   \   0000F0   A3           INC     DPTR
   \   0000F1   7400         MOV     A,#0x0
   \   0000F3   F0           MOVX    @DPTR,A
   1409                req.keySeqNum = 0;
   \   0000F4   7403         MOV     A,#0x3
   \   0000F6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F9   7400         MOV     A,#0x0
   \   0000FB   F0           MOVX    @DPTR,A
   1410              }
   1411            }
   1412          
   1413            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000FC                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000FC   85..82       MOV     DPL,?XSP + 0
   \   0000FF   85..83       MOV     DPH,?XSP + 1
   \   000102   AA82         MOV     R2,DPL
   \   000104   AB83         MOV     R3,DPH
   \   000106   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   000109   E9           MOV     A,R1
   \   00010A   F5..         MOV     ?V0 + 0,A
   1414          
   1415            return status;
   \   00010C   A9..         MOV     R1,?V0 + 0
   \   00010E   740D         MOV     A,#0xd
   \   000110   12....       LCALL   ?DEALLOC_XSTACK8
   \   000113   7F04         MOV     R7,#0x4
   \   000115   02....       LJMP    ?BANKED_LEAVE_XDATA
   1416          }
   1417          
   1418          /******************************************************************************
   1419           * @fn          ZDSecMgrDeviceEntryRemove
   1420           *
   1421           * @brief       Remove device entry.
   1422           *
   1423           * @param       entry - [in] valid entry
   1424           *
   1425           * @return      none
   1426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1427          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1428          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1429            // terminate device control
   1430            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1431            {
   1432              ZDSecMgrCtrlTerm( entry );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlTerm
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   ??ZDSecMgrCtrlTerm?relay
   1433            }
   1434          
   1435            // remove device from entry data
   1436            ZDSecMgrEntryFree( entry );
   \   000010                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??ZDSecMgrEntryFree?relay
   1437          
   1438            // remove EXT address
   1439            //ZDSecMgrExtAddrRelease( aiOld );
   1440          }
   \   000017   7F01         MOV     R7,#0x1
   \   000019   02....       LJMP    ?BANKED_LEAVE_XDATA
   1441          
   1442          /******************************************************************************
   1443           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1444           *
   1445           * @brief       Remove device entry by its ext address.
   1446           *
   1447           * @param       pAddr - pointer to the extended address
   1448           *
   1449           * @return      ZStatus_t
   1450           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1451          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1452          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1453            ZDSecMgrEntry_t *pEntry;
   1454            uint8           retValue;
   1455            
   1456            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001F   E9           MOV     A,R1
   \   000020   F5..         MOV     ?V0 + 0,A
   1457            
   1458            if( retValue == ZSuccess )
   \   000022   E5..         MOV     A,?V0 + 0
   \   000024   700E         JNZ     ??ZDSecMgrDeviceRemoveByExtAddr_0
   1459            {
   1460              ZDSecMgrDeviceEntryRemove( pEntry );
   \   000026                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   FA           MOV     R2,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FB           MOV     R3,A
   \   000031   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay
   1461            }
   1462            
   1463            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   000034   A9..         MOV     R1,?V0 + 0
   \   000036   7402         MOV     A,#0x2
   \   000038   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003B   7F01         MOV     R7,#0x1
   \   00003D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1464          }
   1465          
   1466          /******************************************************************************
   1467           * @fn          ZDSecMgrDeviceEntryAdd
   1468           *
   1469           * @brief       Add entry.
   1470           *
   1471           * @param       device - [in] ZDSecMgrDevice_t, device info
   1472           * @param       ami    - [in] Address Manager index
   1473           *
   1474           * @return      ZStatus_t
   1475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1476          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1477          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1478            AddrMgrEntry_t entry;
   1479          
   1480            // get the ami data
   1481            entry.user  = ADDRMGR_USER_SECURITY;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7402         MOV     A,#0x2
   \   00001A   F0           MOVX    @DPTR,A
   1482            entry.index = ami;
   \   00001B   740B         MOV     A,#0xb
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E5..         MOV     A,?V0 + 0
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E5..         MOV     A,?V0 + 1
   \   000026   F0           MOVX    @DPTR,A
   1483          
   1484            AddrMgrEntryGet( &entry );
   \   000027                ; Setup parameters for call to function AddrMgrEntryGet
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   AA82         MOV     R2,DPL
   \   00002F   AB83         MOV     R3,DPH
   \   000031   12....       LCALL   ??AddrMgrEntryGet?relay
   \   000034   E9           MOV     A,R1
   1485          
   1486            // check if NWK address is same
   1487            if ( entry.nwkAddr != nwkAddr )
   \   000035   7401         MOV     A,#0x1
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   6E           XRL     A,R6
   \   00003C   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   000041   6018         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1488            {
   1489              // update NWK address
   1490              entry.nwkAddr = nwkAddr;
   \   000043   7401         MOV     A,#0x1
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   EE           MOV     A,R6
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   EF           MOV     A,R7
   \   00004C   F0           MOVX    @DPTR,A
   1491          
   1492              AddrMgrEntryUpdate( &entry );
   \   00004D                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00004D   85..82       MOV     DPL,?XSP + 0
   \   000050   85..83       MOV     DPH,?XSP + 1
   \   000053   AA82         MOV     R2,DPL
   \   000055   AB83         MOV     R3,DPH
   \   000057   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00005A   E9           MOV     A,R1
   1493            }
   1494          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00005B   740D         MOV     A,#0xd
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000060   7F02         MOV     R7,#0x2
   \   000062   02....       LJMP    ?BANKED_LEAVE_XDATA
   1495          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1496          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1497          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1498            ZStatus_t        status;
   1499            ZDSecMgrEntry_t* entry;
   1500          
   1501          
   1502            // initialize as unknown until completion
   1503            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 2,#-0x38
   1504          
   1505            device->ctrl = NULL;
   \   000015   85..82       MOV     DPL,?V0 + 0
   \   000018   85..83       MOV     DPH,?V0 + 1
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   7400         MOV     A,#0x0
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   7400         MOV     A,#0x0
   \   000029   F0           MOVX    @DPTR,A
   1506          
   1507            // make sure not already registered
   1508            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \   00002A                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   AC82         MOV     R4,DPL
   \   000032   AD83         MOV     R5,DPH
   \   000034   85..82       MOV     DPL,?V0 + 0
   \   000037   85..83       MOV     DPH,?V0 + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   FA           MOV     R2,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   ??ZDSecMgrEntryLookup?relay
   \   000042   E9           MOV     A,R1
   \   000043   704D         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1509            {
   1510              // verify that address index is same
   1511              if ( entry->ami != ami )
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F8           MOV     R0,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F583         MOV     DPH,A
   \   000051   8882         MOV     DPL,R0
   \   000053   E0           MOVX    A,@DPTR
   \   000054   6E           XRL     A,R6
   \   000055   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   00005A   605C         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1512              {
   1513                // remove conflicting entry
   1514                ZDSecMgrDeviceEntryRemove( entry );
   \   00005C                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   00005C   85..82       MOV     DPL,?XSP + 0
   \   00005F   85..83       MOV     DPH,?XSP + 1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   FA           MOV     R2,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   FB           MOV     R3,A
   \   000067   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay
   1515          
   1516                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \   00006A                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   AC82         MOV     R4,DPL
   \   000072   AD83         MOV     R5,DPH
   \   000074   EE           MOV     A,R6
   \   000075   FA           MOV     R2,A
   \   000076   EF           MOV     A,R7
   \   000077   FB           MOV     R3,A
   \   000078   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   00007B   E9           MOV     A,R1
   \   00007C   703A         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1517                {
   1518                  // update NWK address
   1519                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   00007E                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   00007E   85..82       MOV     DPL,?V0 + 0
   \   000081   85..83       MOV     DPH,?V0 + 1
   \   000084   E0           MOVX    A,@DPTR
   \   000085   FC           MOV     R4,A
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   FD           MOV     R5,A
   \   000089   EE           MOV     A,R6
   \   00008A   FA           MOV     R2,A
   \   00008B   EF           MOV     A,R7
   \   00008C   FB           MOV     R3,A
   \   00008D   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   \   000090   8026         SJMP    ??ZDSecMgrDeviceEntryAdd_2
   1520                }
   1521              }
   1522            }
   1523            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   000092                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000092   85..82       MOV     DPL,?XSP + 0
   \   000095   85..83       MOV     DPH,?XSP + 1
   \   000098   AC82         MOV     R4,DPL
   \   00009A   AD83         MOV     R5,DPH
   \   00009C   EE           MOV     A,R6
   \   00009D   FA           MOV     R2,A
   \   00009E   EF           MOV     A,R7
   \   00009F   FB           MOV     R3,A
   \   0000A0   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   0000A3   E9           MOV     A,R1
   \   0000A4   7012         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1524            {
   1525              // update NWK address
   1526              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   0000A6                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   0000A6   85..82       MOV     DPL,?V0 + 0
   \   0000A9   85..83       MOV     DPH,?V0 + 1
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   FC           MOV     R4,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   FD           MOV     R5,A
   \   0000B1   EE           MOV     A,R6
   \   0000B2   FA           MOV     R2,A
   \   0000B3   EF           MOV     A,R7
   \   0000B4   FB           MOV     R3,A
   \   0000B5   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   1527            }
   1528          
   1529            // check if a new entry needs to be created
   1530            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   0000B8   85..82       MOV     DPL,?XSP + 0
   \   0000BB   85..83       MOV     DPH,?XSP + 1
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   F8           MOV     R0,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F9           MOV     R1,A
   \   0000C3   E8           MOV     A,R0
   \   0000C4   49           ORL     A,R1
   \   0000C5   704C         JNZ     ??ZDSecMgrDeviceEntryAdd_3
   1531            {
   1532              // get new entry
   1533              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   0000C7                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   0000C7   85..82       MOV     DPL,?XSP + 0
   \   0000CA   85..83       MOV     DPH,?XSP + 1
   \   0000CD   AA82         MOV     R2,DPL
   \   0000CF   AB83         MOV     R3,DPH
   \   0000D1   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   0000D4   E9           MOV     A,R1
   \   0000D5   7051         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   1534              {
   1535                // reset entry lkd
   1536          
   1537                // finish setting up entry
   1538                entry->ami = ami;
   \   0000D7   85..82       MOV     DPL,?XSP + 0
   \   0000DA   85..83       MOV     DPH,?XSP + 1
   \   0000DD   E0           MOVX    A,@DPTR
   \   0000DE   F8           MOV     R0,A
   \   0000DF   A3           INC     DPTR
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   F583         MOV     DPH,A
   \   0000E3   8882         MOV     DPL,R0
   \   0000E5   EE           MOV     A,R6
   \   0000E6   F0           MOVX    @DPTR,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   EF           MOV     A,R7
   \   0000E9   F0           MOVX    @DPTR,A
   1539          
   1540                // update NWK address
   1541                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   0000EA                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   0000EA   85..82       MOV     DPL,?V0 + 0
   \   0000ED   85..83       MOV     DPH,?V0 + 1
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   FC           MOV     R4,A
   \   0000F2   A3           INC     DPTR
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   FD           MOV     R5,A
   \   0000F5   EE           MOV     A,R6
   \   0000F6   FA           MOV     R2,A
   \   0000F7   EF           MOV     A,R7
   \   0000F8   FB           MOV     R3,A
   \   0000F9   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   1542          
   1543                // enter new device into device control
   1544                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1545                {
   1546                  status = ZDSecMgrCtrlAdd( device, entry );
   \   0000FC                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   0000FC   85..82       MOV     DPL,?XSP + 0
   \   0000FF   85..83       MOV     DPH,?XSP + 1
   \   000102   E0           MOVX    A,@DPTR
   \   000103   FC           MOV     R4,A
   \   000104   A3           INC     DPTR
   \   000105   E0           MOVX    A,@DPTR
   \   000106   FD           MOV     R5,A
   \   000107   AA..         MOV     R2,?V0 + 0
   \   000109   AB..         MOV     R3,?V0 + 1
   \   00010B   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   \   00010E   E9           MOV     A,R1
   \   00010F   F5..         MOV     ?V0 + 2,A
   \   000111   8015         SJMP    ??ZDSecMgrDeviceEntryAdd_4
   1547                }
   1548                else
   1549                {
   1550                  status = ZSuccess;
   1551                }
   1552              }
   1553            }
   1554            else
   1555            {
   1556              // reset entry lkd
   1557          
   1558              // reset entry in entry control
   1559              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1560              {
   1561                status = ZDSecMgrCtrlReset( device, entry );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000113                ; Setup parameters for call to function ZDSecMgrCtrlReset
   \   000113   85..82       MOV     DPL,?XSP + 0
   \   000116   85..83       MOV     DPH,?XSP + 1
   \   000119   E0           MOVX    A,@DPTR
   \   00011A   FC           MOV     R4,A
   \   00011B   A3           INC     DPTR
   \   00011C   E0           MOVX    A,@DPTR
   \   00011D   FD           MOV     R5,A
   \   00011E   AA..         MOV     R2,?V0 + 0
   \   000120   AB..         MOV     R3,?V0 + 1
   \   000122   12....       LCALL   ??ZDSecMgrCtrlReset?relay
   \   000125   E9           MOV     A,R1
   \   000126   F5..         MOV     ?V0 + 2,A
   1562              }
   1563              else
   1564              {
   1565                status = ZSuccess;
   1566              }
   1567            }
   1568          
   1569            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   000128   A9..         MOV     R1,?V0 + 2
   \   00012A   7402         MOV     A,#0x2
   \   00012C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012F   7F03         MOV     R7,#0x3
   \   000131   02....       LJMP    ?BANKED_LEAVE_XDATA
   1570          }
   1571          
   1572          /******************************************************************************
   1573           * @fn          ZDSecMgrDeviceCtrlHandler
   1574           *
   1575           * @brief       Device control handler.
   1576           *
   1577           * @param       device - [in] ZDSecMgrDevice_t, device info
   1578           *
   1579           * @return      none
   1580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1581          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1582          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1583            uint8 state;
   1584            uint8 cntr;
   1585          
   1586          
   1587            state = device->ctrl->state;
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F8           MOV     R0,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F583         MOV     DPH,A
   \   00001B   8882         MOV     DPL,R0
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 0,A
   1588            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   000025   75..01       MOV     ?V0 + 1,#0x1
   1589          
   1590            switch ( state )
   \   000028   E5..         MOV     A,?V0 + 0
   \   00002A   24FE         ADD     A,#-0x2
   \   00002C   600C         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   \   00002E   14           DEC     A
   \   00002F   601B         JZ      ??ZDSecMgrDeviceCtrlHandler_1
   \   000031   14           DEC     A
   \   000032   6039         JZ      ??ZDSecMgrDeviceCtrlHandler_2
   \   000034   24FD         ADD     A,#-0x3
   \   000036   6023         JZ      ??ZDSecMgrDeviceCtrlHandler_3
   \   000038   8030         SJMP    ??ZDSecMgrDeviceCtrlHandler_4
   1591            {
   1592              case ZDSECMGR_CTRL_TK_MASTER:
   1593                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   00003A                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   00003A   EE           MOV     A,R6
   \   00003B   FA           MOV     R2,A
   \   00003C   EF           MOV     A,R7
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ??ZDSecMgrSendMasterKey?relay
   \   000041   E9           MOV     A,R1
   \   000042   7029         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1594                {
   1595                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000044   75..03       MOV     ?V0 + 0,#0x3
   1596                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   000047   75..01       MOV     ?V0 + 1,#0x1
   1597                }
   1598                break;
   \   00004A   8021         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1599          
   1600              case ZDSECMGR_CTRL_SKKE_INIT:
   1601                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   00004C                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   00004C   EE           MOV     A,R6
   \   00004D   FA           MOV     R2,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FB           MOV     R3,A
   \   000050   12....       LCALL   ??ZDSecMgrEstablishKey?relay
   \   000053   E9           MOV     A,R1
   \   000054   7017         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1602                {
   1603                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000056   75..04       MOV     ?V0 + 0,#0x4
   1604                }
   1605                break;
   \   000059   8012         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1606          
   1607              case ZDSECMGR_CTRL_SKKE_WAIT:
   1608                // continue to wait for SKA control timeout
   1609                break;
   1610          
   1611              case ZDSECMGR_CTRL_TK_NWK:
   1612                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   00005B                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00005B   EE           MOV     A,R6
   \   00005C   FA           MOV     R2,A
   \   00005D   EF           MOV     A,R7
   \   00005E   FB           MOV     R3,A
   \   00005F   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000062   E9           MOV     A,R1
   \   000063   7008         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1613                {
   1614                  state = ZDSECMGR_CTRL_NONE;
   \   000065   75..00       MOV     ?V0 + 0,#0x0
   1615                }
   1616                break;
   \   000068   8003         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1617          
   1618              default:
   1619                state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   00006A   75..00       MOV     ?V0 + 0,#0x0
   1620                break;
   1621            }
   1622          
   1623            if ( state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   00006D   E5..         MOV     A,?V0 + 0
   \   00006F   6050         JZ      ??ZDSecMgrDeviceCtrlHandler_5
   1624            {
   1625              device->ctrl->state = state;
   \   000071   E5..         MOV     A,?V0 + 0
   \   000073   8E82         MOV     DPL,R6
   \   000075   8F83         MOV     DPH,R7
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F8           MOV     R0,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F583         MOV     DPH,A
   \   000085   8882         MOV     DPL,R0
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   E5..         MOV     A,?V0 + 0
   \   00008E   F0           MOVX    @DPTR,A
   1626              device->ctrl->cntr  = cntr;
   \   00008F   E5..         MOV     A,?V0 + 1
   \   000091   8E82         MOV     DPL,R6
   \   000093   8F83         MOV     DPH,R7
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   F8           MOV     R0,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   C8           XCH     A,R0
   \   0000A2   2406         ADD     A,#0x6
   \   0000A4   F582         MOV     DPL,A
   \   0000A6   E8           MOV     A,R0
   \   0000A7   3400         ADDC    A,#0x0
   \   0000A9   F583         MOV     DPH,A
   \   0000AB   E5..         MOV     A,?V0 + 1
   \   0000AD   F0           MOVX    @DPTR,A
   1627          
   1628              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000AE                ; Setup parameters for call to function osal_start_timerEx
   \   0000AE   7C64         MOV     R4,#0x64
   \   0000B0   7D00         MOV     R5,#0x0
   \   0000B2   7A00         MOV     R2,#0x0
   \   0000B4   7B01         MOV     R3,#0x1
   \   0000B6   90....       MOV     DPTR,#ZDAppTaskID
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   F9           MOV     R1,A
   \   0000BB   12....       LCALL   ??osal_start_timerEx?relay
   \   0000BE   E9           MOV     A,R1
   \   0000BF   8014         SJMP    ??ZDSecMgrDeviceCtrlHandler_6
   1629            }
   1630            else
   1631            {
   1632              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   0000C1                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   0000C1   8E82         MOV     DPL,R6
   \   0000C3   8F83         MOV     DPH,R7
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   FA           MOV     R2,A
   \   0000CF   A3           INC     DPTR
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   FB           MOV     R3,A
   \   0000D2   12....       LCALL   ??ZDSecMgrCtrlRelease?relay
   1633            }
   1634          }
   \                     ??ZDSecMgrDeviceCtrlHandler_6:
   \   0000D5   7F02         MOV     R7,#0x2
   \   0000D7   02....       LJMP    ?BANKED_LEAVE_XDATA
   1635          
   1636          /******************************************************************************
   1637           * @fn          ZDSecMgrDeviceCtrlSetup
   1638           *
   1639           * @brief       Setup device control.
   1640           *
   1641           * @param       device - [in] ZDSecMgrDevice_t, device info
   1642           *
   1643           * @return      ZStatus_t
   1644           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1645          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1646          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1647            if ( device->ctrl != NULL )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F8           MOV     R0,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F9           MOV     R1,A
   \   00001A   E8           MOV     A,R0
   \   00001B   49           ORL     A,R1
   \   00001C   604E         JZ      ??ZDSecMgrDeviceCtrlSetup_0
   1648            {
   1649              if ( device->secure == FALSE )
   \   00001E   8E82         MOV     DPL,R6
   \   000020   8F83         MOV     DPH,R7
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   701E         JNZ     ??ZDSecMgrDeviceCtrlSetup_1
   1650              {
   1651                // send the master key data to the joining device
   1652                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F583         MOV     DPH,A
   \   00003D   8882         MOV     DPL,R0
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   7402         MOV     A,#0x2
   \   000046   F0           MOVX    @DPTR,A
   \   000047   801C         SJMP    ??ZDSecMgrDeviceCtrlSetup_2
   1653              }
   1654              else
   1655              {
   1656                // start SKKE
   1657                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   000049   8E82         MOV     DPL,R6
   \   00004B   8F83         MOV     DPH,R7
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F583         MOV     DPH,A
   \   00005B   8882         MOV     DPL,R0
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   7403         MOV     A,#0x3
   \   000064   F0           MOVX    @DPTR,A
   1658              }
   1659          
   1660              ZDSecMgrDeviceCtrlHandler( device );
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000065                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000065   EE           MOV     A,R6
   \   000066   FA           MOV     R2,A
   \   000067   EF           MOV     A,R7
   \   000068   FB           MOV     R3,A
   \   000069   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   1661            }
   1662          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   00006C   7F01         MOV     R7,#0x1
   \   00006E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1663          
   1664          /******************************************************************************
   1665           * @fn          ZDSecMgrDeviceCtrlUpdate
   1666           *
   1667           * @brief       Update control data.
   1668           *
   1669           * @param       extAddr - [in] EXT address
   1670           * @param       state   - [in] new control state
   1671           *
   1672           * @return      none
   1673           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1674          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1675          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 0,R1
   1676            ZDSecMgrEntry_t* entry;
   1677            ZDSecMgrCtrl_t*  ctrl;
   1678          
   1679          
   1680            // lookup device entry data
   1681            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000010                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000010   7402         MOV     A,#0x2
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   AC82         MOV     R4,DPL
   \   000017   AD83         MOV     R5,DPH
   \   000019   EE           MOV     A,R6
   \   00001A   FA           MOV     R2,A
   \   00001B   EF           MOV     A,R7
   \   00001C   FB           MOV     R3,A
   \   00001D   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000020   E9           MOV     A,R1
   1682          
   1683            if ( entry != NULL )
   \   000021   7402         MOV     A,#0x2
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F8           MOV     R0,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   E8           MOV     A,R0
   \   00002C   49           ORL     A,R1
   \   00002D   7003         JNZ     $+5
   \   00002F   02....       LJMP    ??ZDSecMgrDeviceCtrlUpdate_0 & 0xFFFF
   1684            {
   1685              // lookup device control data
   1686              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000032                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   AC82         MOV     R4,DPL
   \   00003A   AD83         MOV     R5,DPH
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E0           MOVX    A,@DPTR
   \   000042   FA           MOV     R2,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   FB           MOV     R3,A
   \   000046   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1687          
   1688              // make sure control data is valid
   1689              if ( ctrl != NULL )
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F8           MOV     R0,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F9           MOV     R1,A
   \   000054   E8           MOV     A,R0
   \   000055   49           ORL     A,R1
   \   000056   7003         JNZ     $+5
   \   000058   02....       LJMP    ??ZDSecMgrDeviceCtrlUpdate_0 & 0xFFFF
   1690              {
   1691                // possible state transitions
   1692                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   E0           MOVX    A,@DPTR
   \   000062   F8           MOV     R0,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F583         MOV     DPH,A
   \   000067   8882         MOV     DPL,R0
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   6404         XRL     A,#0x4
   \   000071   7068         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1693                {
   1694                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000073   7405         MOV     A,#0x5
   \   000075   65..         XRL     A,?V0 + 0
   \   000077   702F         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1695                  {
   1696                    // send the network key
   1697                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   000079   85..82       MOV     DPL,?XSP + 0
   \   00007C   85..83       MOV     DPH,?XSP + 1
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F8           MOV     R0,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F583         MOV     DPH,A
   \   000085   8882         MOV     DPL,R0
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   7407         MOV     A,#0x7
   \   00008E   F0           MOVX    @DPTR,A
   1698                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   \   00008F   85..82       MOV     DPL,?XSP + 0
   \   000092   85..83       MOV     DPH,?XSP + 1
   \   000095   E0           MOVX    A,@DPTR
   \   000096   F8           MOV     R0,A
   \   000097   A3           INC     DPTR
   \   000098   E0           MOVX    A,@DPTR
   \   000099   C8           XCH     A,R0
   \   00009A   2406         ADD     A,#0x6
   \   00009C   F582         MOV     DPL,A
   \   00009E   E8           MOV     A,R0
   \   00009F   3400         ADDC    A,#0x0
   \   0000A1   F583         MOV     DPH,A
   \   0000A3   7401         MOV     A,#0x1
   \   0000A5   F0           MOVX    @DPTR,A
   \   0000A6   8033         SJMP    ??ZDSecMgrDeviceCtrlUpdate_0
   1699                  }
   1700                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   0000A8   7406         MOV     A,#0x6
   \   0000AA   65..         XRL     A,?V0 + 0
   \   0000AC   702D         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1701                  {
   1702                    // force default timeout in order to cleanup control logic
   1703                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   0000AE   85..82       MOV     DPL,?XSP + 0
   \   0000B1   85..83       MOV     DPH,?XSP + 1
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   F8           MOV     R0,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   F583         MOV     DPH,A
   \   0000BA   8882         MOV     DPL,R0
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   7406         MOV     A,#0x6
   \   0000C3   F0           MOVX    @DPTR,A
   1704                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   0000C4   85..82       MOV     DPL,?XSP + 0
   \   0000C7   85..83       MOV     DPH,?XSP + 1
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   F8           MOV     R0,A
   \   0000CC   A3           INC     DPTR
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   C8           XCH     A,R0
   \   0000CF   2406         ADD     A,#0x6
   \   0000D1   F582         MOV     DPL,A
   \   0000D3   E8           MOV     A,R0
   \   0000D4   3400         ADDC    A,#0x0
   \   0000D6   F583         MOV     DPH,A
   \   0000D8   7401         MOV     A,#0x1
   \   0000DA   F0           MOVX    @DPTR,A
   1705                  }
   1706                }
   1707                // timer should be active
   1708              }
   1709            }
   1710          }
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   0000DB   7404         MOV     A,#0x4
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E0   7F01         MOV     R7,#0x1
   \   0000E2   02....       LJMP    ?BANKED_LEAVE_XDATA
   1711          
   1712          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1713          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1714          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   1715            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1716            {
   1717              if ( initiator == TRUE )
   \   00000B   7401         MOV     A,#0x1
   \   00000D   65..         XRL     A,?V0 + 0
   \   00000F   7009         JNZ     ??APSME_SKA_TimerExpired_0
   1718              {
   1719                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   \   000011                ; Setup parameters for call to function ZDSecMgrDeviceCtrlUpdate
   \   000011   7906         MOV     R1,#0x6
   \   000013   EE           MOV     A,R6
   \   000014   FA           MOV     R2,A
   \   000015   EF           MOV     A,R7
   \   000016   FB           MOV     R3,A
   \   000017   12....       LCALL   ??ZDSecMgrDeviceCtrlUpdate?relay
   1720              }
   1721            }
   1722          }
   \                     ??APSME_SKA_TimerExpired_0:
   \   00001A   7F01         MOV     R7,#0x1
   \   00001C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1723          
   1724          /******************************************************************************
   1725           * @fn          ZDSecMgrDeviceRemove
   1726           *
   1727           * @brief       Remove device from network.
   1728           *
   1729           * @param       device - [in] ZDSecMgrDevice_t, device info
   1730           *
   1731           * @return      none
   1732           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1733          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1734          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1735            APSME_RemoveDeviceReq_t remDevReq;
   1736            NLME_LeaveReq_t         leaveReq;
   1737            associated_devices_t*   assoc;
   1738          
   1739          
   1740            // check if parent, remove the device
   1741            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   C082         PUSH    DPL
   \   000018   C083         PUSH    DPH
   \   00001A                ; Setup parameters for call to function NLME_GetShortAddr
   \   00001A   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00001D   8A..         MOV     ?V0 + 2,R2
   \   00001F   8B..         MOV     ?V0 + 3,R3
   \   000021   D083         POP     DPH
   \   000023   D082         POP     DPL
   \   000025   E0           MOVX    A,@DPTR
   \   000026   65..         XRL     A,?V0 + 2
   \   000028   7004         JNZ     ??ZDSecMgrDeviceRemove_0
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00002E   6003         JZ      $+5
   \   000030   02....       LJMP    ??ZDSecMgrDeviceRemove_1 & 0xFFFF
   1742            {
   1743              // this is the parent of the device
   1744              leaveReq.extAddr        = device->extAddr;
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F8           MOV     R0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F9           MOV     R1,A
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   E8           MOV     A,R0
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   E9           MOV     A,R1
   \   000048   F0           MOVX    @DPTR,A
   1745              leaveReq.removeChildren = FALSE;
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   7400         MOV     A,#0x0
   \   000050   F0           MOVX    @DPTR,A
   1746              leaveReq.rejoin         = FALSE;
   \   000051   7403         MOV     A,#0x3
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   7400         MOV     A,#0x0
   \   000058   F0           MOVX    @DPTR,A
   1747          
   1748              // find child association
   1749              assoc = AssocGetWithExt( device->extAddr );
   \   000059                ; Setup parameters for call to function AssocGetWithExt
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   FA           MOV     R2,A
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   FB           MOV     R3,A
   \   000064   12....       LCALL   ??AssocGetWithExt?relay
   \   000067   8A..         MOV     ?V0 + 2,R2
   \   000069   8B..         MOV     ?V0 + 3,R3
   \   00006B   85....       MOV     ?V0 + 0,?V0 + 2
   \   00006E   85....       MOV     ?V0 + 1,?V0 + 3
   1750          
   1751              if ( ( assoc != NULL                            ) &&
   1752                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1753                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000071   E5..         MOV     A,?V0 + 0
   \   000073   45..         ORL     A,?V0 + 1
   \   000075   7003         JNZ     $+5
   \   000077   02....       LJMP    ??ZDSecMgrDeviceRemove_2 & 0xFFFF
   \   00007A   85..82       MOV     DPL,?V0 + 0
   \   00007D   85..83       MOV     DPH,?V0 + 1
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   C3           CLR     C
   \   000086   9401         SUBB    A,#0x1
   \   000088   407B         JC      ??ZDSecMgrDeviceRemove_2
   \   00008A   85..82       MOV     DPL,?V0 + 0
   \   00008D   85..83       MOV     DPH,?V0 + 1
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   E0           MOVX    A,@DPTR
   \   000095   C3           CLR     C
   \   000096   9405         SUBB    A,#0x5
   \   000098   506B         JNC     ??ZDSecMgrDeviceRemove_2
   1754              {
   1755                // check if associated device is authenticated
   1756                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   00009A   85..82       MOV     DPL,?V0 + 0
   \   00009D   85..83       MOV     DPH,?V0 + 1
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   A2E3         MOV     C,0xE0 /* A   */.3
   \   0000A8   500A         JNC     ??ZDSecMgrDeviceRemove_3
   1757                {
   1758                  leaveReq.silent = FALSE;
   \   0000AA   7404         MOV     A,#0x4
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   7400         MOV     A,#0x0
   \   0000B1   F0           MOVX    @DPTR,A
   \   0000B2   8008         SJMP    ??ZDSecMgrDeviceRemove_4
   1759                }
   1760                else
   1761                {
   1762                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   0000B4   7404         MOV     A,#0x4
   \   0000B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B9   7401         MOV     A,#0x1
   \   0000BB   F0           MOVX    @DPTR,A
   1763                }
   1764          
   1765                NLME_LeaveReq( &leaveReq );
   \                     ??ZDSecMgrDeviceRemove_4:
   \   0000BC                ; Setup parameters for call to function NLME_LeaveReq
   \   0000BC   85..82       MOV     DPL,?XSP + 0
   \   0000BF   85..83       MOV     DPH,?XSP + 1
   \   0000C2   AA82         MOV     R2,DPL
   \   0000C4   AB83         MOV     R3,DPH
   \   0000C6   12....       LCALL   ??NLME_LeaveReq?relay
   \   0000C9   E9           MOV     A,R1
   \   0000CA   8039         SJMP    ??ZDSecMgrDeviceRemove_2
   1766              }
   1767            }
   1768            else
   1769            {
   1770              // this is not the parent of the device
   1771              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   0000CC   8E82         MOV     DPL,R6
   \   0000CE   8F83         MOV     DPH,R7
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   F8           MOV     R0,A
   \   0000D6   A3           INC     DPTR
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   F9           MOV     R1,A
   \   0000D9   7405         MOV     A,#0x5
   \   0000DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DE   E8           MOV     A,R0
   \   0000DF   F0           MOVX    @DPTR,A
   \   0000E0   A3           INC     DPTR
   \   0000E1   E9           MOV     A,R1
   \   0000E2   F0           MOVX    @DPTR,A
   1772              remDevReq.childExtAddr = device->extAddr;
   \   0000E3   8E82         MOV     DPL,R6
   \   0000E5   8F83         MOV     DPH,R7
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   F8           MOV     R0,A
   \   0000EB   A3           INC     DPTR
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   F9           MOV     R1,A
   \   0000EE   7407         MOV     A,#0x7
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   E8           MOV     A,R0
   \   0000F4   F0           MOVX    @DPTR,A
   \   0000F5   A3           INC     DPTR
   \   0000F6   E9           MOV     A,R1
   \   0000F7   F0           MOVX    @DPTR,A
   1773          
   1774              APSME_RemoveDeviceReq( &remDevReq );
   \   0000F8                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   0000F8   7405         MOV     A,#0x5
   \   0000FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FD   AA82         MOV     R2,DPL
   \   0000FF   AB83         MOV     R3,DPH
   \   000101   12....       LCALL   ??APSME_RemoveDeviceReq?relay
   \   000104   E9           MOV     A,R1
   1775            }
   1776          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   000105   7409         MOV     A,#0x9
   \   000107   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010A   7F04         MOV     R7,#0x4
   \   00010C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1777          
   1778          /******************************************************************************
   1779           * @fn          ZDSecMgrDeviceValidateSKKE
   1780           *
   1781           * @brief       Decide whether device is allowed for SKKE.
   1782           *
   1783           * @param       device - [in] ZDSecMgrDevice_t, device info
   1784           *
   1785           * @return      ZStatus_t
   1786           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1787          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1788          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1789            ZStatus_t status;
   1790            uint16    ami;
   1791            uint8*    key;
   1792          
   1793          
   1794            // get EXT address
   1795            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FA           MOV     R2,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000026   E9           MOV     A,R1
   \   000027   F5..         MOV     ?V0 + 0,A
   1796          
   1797            if ( status == ZSuccess )
   \   000029   E5..         MOV     A,?V0 + 0
   \   00002B   7033         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1798            {
   1799              // get MASTER key
   1800              status = ZDSecMgrMasterKeyLookup( ami, &key );
   \   00002D                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   AC82         MOV     R4,DPL
   \   000034   AD83         MOV     R5,DPH
   \   000036   85..82       MOV     DPL,?XSP + 0
   \   000039   85..83       MOV     DPH,?XSP + 1
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FA           MOV     R2,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FB           MOV     R3,A
   \   000041   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000044   E9           MOV     A,R1
   \   000045   F5..         MOV     ?V0 + 0,A
   1801          
   1802              if ( status == ZSuccess )
   \   000047   E5..         MOV     A,?V0 + 0
   \   000049   7015         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1803              {
   1804              //  // check if initiator is Trust Center
   1805              //  if ( device->nwkAddr == APSME_TRUSTCENTER_NWKADDR )
   1806              //  {
   1807              //    // verify NWK key not sent
   1808              //    // devtag.todo
   1809              //    // temporary - add device to internal data
   1810              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1811              //  }
   1812              //  else
   1813              //  {
   1814              //    // initiator not Trust Center - End to End SKKE - set policy
   1815              //    // for accepting an SKKE initiation
   1816              //    // temporary - add device to internal data
   1817              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1818              //  }
   1819                  status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00004B                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00004B   85..82       MOV     DPL,?XSP + 0
   \   00004E   85..83       MOV     DPH,?XSP + 1
   \   000051   E0           MOVX    A,@DPTR
   \   000052   FC           MOV     R4,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FD           MOV     R5,A
   \   000056   EE           MOV     A,R6
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   FB           MOV     R3,A
   \   00005A   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   00005D   E9           MOV     A,R1
   \   00005E   F5..         MOV     ?V0 + 0,A
   1820              }
   1821            }
   1822          
   1823            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   000060   A9..         MOV     R1,?V0 + 0
   \   000062   7404         MOV     A,#0x4
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067   7F01         MOV     R7,#0x1
   \   000069   02....       LJMP    ?BANKED_LEAVE_XDATA
   1824          }
   1825          
   1826          /******************************************************************************
   1827           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1828           *
   1829           * @brief       Decide whether device is allowed.
   1830           *
   1831           * @param       device - [in] ZDSecMgrDevice_t, device info
   1832           *
   1833           * @return      ZStatus_t
   1834           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1835          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1836          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1837          
   1838            ZStatus_t status;
   1839            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1840          
   1841            (void)device;  // Intentionally unreferenced parameter
   1842            
   1843            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1844            // the trust center to reject any newly joining devices by sending
   1845            // Remove-device to the parents.
   1846            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1847            {
   1848              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1849            }
   1850          
   1851          
   1852          
   1853          #if 0  // Taken out because the following functionality is only used for test
   1854                 // purpose. A more efficient (above) way is used. It can be put
   1855                 // back in if customers request for a white/black list feature.
   1856                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1857          
   1858            // The following code processes the device black list (stored device list)
   1859            // If the joining device is not part of the forbidden device list
   1860            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1861            // will send Remove-device and ban the device from joining.
   1862          
   1863            uint8     index;
   1864            uint8*    restricted;
   1865          
   1866            // Look through the stored device list - used for restricted devices
   1867            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1868            {
   1869              restricted = ZDSecMgrStoredDeviceList[index];
   1870          
   1871              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1872              {
   1873                // return as unknown device in regards to validation
   1874                status = ZNwkUnknownDevice;
   1875          
   1876                // break from loop
   1877                index = ZDSECMGR_STORED_DEVICES;
   1878              }
   1879            }
   1880          
   1881          #endif
   1882          
   1883            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
   1884          }
   1885          
   1886          /******************************************************************************
   1887           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1888           *
   1889           * @brief       Decide whether device is allowed.
   1890           *
   1891           * @param       device - [in] ZDSecMgrDevice_t, device info
   1892           *
   1893           * @return      ZStatus_t
   1894           */
   1895          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1896          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1897          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1898            ZStatus_t status;
   1899            uint16    ami;
   1900            uint8*    key;
   1901          
   1902          
   1903          //  // check for pre configured setting
   1904          //  if ( device->secure == TRUE )
   1905          //  {
   1906          //    // get EXT address and MASTER key
   1907          //    status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1908          //
   1909          //    if ( status == ZSuccess )
   1910          //    {
   1911          //      status = ZDSecMgrMasterKeyLookup( ami, &key );
   1912          //    }
   1913          //  }
   1914          //  else
   1915          //  {
   1916              // implement EXT address and MASTER key policy here -- the total number of
   1917              // Security Manager entries should never exceed the number of EXT addresses
   1918              // and MASTER keys available
   1919          
   1920              // set status based on policy
   1921              //status = ZNwkUnknownDevice;
   1922          
   1923              // set status based on policy
   1924              status = ZSuccess; // ZNwkUnknownDevice;
   \   00000E   75..00       MOV     ?V0 + 4,#0x0
   1925          
   1926              // get key based on policy
   1927              key = ZDSecMgrTCMasterKey;
   \   000011   75....       MOV     ?V0 + 0,#ZDSecMgrTCMasterKey & 0xff
   \   000014   75....       MOV     ?V0 + 1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   1928          
   1929              // if policy, store new EXT address
   1930              status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000017                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   8582..       MOV     ?V0 + 2,DPL
   \   000020   8583..       MOV     ?V0 + 3,DPH
   \   000023   78..         MOV     R0,#?V0 + 2
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   FC           MOV     R4,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FD           MOV     R5,A
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FA           MOV     R2,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   FB           MOV     R3,A
   \   00003C   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00003F   7402         MOV     A,#0x2
   \   000041   12....       LCALL   ?DEALLOC_XSTACK8
   \   000044   E9           MOV     A,R1
   \   000045   F5..         MOV     ?V0 + 4,A
   1931          
   1932              // set the key
   1933              ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   000047                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   000047   AC..         MOV     R4,?V0 + 0
   \   000049   AD..         MOV     R5,?V0 + 1
   \   00004B   8E82         MOV     DPL,R6
   \   00004D   8F83         MOV     DPH,R7
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   FA           MOV     R2,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FB           MOV     R3,A
   \   000056   12....       LCALL   ??ZDSecMgrMasterKeyLoad?relay
   \   000059   E9           MOV     A,R1
   1934          //  }
   1935          
   1936            // if EXT address and MASTER key available -- add device
   1937            if ( status == ZSuccess )
   \   00005A   E5..         MOV     A,?V0 + 4
   \   00005C   7015         JNZ     ??ZDSecMgrDeviceValidateCM_0
   1938            {
   1939              // add device to internal data - with control
   1940              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00005E                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00005E   85..82       MOV     DPL,?XSP + 0
   \   000061   85..83       MOV     DPH,?XSP + 1
   \   000064   E0           MOVX    A,@DPTR
   \   000065   FC           MOV     R4,A
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FD           MOV     R5,A
   \   000069   EE           MOV     A,R6
   \   00006A   FA           MOV     R2,A
   \   00006B   EF           MOV     A,R7
   \   00006C   FB           MOV     R3,A
   \   00006D   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   000070   E9           MOV     A,R1
   \   000071   F5..         MOV     ?V0 + 4,A
   1941            }
   1942          
   1943            return status;
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   000073   A9..         MOV     R1,?V0 + 4
   \   000075   7402         MOV     A,#0x2
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007A   7F05         MOV     R7,#0x5
   \   00007C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1944          }
   1945          //devtag.pro.security
   1946          #if 0
   1947          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   1948          {
   1949            ZStatus_t status;
   1950            uint16    ami;
   1951            uint8*    key;
   1952          
   1953          
   1954            // check for pre configured setting
   1955            if ( device->secure == TRUE )
   1956            {
   1957              // get EXT address and MASTER key
   1958              status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1959          
   1960              if ( status == ZSuccess )
   1961              {
   1962                status = ZDSecMgrMasterKeyLookup( ami, &key );
   1963              }
   1964            }
   1965            else
   1966            {
   1967              // implement EXT address and MASTER key policy here -- the total number of
   1968              // Security Manager entries should never exceed the number of EXT addresses
   1969              // and MASTER keys available
   1970          
   1971              // set status based on policy
   1972              status = ZSuccess; // ZNwkUnknownDevice;
   1973          
   1974              // get the address index
   1975              if ( ZDSecMgrExtAddrLookup( device->extAddr, &ami ) != ZSuccess )
   1976              {
   1977                // if policy, store new EXT address
   1978                status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   1979              }
   1980          
   1981              // get the address index
   1982              if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   1983              {
   1984                // if policy, store new key -- NULL will zero key
   1985                status = ZDSecMgrMasterKeyStore( ami, NULL );
   1986              }
   1987            }
   1988          
   1989            // if EXT address and MASTER key available -- add device
   1990            if ( status == ZSuccess )
   1991            {
   1992              // add device to internal data - with control
   1993              status = ZDSecMgrDeviceEntryAdd( device, ami );
   1994            }
   1995          
   1996            return status;
   1997          }
   1998          #endif
   1999          
   2000          /******************************************************************************
   2001           * @fn          ZDSecMgrDeviceValidate
   2002           *
   2003           * @brief       Decide whether device is allowed.
   2004           *
   2005           * @param       device - [in] ZDSecMgrDevice_t, device info
   2006           *
   2007           * @return      ZStatus_t
   2008           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2009          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   2010          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2011            ZStatus_t status;
   2012          
   2013          
   2014            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000009   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6401         XRL     A,#0x1
   \   00000F   7030         JNZ     ??ZDSecMgrDeviceValidate_0
   2015            {
   2016              // device may be joining with a secure flag but it is ultimately the Trust
   2017              // Center that decides -- check if expected pre configured device --
   2018              // override settings
   2019              if ( zgPreConfigKeys == TRUE )
   \   000011   90....       MOV     DPTR,#zgPreConfigKeys
   \   000014   E0           MOVX    A,@DPTR
   \   000015   6401         XRL     A,#0x1
   \   000017   700F         JNZ     ??ZDSecMgrDeviceValidate_1
   2020              {
   2021                device->secure = TRUE;
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   7401         MOV     A,#0x1
   \   000025   F0           MOVX    @DPTR,A
   \   000026   800D         SJMP    ??ZDSecMgrDeviceValidate_2
   2022              }
   2023              else
   2024              {
   2025                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   7400         MOV     A,#0x0
   \   000034   F0           MOVX    @DPTR,A
   2026              }
   2027          
   2028              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2029              {
   2030                status = ZDSecMgrDeviceValidateCM( device );
   2031              }
   2032              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2033              {
   2034                status = ZDSecMgrDeviceValidateRM( device );
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000035                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000035   EE           MOV     A,R6
   \   000036   FA           MOV     R2,A
   \   000037   EF           MOV     A,R7
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay
   \   00003C   E9           MOV     A,R1
   \   00003D   F5..         MOV     ?V0 + 0,A
   \   00003F   8003         SJMP    ??ZDSecMgrDeviceValidate_3
   2035              }
   2036            }
   2037            else
   2038            {
   2039              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   000041   75..C8       MOV     ?V0 + 0,#-0x38
   2040            }
   2041          
   2042            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   000044   A9..         MOV     R1,?V0 + 0
   \   000046   7F01         MOV     R7,#0x1
   \   000048   02....       LJMP    ?BANKED_LEAVE_XDATA
   2043          }
   2044          
   2045          /******************************************************************************
   2046           * @fn          ZDSecMgrDeviceJoin
   2047           *
   2048           * @brief       Try to join this device.
   2049           *
   2050           * @param       device - [in] ZDSecMgrDevice_t, device info
   2051           *
   2052           * @return      ZStatus_t
   2053           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2054          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2055          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2056            ZStatus_t status;
   2057            uint16    ami;
   2058          
   2059            // attempt to validate device
   2060            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   EE           MOV     A,R6
   \   00000F   FA           MOV     R2,A
   \   000010   EF           MOV     A,R7
   \   000011   FB           MOV     R3,A
   \   000012   12....       LCALL   ??ZDSecMgrDeviceValidate?relay
   \   000015   E9           MOV     A,R1
   \   000016   F5..         MOV     ?V0 + 2,A
   2061          
   2062            if ( status == ZSuccess )
   \   000018   E5..         MOV     A,?V0 + 2
   \   00001A   703A         JNZ     ??ZDSecMgrDeviceJoin_0
   2063            {
   2064              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2065              {
   2066                ZDSecMgrDeviceCtrlSetup( device );
   2067              }
   2068              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2069              {
   2070                // Add the device to the address manager
   2071                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00001C                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   8582..       MOV     ?V0 + 0,DPL
   \   000025   8583..       MOV     ?V0 + 1,DPH
   \   000028   78..         MOV     R0,#?V0 + 0
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FC           MOV     R4,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FD           MOV     R5,A
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FA           MOV     R2,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FB           MOV     R3,A
   \   000041   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000044   7402         MOV     A,#0x2
   \   000046   12....       LCALL   ?DEALLOC_XSTACK8
   \   000049   E9           MOV     A,R1
   2072                //send the nwk key data to the joining device
   2073                status = ZDSecMgrSendNwkKey( device );
   \   00004A                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00004A   EE           MOV     A,R6
   \   00004B   FA           MOV     R2,A
   \   00004C   EF           MOV     A,R7
   \   00004D   FB           MOV     R3,A
   \   00004E   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000051   E9           MOV     A,R1
   \   000052   F5..         MOV     ?V0 + 2,A
   \   000054   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2074              }
   2075            }
   2076            else
   2077            {
   2078              // not allowed, remove the device
   2079              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000056                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000056   EE           MOV     A,R6
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   FB           MOV     R3,A
   \   00005A   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2080            }
   2081          
   2082            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   00005D   A9..         MOV     R1,?V0 + 2
   \   00005F   7402         MOV     A,#0x2
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   \   000064   7F03         MOV     R7,#0x3
   \   000066   02....       LJMP    ?BANKED_LEAVE_XDATA
   2083          }
   2084          
   2085          /******************************************************************************
   2086           * @fn          ZDSecMgrDeviceJoinDirect
   2087           *
   2088           * @brief       Try to join this device as a direct child.
   2089           *
   2090           * @param       device - [in] ZDSecMgrDevice_t, device info
   2091           *
   2092           * @return      ZStatus_t
   2093           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2094          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2095          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2096            ZStatus_t status;
   2097          
   2098            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   000010   E9           MOV     A,R1
   \   000011   F5..         MOV     ?V0 + 0,A
   2099          
   2100            if ( status == ZSuccess )
   \   000013   E5..         MOV     A,?V0 + 0
   \   000015   700F         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2101            {
   2102              // set association status to authenticated
   2103              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000017                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000017                ; Setup parameters for call to function AssocGetWithShort
   \   000017   8E82         MOV     DPL,R6
   \   000019   8F83         MOV     DPH,R7
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FA           MOV     R2,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??AssocGetWithShort?relay
   \   000023   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2104            }
   2105          
   2106            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   000026   A9..         MOV     R1,?V0 + 0
   \   000028   7F01         MOV     R7,#0x1
   \   00002A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2107          }
   2108          
   2109          /******************************************************************************
   2110           * @fn          ZDSecMgrDeviceJoinFwd
   2111           *
   2112           * @brief       Forward join to Trust Center.
   2113           *
   2114           * @param       device - [in] ZDSecMgrDevice_t, device info
   2115           *
   2116           * @return      ZStatus_t
   2117           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2118          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2119          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2120            ZStatus_t               status;
   2121            APSME_UpdateDeviceReq_t req;
   2122          
   2123          
   2124            // forward any joining device to the Trust Center -- the Trust Center will
   2125            // decide if the device is allowed to join
   2126            status = ZSuccess;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2127          
   2128            // forward authorization to the Trust Center
   2129            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   7400         MOV     A,#0x0
   \   00001D   F0           MOVX    @DPTR,A
   2130            req.devAddr    = device->nwkAddr;
   \   00001E   8E82         MOV     DPL,R6
   \   000020   8F83         MOV     DPH,R7
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E8           MOV     A,R0
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   E9           MOV     A,R1
   \   000030   F0           MOVX    @DPTR,A
   2131            req.devExtAddr = device->extAddr;
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F9           MOV     R1,A
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E8           MOV     A,R0
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   E9           MOV     A,R1
   \   000045   F0           MOVX    @DPTR,A
   2132          
   2133            // set security status, option for router to reject if policy set
   2134            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   A2E7         MOV     C,0xE0 /* A   */.7
   \   000054   503D         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2135            {
   2136              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   A2E6         MOV     C,0xE0 /* A   */.6
   \   000064   5023         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2137              {
   2138                if ( device->secure == TRUE )
   \   000066   8E82         MOV     DPL,R6
   \   000068   8F83         MOV     DPH,R7
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   6401         XRL     A,#0x1
   \   000073   700A         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2139                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000075   7406         MOV     A,#0x6
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   7404         MOV     A,#0x4
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   804F         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2140                else
   2141                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00007F   7406         MOV     A,#0x6
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   7407         MOV     A,#0x7
   \   000086   F0           MOVX    @DPTR,A
   \   000087   8045         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2142              }
   2143              else
   2144                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000089   7406         MOV     A,#0x6
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   7405         MOV     A,#0x5
   \   000090   F0           MOVX    @DPTR,A
   \   000091   803B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2145            }
   2146            else
   2147            {
   2148              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000093   8E82         MOV     DPL,R6
   \   000095   8F83         MOV     DPH,R7
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   A2E6         MOV     C,0xE0 /* A   */.6
   \   0000A1   5023         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2149              {
   2150                if ( device->secure == TRUE )
   \   0000A3   8E82         MOV     DPL,R6
   \   0000A5   8F83         MOV     DPH,R7
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   6401         XRL     A,#0x1
   \   0000B0   700A         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2151                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   0000B2   7406         MOV     A,#0x6
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   7400         MOV     A,#0x0
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   8012         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2152                else
   2153                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   0000BC   7406         MOV     A,#0x6
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   7403         MOV     A,#0x3
   \   0000C3   F0           MOVX    @DPTR,A
   \   0000C4   8008         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2154              }
   2155              else
   2156                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   0000C6   7406         MOV     A,#0x6
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   7401         MOV     A,#0x1
   \   0000CD   F0           MOVX    @DPTR,A
   2157            }
   2158          
   2159            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2160              req.apsSecure = TRUE;
   2161            else
   2162              req.apsSecure = FALSE;
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   0000CE   7407         MOV     A,#0x7
   \   0000D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D3   7400         MOV     A,#0x0
   \   0000D5   F0           MOVX    @DPTR,A
   2163          
   2164            // send and APSME_UPDATE_DEVICE request to the trust center
   2165            status = APSME_UpdateDeviceReq( &req );
   \   0000D6                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   0000D6   85..82       MOV     DPL,?XSP + 0
   \   0000D9   85..83       MOV     DPH,?XSP + 1
   \   0000DC   AA82         MOV     R2,DPL
   \   0000DE   AB83         MOV     R3,DPH
   \   0000E0   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   \   0000E3   E9           MOV     A,R1
   \   0000E4   F5..         MOV     ?V0 + 0,A
   2166          
   2167            return status;
   \   0000E6   A9..         MOV     R1,?V0 + 0
   \   0000E8   7408         MOV     A,#0x8
   \   0000EA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000ED   7F01         MOV     R7,#0x1
   \   0000EF   02....       LJMP    ?BANKED_LEAVE_XDATA
   2168          }
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrDeviceNew
   2172           *
   2173           * @brief       Process a new device.
   2174           *
   2175           * @param       device - [in] ZDSecMgrDevice_t, device info
   2176           *
   2177           * @return      ZStatus_t
   2178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2179          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2180          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2181            ZStatus_t status;
   2182          
   2183            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2184            {
   2185              // try to join this device
   2186              status = ZDSecMgrDeviceJoinDirect( joiner );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoinDirect
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   ??ZDSecMgrDeviceJoinDirect?relay
   \   000010   E9           MOV     A,R1
   \   000011   F5..         MOV     ?V0 + 0,A
   2187            }
   2188            else
   2189            {
   2190              status = ZDSecMgrDeviceJoinFwd( joiner );
   2191            }
   2192          
   2193            return status;
   \   000013   A9..         MOV     R1,?V0 + 0
   \   000015   7F01         MOV     R7,#0x1
   \   000017   02....       LJMP    ?BANKED_LEAVE_XDATA
   2194          }
   2195          
   2196          /******************************************************************************
   2197           * @fn          ZDSecMgrAssocDeviceAuth
   2198           *
   2199           * @brief       Set associated device status to authenticated
   2200           *
   2201           * @param       assoc - [in, out] associated_devices_t
   2202           *
   2203           * @return      none
   2204           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2205          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2206          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2207            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   2208            {
   2209              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   2210            }
   2211          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   02....       LJMP    ?BRET
   2212          
   2213          /******************************************************************************
   2214           * @fn          ZDSecMgrAuthInitiate
   2215           *
   2216           * @brief       Initiate entity authentication
   2217           *
   2218           * @param       responder - [in] responder EXT address
   2219           *
   2220           * @return      none
   2221           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2222          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2223          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2224            APSME_AuthenticateReq_t req;
   2225          
   2226          
   2227            // make sure NWK address is available
   2228            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001F   E9           MOV     A,R1
   \   000020   602C         JZ      ??ZDSecMgrAuthInitiate_0
   2229            {
   2230              // set request fields
   2231              req.extAddr   = responder;
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   EE           MOV     A,R6
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   EF           MOV     A,R7
   \   00002B   F0           MOVX    @DPTR,A
   2232              req.action    = APSME_EA_INITIATE;
   \   00002C   7406         MOV     A,#0x6
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   7400         MOV     A,#0x0
   \   000033   F0           MOVX    @DPTR,A
   2233              req.challenge = NULL;
   \   000034   7404         MOV     A,#0x4
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   7400         MOV     A,#0x0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   7400         MOV     A,#0x0
   \   00003F   F0           MOVX    @DPTR,A
   2234          
   2235              // start EA processing
   2236              APSME_AuthenticateReq( &req );
   \   000040                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000040   85..82       MOV     DPL,?XSP + 0
   \   000043   85..83       MOV     DPH,?XSP + 1
   \   000046   AA82         MOV     R2,DPL
   \   000048   AB83         MOV     R3,DPH
   \   00004A   12....       LCALL   ??APSME_AuthenticateReq?relay
   \   00004D   E9           MOV     A,R1
   2237            }
   2238          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   00004E   7407         MOV     A,#0x7
   \   000050   12....       LCALL   ?DEALLOC_XSTACK8
   \   000053   7F01         MOV     R7,#0x1
   \   000055   02....       LJMP    ?BANKED_LEAVE_XDATA
   2239          
   2240          /******************************************************************************
   2241           * @fn          ZDSecMgrAuthNwkKey
   2242           *
   2243           * @brief       Handle next step in authentication process
   2244           *
   2245           * @param       none
   2246           *
   2247           * @return      none
   2248           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2249          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2250          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2251            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700D         JNZ     ??ZDSecMgrAuthNwkKey_0
   2252            {
   2253              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2254              {
   2255                uint8 parent[Z_EXTADDR_LEN];
   2256          
   2257                // get parent's EXT address
   2258                NLME_GetCoordExtAddr( parent );
   2259          
   2260                // begin entity authentication with parent
   2261                ZDSecMgrAuthInitiate( parent );
   2262              }
   2263              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2264              {
   2265                // inform ZDO that device has been authenticated
   2266                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay
   \   000018   E9           MOV     A,R1
   2267              }
   2268            }
   2269          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000019   D083         POP     DPH
   \   00001B   D082         POP     DPL
   \   00001D   02....       LJMP    ?BRET
   2270          
   2271          /******************************************************************************
   2272           * PUBLIC FUNCTIONS
   2273           */
   2274          /******************************************************************************
   2275           * @fn          ZDSecMgrInit
   2276           *
   2277           * @brief       Initialize ZigBee Device Security Manager.
   2278           *
   2279           * @param       state - device initialization state
   2280           *
   2281           * @return      none
   2282           */
   2283          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2284          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2285          void ZDSecMgrAddrMgrCB( uint8           update,
   2286                                  AddrMgrEntry_t* newEntry,
   2287                                  AddrMgrEntry_t* oldEntry )
   2288          {
   2289            (void)update;
   2290            (void)newEntry;
   2291            (void)oldEntry;
   2292          }
   2293          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2294          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2295          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   2296          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   2297            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2298                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2299            {
   2300              // initialize sub modules
   2301              ZDSecMgrMasterKeyInit();
   2302              ZDSecMgrEntryInit(state);
   2303          
   2304              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2305              {
   2306                ZDSecMgrCtrlInit();
   2307              }
   2308          
   2309              // register with Address Manager
   2310              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2311              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2312              #endif
   2313            }
   2314          
   2315            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2316            {
   2317              // configure SKA slot data
   2318              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2319            }
   2320            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2321            {
   2322              APSME_TCLinkKeyInit();  
   2323              APSME_TCAddrSetup( zgTrustCenterAddr );    
   2324            
   2325            }
   2326          
   2327            if ( ZG_SECURE_ENABLED )
   2328            {
   2329              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2330              {
   2331                // setup joining permissions
   2332                ZDSecMgrPermitJoiningEnabled = TRUE;
   2333                ZDSecMgrPermitJoiningTimed   = FALSE;
   2334              }
   2335            }
   2336          
   2337            // configure security based on security mode and type of device
   2338            ZDSecMgrConfig();
   \   000007                ; Setup parameters for call to function ZDSecMgrConfig
   \   000007   12....       LCALL   ??ZDSecMgrConfig?relay
   2339          }
   \   00000A   7F01         MOV     R7,#0x1
   \   00000C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2340          
   2341          /******************************************************************************
   2342           * @fn          ZDSecMgrConfig
   2343           *
   2344           * @brief       Configure ZigBee Device Security Manager.
   2345           *
   2346           * @param       none
   2347           *
   2348           * @return      none
   2349           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2350          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   2351          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2352            if ( ZG_SECURE_ENABLED )
   2353            {
   2354              SSP_Init();
   2355          
   2356              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2357                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2358              {
   2359                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2360                {
   2361                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2362                  APSME_SecurityCM_CD();
   2363                }
   2364                else if ( ZSTACK_ROUTER_BUILD )
   2365                {
   2366                  // COMMERCIAL MODE - ROUTER DEVICE
   2367                  APSME_SecurityCM_RD();
   2368                }
   2369                else
   2370                {
   2371                  // COMMERCIAL MODE - END DEVICE
   2372                  APSME_SecurityCM_ED();
   2373                }
   2374              }
   2375              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2376              {
   2377                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2378                {
   2379                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2380                  APSME_SecurityRM_CD();
   2381                }
   2382                else if ( ZSTACK_ROUTER_BUILD )
   2383                {
   2384                  // RESIDENTIAL MODE - ROUTER DEVICE
   2385                  APSME_SecurityRM_RD();
   2386                }
   2387                else
   2388                {
   2389                  // RESIDENTIAL MODE - END DEVICE
   2390                  APSME_SecurityRM_ED();
   2391                }
   2392              }
   2393            }
   2394            else
   2395            {
   2396              // NO SECURITY
   2397              APSME_SecurityNM();
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   ??APSME_SecurityNM?relay
   2398            }
   2399          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   2400          
   2401          /******************************************************************************
   2402           * @fn          ZDSecMgrPermitJoining
   2403           *
   2404           * @brief       Process request to change joining permissions.
   2405           *
   2406           * @param       duration - [in] timed duration for join in seconds
   2407           *                         - 0x00 not allowed
   2408           *                         - 0xFF allowed without timeout
   2409           *
   2410           * @return      uint8 - success(TRUE:FALSE)
   2411           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2412          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2413          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2414            uint8 accept;
   2415          
   2416          
   2417            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   7400         MOV     A,#0x0
   \   00000B   F0           MOVX    @DPTR,A
   2418          
   2419            if ( duration > 0 )
   \   00000C   E8           MOV     A,R0
   \   00000D   C3           CLR     C
   \   00000E   9401         SUBB    A,#0x1
   \   000010   4013         JC      ??ZDSecMgrPermitJoining_0
   2420            {
   2421              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000012   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000015   7401         MOV     A,#0x1
   \   000017   F0           MOVX    @DPTR,A
   2422          
   2423              if ( duration != 0xFF )
   \   000018   74FF         MOV     A,#-0x1
   \   00001A   68           XRL     A,R0
   \   00001B   600E         JZ      ??ZDSecMgrPermitJoining_1
   2424              {
   2425                ZDSecMgrPermitJoiningTimed = TRUE;
   \   00001D   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000020   7401         MOV     A,#0x1
   \   000022   F0           MOVX    @DPTR,A
   \   000023   8006         SJMP    ??ZDSecMgrPermitJoining_1
   2426              }
   2427            }
   2428            else
   2429            {
   2430              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000025   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000028   7400         MOV     A,#0x0
   \   00002A   F0           MOVX    @DPTR,A
   2431            }
   2432          
   2433            accept = TRUE;
   \                     ??ZDSecMgrPermitJoining_1:
   \   00002B   7901         MOV     R1,#0x1
   2434          
   2435            return accept;
   \   00002D   D083         POP     DPH
   \   00002F   D082         POP     DPL
   \   000031   02....       LJMP    ?BRET
   2436          }
   2437          
   2438          /******************************************************************************
   2439           * @fn          ZDSecMgrPermitJoiningTimeout
   2440           *
   2441           * @brief       Process permit joining timeout
   2442           *
   2443           * @param       none
   2444           *
   2445           * @return      none
   2446           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2447          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2448          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2449            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   700C         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2450            {
   2451              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   7400         MOV     A,#0x0
   \   000011   F0           MOVX    @DPTR,A
   2452              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000012   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000015   7400         MOV     A,#0x0
   \   000017   F0           MOVX    @DPTR,A
   2453            }
   2454          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000018   D083         POP     DPH
   \   00001A   D082         POP     DPL
   \   00001C   02....       LJMP    ?BRET
   2455          
   2456          /******************************************************************************
   2457           * @fn          ZDSecMgrNewDeviceEvent
   2458           *
   2459           * @brief       Process a the new device event, if found reset new device
   2460           *              event/timer.
   2461           *
   2462           * @param       none
   2463           *
   2464           * @return      uint8 - found(TRUE:FALSE)
   2465           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2466          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2467          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2468            uint8                 found;
   2469            ZDSecMgrDevice_t      device;
   2470            AddrMgrEntry_t        addrEntry;
   2471            associated_devices_t* assoc;
   2472            ZStatus_t             status;
   2473          
   2474            // initialize return results
   2475            found = FALSE;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   2476          
   2477            // look for device in the security init state
   2478            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   ??AssocMatchDeviceStatus?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   AE..         MOV     R6,?V0 + 2
   \   000018   AF..         MOV     R7,?V0 + 3
   2479          
   2480            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   4F           ORL     A,R7
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2481            {
   2482              // device found
   2483              found = TRUE;
   \   000021   75..01       MOV     ?V0 + 0,#0x1
   2484          
   2485              // check for preconfigured security
   2486              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV     DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6401         XRL     A,#0x1
   \   00002A   7007         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2487              {
   2488                // set association status to authenticated
   2489                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   EE           MOV     A,R6
   \   00002D   FA           MOV     R2,A
   \   00002E   EF           MOV     A,R7
   \   00002F   FB           MOV     R3,A
   \   000030   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2490              }
   2491          
   2492              // set up device info
   2493              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   000033   740A         MOV     A,#0xa
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   7400         MOV     A,#0x0
   \   00003A   F0           MOVX    @DPTR,A
   2494              addrEntry.index = assoc->addrIdx;
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F8           MOV     R0,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F9           MOV     R1,A
   \   000046   7415         MOV     A,#0x15
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   E8           MOV     A,R0
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   E9           MOV     A,R1
   \   00004F   F0           MOVX    @DPTR,A
   2495              AddrMgrEntryGet( &addrEntry );
   \   000050                ; Setup parameters for call to function AddrMgrEntryGet
   \   000050   740A         MOV     A,#0xa
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   AA82         MOV     R2,DPL
   \   000057   AB83         MOV     R3,DPH
   \   000059   12....       LCALL   ??AddrMgrEntryGet?relay
   \   00005C   E9           MOV     A,R1
   2496          
   2497              device.nwkAddr    = assoc->shortAddr;
   \   00005D   8E82         MOV     DPL,R6
   \   00005F   8F83         MOV     DPH,R7
   \   000061   E0           MOVX    A,@DPTR
   \   000062   F8           MOV     R0,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F9           MOV     R1,A
   \   000066   85..82       MOV     DPL,?XSP + 0
   \   000069   85..83       MOV     DPH,?XSP + 1
   \   00006C   E8           MOV     A,R0
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   A3           INC     DPTR
   \   00006F   E9           MOV     A,R1
   \   000070   F0           MOVX    @DPTR,A
   2498              device.extAddr    = addrEntry.extAddr;
   \   000071   740D         MOV     A,#0xd
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   A882         MOV     R0,DPL
   \   000078   A983         MOV     R1,DPH
   \   00007A   7402         MOV     A,#0x2
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   E8           MOV     A,R0
   \   000080   F0           MOVX    @DPTR,A
   \   000081   A3           INC     DPTR
   \   000082   E9           MOV     A,R1
   \   000083   F0           MOVX    @DPTR,A
   2499              device.parentAddr = NLME_GetShortAddr();
   \   000084                ; Setup parameters for call to function NLME_GetShortAddr
   \   000084   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000087   7404         MOV     A,#0x4
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   EA           MOV     A,R2
   \   00008D   F0           MOVX    @DPTR,A
   \   00008E   A3           INC     DPTR
   \   00008F   EB           MOV     A,R3
   \   000090   F0           MOVX    @DPTR,A
   2500              device.secure     = FALSE;
   \   000091   7406         MOV     A,#0x6
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   7400         MOV     A,#0x0
   \   000098   F0           MOVX    @DPTR,A
   2501              device.devStatus  = assoc->devStatus;
   \   000099   8E82         MOV     DPL,R6
   \   00009B   8F83         MOV     DPH,R7
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   C0E0         PUSH    A
   \   0000A5   7407         MOV     A,#0x7
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   D0E0         POP     A
   \   0000AC   F0           MOVX    @DPTR,A
   2502          
   2503              // process new device
   2504              status = ZDSecMgrDeviceNew( &device );
   \   0000AD                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   85..83       MOV     DPH,?XSP + 1
   \   0000B3   AA82         MOV     R2,DPL
   \   0000B5   AB83         MOV     R3,DPH
   \   0000B7   12....       LCALL   ??ZDSecMgrDeviceNew?relay
   \   0000BA   E9           MOV     A,R1
   \   0000BB   F5..         MOV     ?V0 + 1,A
   2505          
   2506              if ( status == ZSuccess )
   \   0000BD   E5..         MOV     A,?V0 + 1
   \   0000BF   700F         JNZ     ??ZDSecMgrNewDeviceEvent_2
   2507              {
   2508                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   0000C1   8E82         MOV     DPL,R6
   \   0000C3   8F83         MOV     DPH,R7
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   C2E2         CLR     0xE0 /* A   */.2
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   8013         SJMP    ??ZDSecMgrNewDeviceEvent_0
   2509              }
   2510              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   0000D0   74C8         MOV     A,#-0x38
   \   0000D2   65..         XRL     A,?V0 + 1
   \   0000D4   700D         JNZ     ??ZDSecMgrNewDeviceEvent_0
   2511              {
   2512                AssocRemove( addrEntry.extAddr );
   \   0000D6                ; Setup parameters for call to function AssocRemove
   \   0000D6   740D         MOV     A,#0xd
   \   0000D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DB   AA82         MOV     R2,DPL
   \   0000DD   AB83         MOV     R3,DPH
   \   0000DF   12....       LCALL   ??AssocRemove?relay
   \   0000E2   E9           MOV     A,R1
   2513              }
   2514            }
   2515          
   2516            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000E3   A9..         MOV     R1,?V0 + 0
   \   0000E5   7417         MOV     A,#0x17
   \   0000E7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EA   7F04         MOV     R7,#0x4
   \   0000EC   02....       LJMP    ?BANKED_LEAVE_XDATA
   2517          }
   2518          
   2519          /******************************************************************************
   2520           * @fn          ZDSecMgrEvent
   2521           *
   2522           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2523           *
   2524           * @param       none
   2525           *
   2526           * @return      none
   2527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2528          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2529          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2530            uint8            action;
   2531            uint8            restart;
   2532            uint16           index;
   2533            AddrMgrEntry_t   entry;
   2534            ZDSecMgrDevice_t device;
   2535          
   2536          
   2537            // verify data is available
   2538            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   7003         JNZ     $+5
   \   000016   02....       LJMP    ??ZDSecMgrEvent_0 & 0xFFFF
   2539            {
   2540              action  = FALSE;
   \   000019   75..00       MOV     ?V0 + 0,#0x0
   2541              restart = FALSE;
   \   00001C   75..00       MOV     ?V0 + 1,#0x0
   2542          
   2543              // update all the counters
   2544              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEvent_1:
   \   000023   C3           CLR     C
   \   000024   EE           MOV     A,R6
   \   000025   9403         SUBB    A,#0x3
   \   000027   EF           MOV     A,R7
   \   000028   9400         SUBB    A,#0x0
   \   00002A   4003         JC      $+5
   \   00002C   02....       LJMP    ??ZDSecMgrEvent_2 & 0xFFFF
   2545              {
   2546                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \   00002F   EE           MOV     A,R6
   \   000030   F8           MOV     R0,A
   \   000031   EF           MOV     A,R7
   \   000032   F9           MOV     R1,A
   \   000033   E8           MOV     A,R0
   \   000034   75F007       MOV     B,#0x7
   \   000037   A4           MUL     AB
   \   000038   C8           XCH     A,R0
   \   000039   AAF0         MOV     R2,B
   \   00003B   75F000       MOV     B,#0x0
   \   00003E   A4           MUL     AB
   \   00003F   2A           ADD     A,R2
   \   000040   FA           MOV     R2,A
   \   000041   75F007       MOV     B,#0x7
   \   000044   E9           MOV     A,R1
   \   000045   A4           MUL     AB
   \   000046   2A           ADD     A,R2
   \   000047   F9           MOV     R1,A
   \   000048   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   28           ADD     A,R0
   \   00004D   FA           MOV     R2,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   39           ADDC    A,R1
   \   000051   8A82         MOV     DPL,R2
   \   000053   F583         MOV     DPH,A
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   7003         JNZ     $+5
   \   00005D   02....       LJMP    ??ZDSecMgrEvent_3 & 0xFFFF
   2547                {
   2548                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   000060   EE           MOV     A,R6
   \   000061   F8           MOV     R0,A
   \   000062   EF           MOV     A,R7
   \   000063   F9           MOV     R1,A
   \   000064   E8           MOV     A,R0
   \   000065   75F007       MOV     B,#0x7
   \   000068   A4           MUL     AB
   \   000069   C8           XCH     A,R0
   \   00006A   AAF0         MOV     R2,B
   \   00006C   75F000       MOV     B,#0x0
   \   00006F   A4           MUL     AB
   \   000070   2A           ADD     A,R2
   \   000071   FA           MOV     R2,A
   \   000072   75F007       MOV     B,#0x7
   \   000075   E9           MOV     A,R1
   \   000076   A4           MUL     AB
   \   000077   2A           ADD     A,R2
   \   000078   F9           MOV     R1,A
   \   000079   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   28           ADD     A,R0
   \   00007E   FA           MOV     R2,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   39           ADDC    A,R1
   \   000082   8A82         MOV     DPL,R2
   \   000084   F583         MOV     DPH,A
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   6030         JZ      ??ZDSecMgrEvent_4
   2549                  {
   2550                    ZDSecMgrCtrlData[index].cntr--;
   \   00008F   EE           MOV     A,R6
   \   000090   F8           MOV     R0,A
   \   000091   EF           MOV     A,R7
   \   000092   F9           MOV     R1,A
   \   000093   E8           MOV     A,R0
   \   000094   75F007       MOV     B,#0x7
   \   000097   A4           MUL     AB
   \   000098   C8           XCH     A,R0
   \   000099   AAF0         MOV     R2,B
   \   00009B   75F000       MOV     B,#0x0
   \   00009E   A4           MUL     AB
   \   00009F   2A           ADD     A,R2
   \   0000A0   FA           MOV     R2,A
   \   0000A1   75F007       MOV     B,#0x7
   \   0000A4   E9           MOV     A,R1
   \   0000A5   A4           MUL     AB
   \   0000A6   2A           ADD     A,R2
   \   0000A7   F9           MOV     R1,A
   \   0000A8   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   28           ADD     A,R0
   \   0000AD   FA           MOV     R2,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   39           ADDC    A,R1
   \   0000B1   8A82         MOV     DPL,R2
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   24FF         ADD     A,#-0x1
   \   0000BE   F0           MOVX    @DPTR,A
   2551                  }
   2552          
   2553                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_4:
   \   0000BF   E5..         MOV     A,?V0 + 0
   \   0000C1   6003         JZ      $+5
   \   0000C3   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   \   0000C6   EE           MOV     A,R6
   \   0000C7   F8           MOV     R0,A
   \   0000C8   EF           MOV     A,R7
   \   0000C9   F9           MOV     R1,A
   \   0000CA   E8           MOV     A,R0
   \   0000CB   75F007       MOV     B,#0x7
   \   0000CE   A4           MUL     AB
   \   0000CF   C8           XCH     A,R0
   \   0000D0   AAF0         MOV     R2,B
   \   0000D2   75F000       MOV     B,#0x0
   \   0000D5   A4           MUL     AB
   \   0000D6   2A           ADD     A,R2
   \   0000D7   FA           MOV     R2,A
   \   0000D8   75F007       MOV     B,#0x7
   \   0000DB   E9           MOV     A,R1
   \   0000DC   A4           MUL     AB
   \   0000DD   2A           ADD     A,R2
   \   0000DE   F9           MOV     R1,A
   \   0000DF   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   28           ADD     A,R0
   \   0000E4   FA           MOV     R2,A
   \   0000E5   A3           INC     DPTR
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   39           ADDC    A,R1
   \   0000E8   8A82         MOV     DPL,R2
   \   0000EA   F583         MOV     DPH,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   A3           INC     DPTR
   \   0000F1   A3           INC     DPTR
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   6003         JZ      $+5
   \   0000F5   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   2554                  {
   2555                    action = TRUE;
   \   0000F8   75..01       MOV     ?V0 + 0,#0x1
   2556          
   2557                    // update from control data
   2558                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   0000FB   EE           MOV     A,R6
   \   0000FC   F8           MOV     R0,A
   \   0000FD   EF           MOV     A,R7
   \   0000FE   F9           MOV     R1,A
   \   0000FF   E8           MOV     A,R0
   \   000100   75F007       MOV     B,#0x7
   \   000103   A4           MUL     AB
   \   000104   C8           XCH     A,R0
   \   000105   AAF0         MOV     R2,B
   \   000107   75F000       MOV     B,#0x0
   \   00010A   A4           MUL     AB
   \   00010B   2A           ADD     A,R2
   \   00010C   FA           MOV     R2,A
   \   00010D   75F007       MOV     B,#0x7
   \   000110   E9           MOV     A,R1
   \   000111   A4           MUL     AB
   \   000112   2A           ADD     A,R2
   \   000113   F9           MOV     R1,A
   \   000114   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000117   E0           MOVX    A,@DPTR
   \   000118   28           ADD     A,R0
   \   000119   FA           MOV     R2,A
   \   00011A   A3           INC     DPTR
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   39           ADDC    A,R1
   \   00011D   8A82         MOV     DPL,R2
   \   00011F   F583         MOV     DPH,A
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   F8           MOV     R0,A
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   F9           MOV     R1,A
   \   000128   7404         MOV     A,#0x4
   \   00012A   12....       LCALL   ?XSTACK_DISP0_8
   \   00012D   E8           MOV     A,R0
   \   00012E   F0           MOVX    @DPTR,A
   \   00012F   A3           INC     DPTR
   \   000130   E9           MOV     A,R1
   \   000131   F0           MOVX    @DPTR,A
   2559                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \   000132   EE           MOV     A,R6
   \   000133   F8           MOV     R0,A
   \   000134   EF           MOV     A,R7
   \   000135   F9           MOV     R1,A
   \   000136   E8           MOV     A,R0
   \   000137   75F007       MOV     B,#0x7
   \   00013A   A4           MUL     AB
   \   00013B   C8           XCH     A,R0
   \   00013C   AAF0         MOV     R2,B
   \   00013E   75F000       MOV     B,#0x0
   \   000141   A4           MUL     AB
   \   000142   2A           ADD     A,R2
   \   000143   FA           MOV     R2,A
   \   000144   75F007       MOV     B,#0x7
   \   000147   E9           MOV     A,R1
   \   000148   A4           MUL     AB
   \   000149   2A           ADD     A,R2
   \   00014A   F9           MOV     R1,A
   \   00014B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00014E   E0           MOVX    A,@DPTR
   \   00014F   28           ADD     A,R0
   \   000150   FA           MOV     R2,A
   \   000151   A3           INC     DPTR
   \   000152   E0           MOVX    A,@DPTR
   \   000153   39           ADDC    A,R1
   \   000154   8A82         MOV     DPL,R2
   \   000156   F583         MOV     DPH,A
   \   000158   A3           INC     DPTR
   \   000159   A3           INC     DPTR
   \   00015A   A3           INC     DPTR
   \   00015B   A3           INC     DPTR
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   C0E0         PUSH    A
   \   00015F   7406         MOV     A,#0x6
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   D0E0         POP     A
   \   000166   F0           MOVX    @DPTR,A
   2560                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   000167   EE           MOV     A,R6
   \   000168   F8           MOV     R0,A
   \   000169   EF           MOV     A,R7
   \   00016A   F9           MOV     R1,A
   \   00016B   E8           MOV     A,R0
   \   00016C   75F007       MOV     B,#0x7
   \   00016F   A4           MUL     AB
   \   000170   C8           XCH     A,R0
   \   000171   AAF0         MOV     R2,B
   \   000173   75F000       MOV     B,#0x0
   \   000176   A4           MUL     AB
   \   000177   2A           ADD     A,R2
   \   000178   FA           MOV     R2,A
   \   000179   75F007       MOV     B,#0x7
   \   00017C   E9           MOV     A,R1
   \   00017D   A4           MUL     AB
   \   00017E   2A           ADD     A,R2
   \   00017F   F9           MOV     R1,A
   \   000180   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000183   E0           MOVX    A,@DPTR
   \   000184   28           ADD     A,R0
   \   000185   F8           MOV     R0,A
   \   000186   A3           INC     DPTR
   \   000187   E0           MOVX    A,@DPTR
   \   000188   39           ADDC    A,R1
   \   000189   F9           MOV     R1,A
   \   00018A   7408         MOV     A,#0x8
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   E8           MOV     A,R0
   \   000190   F0           MOVX    @DPTR,A
   \   000191   A3           INC     DPTR
   \   000192   E9           MOV     A,R1
   \   000193   F0           MOVX    @DPTR,A
   2561          
   2562                    // set the user and address index
   2563                    entry.user  = ADDRMGR_USER_SECURITY;
   \   000194   740A         MOV     A,#0xa
   \   000196   12....       LCALL   ?XSTACK_DISP0_8
   \   000199   7402         MOV     A,#0x2
   \   00019B   F0           MOVX    @DPTR,A
   2564                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \   00019C   EE           MOV     A,R6
   \   00019D   F8           MOV     R0,A
   \   00019E   EF           MOV     A,R7
   \   00019F   F9           MOV     R1,A
   \   0001A0   E8           MOV     A,R0
   \   0001A1   75F007       MOV     B,#0x7
   \   0001A4   A4           MUL     AB
   \   0001A5   C8           XCH     A,R0
   \   0001A6   AAF0         MOV     R2,B
   \   0001A8   75F000       MOV     B,#0x0
   \   0001AB   A4           MUL     AB
   \   0001AC   2A           ADD     A,R2
   \   0001AD   FA           MOV     R2,A
   \   0001AE   75F007       MOV     B,#0x7
   \   0001B1   E9           MOV     A,R1
   \   0001B2   A4           MUL     AB
   \   0001B3   2A           ADD     A,R2
   \   0001B4   F9           MOV     R1,A
   \   0001B5   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0001B8   E0           MOVX    A,@DPTR
   \   0001B9   28           ADD     A,R0
   \   0001BA   FA           MOV     R2,A
   \   0001BB   A3           INC     DPTR
   \   0001BC   E0           MOVX    A,@DPTR
   \   0001BD   39           ADDC    A,R1
   \   0001BE   8A82         MOV     DPL,R2
   \   0001C0   F583         MOV     DPH,A
   \   0001C2   E0           MOVX    A,@DPTR
   \   0001C3   F8           MOV     R0,A
   \   0001C4   A3           INC     DPTR
   \   0001C5   E0           MOVX    A,@DPTR
   \   0001C6   F583         MOV     DPH,A
   \   0001C8   8882         MOV     DPL,R0
   \   0001CA   E0           MOVX    A,@DPTR
   \   0001CB   F8           MOV     R0,A
   \   0001CC   A3           INC     DPTR
   \   0001CD   E0           MOVX    A,@DPTR
   \   0001CE   F9           MOV     R1,A
   \   0001CF   7415         MOV     A,#0x15
   \   0001D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D4   E8           MOV     A,R0
   \   0001D5   F0           MOVX    @DPTR,A
   \   0001D6   A3           INC     DPTR
   \   0001D7   E9           MOV     A,R1
   \   0001D8   F0           MOVX    @DPTR,A
   2565          
   2566                    // get the address data
   2567                    AddrMgrEntryGet( &entry );
   \   0001D9                ; Setup parameters for call to function AddrMgrEntryGet
   \   0001D9   740A         MOV     A,#0xa
   \   0001DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DE   AA82         MOV     R2,DPL
   \   0001E0   AB83         MOV     R3,DPH
   \   0001E2   12....       LCALL   ??AddrMgrEntryGet?relay
   \   0001E5   E9           MOV     A,R1
   2568          
   2569                    // set device address data
   2570                    device.nwkAddr = entry.nwkAddr;
   \   0001E6   740B         MOV     A,#0xb
   \   0001E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EB   E0           MOVX    A,@DPTR
   \   0001EC   F8           MOV     R0,A
   \   0001ED   A3           INC     DPTR
   \   0001EE   E0           MOVX    A,@DPTR
   \   0001EF   F9           MOV     R1,A
   \   0001F0   85..82       MOV     DPL,?XSP + 0
   \   0001F3   85..83       MOV     DPH,?XSP + 1
   \   0001F6   E8           MOV     A,R0
   \   0001F7   F0           MOVX    @DPTR,A
   \   0001F8   A3           INC     DPTR
   \   0001F9   E9           MOV     A,R1
   \   0001FA   F0           MOVX    @DPTR,A
   2571                    device.extAddr = entry.extAddr;
   \   0001FB   740D         MOV     A,#0xd
   \   0001FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000200   A882         MOV     R0,DPL
   \   000202   A983         MOV     R1,DPH
   \   000204   7402         MOV     A,#0x2
   \   000206   12....       LCALL   ?XSTACK_DISP0_8
   \   000209   E8           MOV     A,R0
   \   00020A   F0           MOVX    @DPTR,A
   \   00020B   A3           INC     DPTR
   \   00020C   E9           MOV     A,R1
   \   00020D   F0           MOVX    @DPTR,A
   2572          
   2573                    // update from entry data
   2574                    ZDSecMgrDeviceCtrlHandler( &device );
   \   00020E                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   00020E   85..82       MOV     DPL,?XSP + 0
   \   000211   85..83       MOV     DPH,?XSP + 1
   \   000214   AA82         MOV     R2,DPL
   \   000216   AB83         MOV     R3,DPH
   \   000218   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   \   00021B   8003         SJMP    ??ZDSecMgrEvent_3
   2575                  }
   2576                  else
   2577                  {
   2578                    restart = TRUE;
   \                     ??ZDSecMgrEvent_5:
   \   00021D   75..01       MOV     ?V0 + 1,#0x1
   2579                  }
   2580                }
   2581              }
   \                     ??ZDSecMgrEvent_3:
   \   000220   EE           MOV     A,R6
   \   000221   2401         ADD     A,#0x1
   \   000223   FE           MOV     R6,A
   \   000224   EF           MOV     A,R7
   \   000225   3400         ADDC    A,#0x0
   \   000227   FF           MOV     R7,A
   \   000228   02....       LJMP    ??ZDSecMgrEvent_1 & 0xFFFF
   2582          
   2583              // check for timer restart
   2584              if ( restart == TRUE )
   \                     ??ZDSecMgrEvent_2:
   \   00022B   7401         MOV     A,#0x1
   \   00022D   65..         XRL     A,?V0 + 1
   \   00022F   7011         JNZ     ??ZDSecMgrEvent_0
   2585              {
   2586                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   000231                ; Setup parameters for call to function osal_start_timerEx
   \   000231   7C64         MOV     R4,#0x64
   \   000233   7D00         MOV     R5,#0x0
   \   000235   7A00         MOV     R2,#0x0
   \   000237   7B01         MOV     R3,#0x1
   \   000239   90....       MOV     DPTR,#ZDAppTaskID
   \   00023C   E0           MOVX    A,@DPTR
   \   00023D   F9           MOV     R1,A
   \   00023E   12....       LCALL   ??osal_start_timerEx?relay
   \   000241   E9           MOV     A,R1
   2587              }
   2588            }
   2589          }
   \                     ??ZDSecMgrEvent_0:
   \   000242   7417         MOV     A,#0x17
   \   000244   12....       LCALL   ?DEALLOC_XSTACK8
   \   000247   7F02         MOV     R7,#0x2
   \   000249   02....       LJMP    ?BANKED_LEAVE_XDATA
   2590          
   2591          /******************************************************************************
   2592           * @fn          ZDSecMgrEstablishKeyCfm
   2593           *
   2594           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2595           *
   2596           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2597           *
   2598           * @return      none
   2599           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2600          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2601          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2602            // send the NWK key
   2603            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2604            {
   2605              // update control for specified EXT address
   2606              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceCtrlUpdate
   \   000009   7905         MOV     R1,#0x5
   \   00000B   EE           MOV     A,R6
   \   00000C   2402         ADD     A,#0x2
   \   00000E   FA           MOV     R2,A
   \   00000F   EF           MOV     A,R7
   \   000010   3400         ADDC    A,#0x0
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   ??ZDSecMgrDeviceCtrlUpdate?relay
   2607            }
   2608            else
   2609            {
   2610              // this should be done when receiving the NWK key
   2611              // if devState ==
   2612              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2613                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2614          
   2615              // if not in joining state -- this should trigger an event for an
   2616              // end point that requested SKKE
   2617              // if ( devState == DEV_END_DEVICE )
   2618             //       devState == DEV_ROUTER;
   2619          
   2620            }
   2621          }
   \   000016   7F01         MOV     R7,#0x1
   \   000018   02....       LJMP    ?BANKED_LEAVE_XDATA
   2622          
   2623          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2624          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2625          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2626            uint8  match;
   2627            uint8  lookup[Z_EXTADDR_LEN];
   2628          
   2629            match = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2630          
   2631            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000022   E9           MOV     A,R1
   \   000023   6014         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2632            {
   2633              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   000025                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   2634            }
   2635          
   2636            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   000039   A9..         MOV     R1,?V0 + 0
   \   00003B   7408         MOV     A,#0x8
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000040   7F01         MOV     R7,#0x1
   \   000042   02....       LJMP    ?BANKED_LEAVE_XDATA
   2637          }
   2638          
   2639          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2640          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2641          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2642            uint16 ami;
   2643            uint8* key;
   2644          
   2645            if ( !ZDSecMgrTCDataLoaded )
   \   00000E   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   000011   E0           MOVX    A,@DPTR
   \   000012   705F         JNZ     ??ZDSecMgrTCDataLoad_0
   2646            {
   2647              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000014                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   8582..       MOV     ?V0 + 0,DPL
   \   00001D   8583..       MOV     ?V0 + 1,DPH
   \   000020   78..         MOV     R0,#?V0 + 0
   \   000022   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   7A00         MOV     R2,#0x0
   \   00002B   7B00         MOV     R3,#0x0
   \   00002D   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?DEALLOC_XSTACK8
   \   000035   E9           MOV     A,R1
   \   000036   7035         JNZ     ??ZDSecMgrTCDataLoad_1
   2648              {
   2649                // if preconfigured load key
   2650                if ( zgPreConfigKeys == TRUE )
   \   000038   90....       MOV     DPTR,#zgPreConfigKeys
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   6401         XRL     A,#0x1
   \   00003E   702D         JNZ     ??ZDSecMgrTCDataLoad_1
   2651                {
   2652                  if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   \   000040                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000040   7402         MOV     A,#0x2
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   AC82         MOV     R4,DPL
   \   000047   AD83         MOV     R5,DPH
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   FA           MOV     R2,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   FB           MOV     R3,A
   \   000054   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000057   E9           MOV     A,R1
   \   000058   6013         JZ      ??ZDSecMgrTCDataLoad_1
   2653                  {
   2654                    ZDSecMgrMasterKeyStore( ami, ZDSecMgrTCMasterKey );
   \   00005A                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00005A   7C..         MOV     R4,#ZDSecMgrTCMasterKey & 0xff
   \   00005C   7D..         MOV     R5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00005E   85..82       MOV     DPL,?XSP + 0
   \   000061   85..83       MOV     DPH,?XSP + 1
   \   000064   E0           MOVX    A,@DPTR
   \   000065   FA           MOV     R2,A
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FB           MOV     R3,A
   \   000069   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   00006C   E9           MOV     A,R1
   2655                  }
   2656                }
   2657              }
   2658          
   2659              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??ZDSecMgrTCDataLoad_1:
   \   00006D   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   000070   7401         MOV     A,#0x1
   \   000072   F0           MOVX    @DPTR,A
   2660            }
   2661          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000073   7404         MOV     A,#0x4
   \   000075   12....       LCALL   ?DEALLOC_XSTACK8
   \   000078   7F02         MOV     R7,#0x2
   \   00007A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2662          
   2663          /******************************************************************************
   2664           * @fn          ZDSecMgrEstablishKeyInd
   2665           *
   2666           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2667           *
   2668           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2669           *
   2670           * @return      none
   2671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2672          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2673          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2674            ZDSecMgrDevice_t        device;
   2675            APSME_EstablishKeyRsp_t rsp;
   2676          
   2677          
   2678            // load Trust Center data if needed
   2679            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00000E   EE           MOV     A,R6
   \   00000F   2404         ADD     A,#0x4
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   FB           MOV     R3,A
   \   000016   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2680          
   2681            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   000019                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   000019   EE           MOV     A,R6
   \   00001A   2404         ADD     A,#0x4
   \   00001C   FA           MOV     R2,A
   \   00001D   EF           MOV     A,R7
   \   00001E   3400         ADDC    A,#0x0
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??ZDSecMgrTCExtAddrCheck?relay
   \   000024   E9           MOV     A,R1
   \   000025   6023         JZ      ??ZDSecMgrEstablishKeyInd_0
   2682            {
   2683              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2684              //OR
   2685              //!ZDSecMgrTCAuthenticated
   2686              //devtag.0604.critical
   2687                  //how is the parentAddr used here
   2688          
   2689              // initial SKKE from Trust Center via parent
   2690              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000027   7407         MOV     A,#0x7
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   7400         MOV     A,#0x0
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   7400         MOV     A,#0x0
   \   000032   F0           MOVX    @DPTR,A
   2691              device.parentAddr = ind->srcAddr;
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F8           MOV     R0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F9           MOV     R1,A
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   E8           MOV     A,R0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   E9           MOV     A,R1
   \   000047   F0           MOVX    @DPTR,A
   \   000048   8021         SJMP    ??ZDSecMgrEstablishKeyInd_1
   2692            }
   2693            else
   2694            {
   2695              // Trust Center direct or E2E SKKE
   2696              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   00004A   8E82         MOV     DPL,R6
   \   00004C   8F83         MOV     DPH,R7
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F9           MOV     R1,A
   \   000055   7407         MOV     A,#0x7
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E8           MOV     A,R0
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   E9           MOV     A,R1
   \   00005E   F0           MOVX    @DPTR,A
   2697              device.parentAddr = INVALID_NODE_ADDR;
   \   00005F   740B         MOV     A,#0xb
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   74FE         MOV     A,#-0x2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   F0           MOVX    @DPTR,A
   2698            }
   2699          
   2700            device.extAddr = ind->initExtAddr;
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   00006B   EE           MOV     A,R6
   \   00006C   2404         ADD     A,#0x4
   \   00006E   F8           MOV     R0,A
   \   00006F   EF           MOV     A,R7
   \   000070   3400         ADDC    A,#0x0
   \   000072   F9           MOV     R1,A
   \   000073   7409         MOV     A,#0x9
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   E8           MOV     A,R0
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   A3           INC     DPTR
   \   00007B   E9           MOV     A,R1
   \   00007C   F0           MOVX    @DPTR,A
   2701            //devtag.pro.security.0724.todo - verify usage
   2702            device.secure  = ind->nwkSecure;
   \   00007D   EE           MOV     A,R6
   \   00007E   240E         ADD     A,#0xe
   \   000080   F582         MOV     DPL,A
   \   000082   EF           MOV     A,R7
   \   000083   3400         ADDC    A,#0x0
   \   000085   F583         MOV     DPH,A
   \   000087   E0           MOVX    A,@DPTR
   \   000088   C0E0         PUSH    A
   \   00008A   740D         MOV     A,#0xd
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   D0E0         POP     A
   \   000091   F0           MOVX    @DPTR,A
   2703          
   2704            // validate device for SKKE
   2705            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000092                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000092   7407         MOV     A,#0x7
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   AA82         MOV     R2,DPL
   \   000099   AB83         MOV     R3,DPH
   \   00009B   12....       LCALL   ??ZDSecMgrDeviceValidateSKKE?relay
   \   00009E   E9           MOV     A,R1
   \   00009F   700A         JNZ     ??ZDSecMgrEstablishKeyInd_2
   2706            {
   2707              rsp.accept = TRUE;
   \   0000A1   7404         MOV     A,#0x4
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   7401         MOV     A,#0x1
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9   8008         SJMP    ??ZDSecMgrEstablishKeyInd_3
   2708            }
   2709            else
   2710            {
   2711              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   0000AB   7404         MOV     A,#0x4
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   7400         MOV     A,#0x0
   \   0000B2   F0           MOVX    @DPTR,A
   2712            }
   2713          
   2714            rsp.dstAddr     = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   0000B3   8E82         MOV     DPL,R6
   \   0000B5   8F83         MOV     DPH,R7
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   F8           MOV     R0,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   85..82       MOV     DPL,?XSP + 0
   \   0000C1   85..83       MOV     DPH,?XSP + 1
   \   0000C4   E8           MOV     A,R0
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E9           MOV     A,R1
   \   0000C8   F0           MOVX    @DPTR,A
   2715            rsp.initExtAddr = &ind->initExtAddr[0];
   \   0000C9   EE           MOV     A,R6
   \   0000CA   2404         ADD     A,#0x4
   \   0000CC   F8           MOV     R0,A
   \   0000CD   EF           MOV     A,R7
   \   0000CE   3400         ADDC    A,#0x0
   \   0000D0   F9           MOV     R1,A
   \   0000D1   7402         MOV     A,#0x2
   \   0000D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D6   E8           MOV     A,R0
   \   0000D7   F0           MOVX    @DPTR,A
   \   0000D8   A3           INC     DPTR
   \   0000D9   E9           MOV     A,R1
   \   0000DA   F0           MOVX    @DPTR,A
   2716            //devtag.0604.todo - remove obsolete
   2717            rsp.apsSecure   = ind->apsSecure;
   \   0000DB   EE           MOV     A,R6
   \   0000DC   240D         ADD     A,#0xd
   \   0000DE   F582         MOV     DPL,A
   \   0000E0   EF           MOV     A,R7
   \   0000E1   3400         ADDC    A,#0x0
   \   0000E3   F583         MOV     DPH,A
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   C0E0         PUSH    A
   \   0000E8   7405         MOV     A,#0x5
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   D0E0         POP     A
   \   0000EF   F0           MOVX    @DPTR,A
   2718            rsp.nwkSecure   = ind->nwkSecure;
   \   0000F0   EE           MOV     A,R6
   \   0000F1   240E         ADD     A,#0xe
   \   0000F3   F582         MOV     DPL,A
   \   0000F5   EF           MOV     A,R7
   \   0000F6   3400         ADDC    A,#0x0
   \   0000F8   F583         MOV     DPH,A
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   C0E0         PUSH    A
   \   0000FD   7406         MOV     A,#0x6
   \   0000FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000102   D0E0         POP     A
   \   000104   F0           MOVX    @DPTR,A
   2719          
   2720            APSME_EstablishKeyRsp( &rsp );
   \   000105                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000105   85..82       MOV     DPL,?XSP + 0
   \   000108   85..83       MOV     DPH,?XSP + 1
   \   00010B   AA82         MOV     R2,DPL
   \   00010D   AB83         MOV     R3,DPH
   \   00010F   12....       LCALL   ??APSME_EstablishKeyRsp?relay
   \   000112   E9           MOV     A,R1
   2721          }
   \   000113   7411         MOV     A,#0x11
   \   000115   12....       LCALL   ?DEALLOC_XSTACK8
   \   000118   7F01         MOV     R7,#0x1
   \   00011A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2722          //devtag.pro.security
   2723          #if 0
   2724          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2725          {
   2726            ZDSecMgrDevice_t        device;
   2727            APSME_EstablishKeyRsp_t rsp;
   2728          
   2729          
   2730            device.extAddr = ind->initExtAddr;
   2731            device.secure  = ind->secure;
   2732          
   2733            if ( ind->secure == FALSE )
   2734            {
   2735              // SKKE from Trust Center is not secured between child and parent
   2736              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2737              device.parentAddr = ind->srcAddr;
   2738            }
   2739            else
   2740            {
   2741              // SKKE from initiator should be secured
   2742              device.nwkAddr    = ind->srcAddr;
   2743              device.parentAddr = INVALID_NODE_ADDR;
   2744            }
   2745          
   2746            rsp.dstAddr     = ind->srcAddr;
   2747            rsp.initExtAddr = &ind->initExtAddr[0];
   2748            rsp.secure      = ind->secure;
   2749          
   2750            // validate device for SKKE
   2751            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2752            {
   2753              rsp.accept = TRUE;
   2754            }
   2755            else
   2756            {
   2757              rsp.accept = FALSE;
   2758            }
   2759          
   2760            APSME_EstablishKeyRsp( &rsp );
   2761          }
   2762          #endif
   2763          
   2764          /******************************************************************************
   2765           * @fn          ZDSecMgrTransportKeyInd
   2766           *
   2767           * @brief       Process the ZDO_TransportKeyInd_t message.
   2768           *
   2769           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2770           *
   2771           * @return      none
   2772           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2773          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2774          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2775            uint8 index;
   2776          
   2777            // load Trust Center data if needed
   2778            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   000009                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000009   EE           MOV     A,R6
   \   00000A   2416         ADD     A,#0x16
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   3400         ADDC    A,#0x0
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2779          
   2780            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000014   8E82         MOV     DPL,R6
   \   000016   8F83         MOV     DPH,R7
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   7003         JNZ     $+5
   \   00001F   02....       LJMP    ??ZDSecMgrTransportKeyInd_0 & 0xFFFF
   2781            {
   2782              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2783              //ZDSecMgrTCMasterKey( ind );
   2784              {
   2785                if ( zgPreConfigKeys != TRUE )
   2786                {
   2787                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2788                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2789                }
   2790                else
   2791                {
   2792                  // error condition - reject key
   2793                }
   2794              }
   2795            }
   2796            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2797                      ( ind->keyType == 6                 ) ||
   2798                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   6401         XRL     A,#0x1
   \   00002D   601A         JZ      ??ZDSecMgrTransportKeyInd_1
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6406         XRL     A,#0x6
   \   00003A   600D         JZ      ??ZDSecMgrTransportKeyInd_1
   \   00003C   8E82         MOV     DPL,R6
   \   00003E   8F83         MOV     DPH,R7
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6405         XRL     A,#0x5
   \   000047   7072         JNZ     ??ZDSecMgrTransportKeyInd_2
   2799            {
   2800              // check for dummy NWK key (all zeros)
   2801              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000049   75..00       MOV     ?V0 + 2,#0x0
   2802                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   00004C   E5..         MOV     A,?V0 + 2
   \   00004E   C3           CLR     C
   \   00004F   9410         SUBB    A,#0x10
   \   000051   501D         JNC     ??ZDSecMgrTransportKeyInd_4
   \   000053   85....       MOV     ?V0 + 0,?V0 + 2
   \   000056   75..00       MOV     ?V0 + 1,#0x0
   \   000059   EE           MOV     A,R6
   \   00005A   25..         ADD     A,?V0 + 0
   \   00005C   F582         MOV     DPL,A
   \   00005E   EF           MOV     A,R7
   \   00005F   35..         ADDC    A,?V0 + 1
   \   000061   F583         MOV     DPH,A
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   7004         JNZ     ??ZDSecMgrTransportKeyInd_4
   2803                    index++ );
   \   00006C   05..         INC     ?V0 + 2
   \   00006E   80DC         SJMP    ??ZDSecMgrTransportKeyInd_3
   2804          
   2805              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000070   7410         MOV     A,#0x10
   \   000072   65..         XRL     A,?V0 + 2
   \   000074   7016         JNZ     ??ZDSecMgrTransportKeyInd_5
   2806              {
   2807                // load preconfigured key - once!!
   2808                if ( !_NIB.nwkKeyLoaded )
   \   000076   90....       MOV     DPTR,#_NIB + 61
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   703A         JNZ     ??ZDSecMgrTransportKeyInd_6
   2809                {
   2810                  SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
   \   00007C                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   00007C   7900         MOV     R1,#0x0
   \   00007E   7A..         MOV     R2,#zgPreConfigKey & 0xff
   \   000080   7B..         MOV     R3,#(zgPreConfigKey >> 8) & 0xff
   \   000082   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2811                  SSP_SwitchNwkKey( 0 );
   \   000085                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000085   7900         MOV     R1,#0x0
   \   000087   12....       LCALL   ??SSP_SwitchNwkKey?relay
   \   00008A   802A         SJMP    ??ZDSecMgrTransportKeyInd_6
   2812                }
   2813              }
   2814              else
   2815              {
   2816                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   00008C                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   00008C   8E82         MOV     DPL,R6
   \   00008E   8F83         MOV     DPH,R7
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   E0           MOVX    A,@DPTR
   \   000096   F9           MOV     R1,A
   \   000097   EE           MOV     A,R6
   \   000098   2406         ADD     A,#0x6
   \   00009A   FA           MOV     R2,A
   \   00009B   EF           MOV     A,R7
   \   00009C   3400         ADDC    A,#0x0
   \   00009E   FB           MOV     R3,A
   \   00009F   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2817                if ( !_NIB.nwkKeyLoaded )
   \   0000A2   90....       MOV     DPTR,#_NIB + 61
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   700E         JNZ     ??ZDSecMgrTransportKeyInd_6
   2818                {
   2819                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000A8                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000A8   8E82         MOV     DPL,R6
   \   0000AA   8F83         MOV     DPH,R7
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   F9           MOV     R1,A
   \   0000B3   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2820                }
   2821              }
   2822          
   2823              // handle next step in authentication process
   2824              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   0000B6                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000B6   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay
   \   0000B9   8025         SJMP    ??ZDSecMgrTransportKeyInd_0
   2825            }
   2826            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   0000BB   8E82         MOV     DPL,R6
   \   0000BD   8F83         MOV     DPH,R7
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   E0           MOVX    A,@DPTR
   \   0000C4   6404         XRL     A,#0x4
   \   0000C6   6018         JZ      ??ZDSecMgrTransportKeyInd_0
   2827            {
   2828              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2829              {
   2830                //ZDSecMgrTCLinkKey( ind );
   2831              }
   2832            }
   2833            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   0000C8   8E82         MOV     DPL,R6
   \   0000CA   8F83         MOV     DPH,R7
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   6402         XRL     A,#0x2
   \   0000D3   600B         JZ      ??ZDSecMgrTransportKeyInd_0
   2834            {
   2835              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2836              {
   2837                uint16           ami;
   2838                AddrMgrEntry_t   entry;
   2839                ZDSecMgrEntry_t* entryZD;
   2840          
   2841                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2842          
   2843                if ( ind->initiator == TRUE )
   2844                {
   2845                  // get the ami data
   2846                  entry.user  = ADDRMGR_USER_SECURITY;
   2847                  entry.index = ami;
   2848                  AddrMgrEntryGet( &entry );
   2849          
   2850                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2851                  {
   2852                    APSME_EstablishKeyReq_t req;
   2853                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2854          
   2855                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2856          
   2857                    if ( entryZD == NULL )
   2858                    {
   2859                      // get new entry
   2860                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2861                      {
   2862                        // finish setting up entry
   2863                        entryZD->ami = ami;
   2864                      }
   2865                    }
   2866          
   2867                    req.respExtAddr = ind->srcExtAddr;
   2868                    req.method      = APSME_SKKE_METHOD;
   2869                    req.dstAddr     = entry.nwkAddr;
   2870                    //devtag.0604.todo - remove obsolete
   2871                    req.apsSecure   = FALSE;
   2872                    req.nwkSecure   = TRUE;
   2873                    APSME_EstablishKeyReq( &req );
   2874                  }
   2875                }
   2876                else
   2877                {
   2878                  if ( ami == INVALID_NODE_ADDR )
   2879                  {
   2880                    // store new EXT address
   2881                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2882                  }
   2883          
   2884                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2885                }
   2886          
   2887                //if ( entry.nwkAddr == INVALID_NODE_ADDR )
   2888                //{
   2889                //  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2890                //}
   2891              }
   2892            }
   2893            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   \   0000D5   8E82         MOV     DPL,R6
   \   0000D7   8F83         MOV     DPH,R7
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   E0           MOVX    A,@DPTR
   \   0000DE   6403         XRL     A,#0x3
   2894            {
   2895              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2896              {
   2897                uint16           ami;
   2898                ZDSecMgrEntry_t* entry;
   2899          
   2900                // get the address index
   2901                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2902                {
   2903                  // store new EXT address
   2904                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2905                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2906                }
   2907          
   2908                ZDSecMgrEntryLookupAMI( ami, &entry );
   2909          
   2910                if ( entry == NULL )
   2911                {
   2912                  // get new entry
   2913                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2914                  {
   2915                    // finish setting up entry
   2916                    entry->ami = ami;
   2917                  }
   2918                }
   2919          
   2920                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2921              }
   2922            }
   2923          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   0000E0   7F03         MOV     R7,#0x3
   \   0000E2   02....       LJMP    ?BANKED_LEAVE_XDATA
   2924          
   2925          /******************************************************************************
   2926           * @fn          ZDSecMgrUpdateDeviceInd
   2927           *
   2928           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2929           *
   2930           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2931           *
   2932           * @return      none
   2933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2934          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2935          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2936            ZDSecMgrDevice_t device;
   2937          
   2938          
   2939            device.nwkAddr    = ind->devAddr;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F583         MOV     DPH,A
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   E8           MOV     A,R0
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   E9           MOV     A,R1
   \   000027   F0           MOVX    @DPTR,A
   2940            device.extAddr    = ind->devExtAddr;
   \   000028   EE           MOV     A,R6
   \   000029   2404         ADD     A,#0x4
   \   00002B   F8           MOV     R0,A
   \   00002C   EF           MOV     A,R7
   \   00002D   3400         ADDC    A,#0x0
   \   00002F   F9           MOV     R1,A
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E8           MOV     A,R0
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   E9           MOV     A,R1
   \   000039   F0           MOVX    @DPTR,A
   2941            device.parentAddr = ind->srcAddr;
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F8           MOV     R0,A
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   7404         MOV     A,#0x4
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E8           MOV     A,R0
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   E9           MOV     A,R1
   \   00004E   F0           MOVX    @DPTR,A
   2942          
   2943            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2944            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2945            //{
   2946            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2947            //  {
   2948            //    device.secure = TRUE;
   2949            //  }
   2950            //  else
   2951            //  {
   2952            //    device.secure = FALSE;
   2953            //  }
   2954          
   2955              // try to join this device
   2956              ZDSecMgrDeviceJoin( &device );
   \   00004F                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   00004F   85..82       MOV     DPL,?XSP + 0
   \   000052   85..83       MOV     DPH,?XSP + 1
   \   000055   AA82         MOV     R2,DPL
   \   000057   AB83         MOV     R3,DPH
   \   000059   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   00005C   E9           MOV     A,R1
   2957            //}
   2958          }
   \   00005D   740A         MOV     A,#0xa
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   7F01         MOV     R7,#0x1
   \   000064   02....       LJMP    ?BANKED_LEAVE_XDATA
   2959          
   2960          /******************************************************************************
   2961           * @fn          ZDSecMgrRemoveDeviceInd
   2962           *
   2963           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2964           *
   2965           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2966           *
   2967           * @return      none
   2968           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2969          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2970          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2971            ZDSecMgrDevice_t device;
   2972          
   2973          
   2974            // only accept from Trust Center
   2975            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   E8           MOV     A,R0
   \   00001A   49           ORL     A,R1
   \   00001B   7046         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2976            {
   2977              // look up NWK address
   2978              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   00001D                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   AC82         MOV     R4,DPL
   \   000025   AD83         MOV     R5,DPH
   \   000027   EE           MOV     A,R6
   \   000028   2404         ADD     A,#0x4
   \   00002A   FA           MOV     R2,A
   \   00002B   EF           MOV     A,R7
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FB           MOV     R3,A
   \   00002F   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000032   E9           MOV     A,R1
   \   000033   6401         XRL     A,#0x1
   \   000035   702C         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   2979              {
   2980                device.parentAddr = NLME_GetShortAddr();
   \   000037                ; Setup parameters for call to function NLME_GetShortAddr
   \   000037   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   EA           MOV     A,R2
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   EB           MOV     A,R3
   \   000043   F0           MOVX    @DPTR,A
   2981                device.extAddr    = ind->childExtAddr;
   \   000044   EE           MOV     A,R6
   \   000045   2404         ADD     A,#0x4
   \   000047   F8           MOV     R0,A
   \   000048   EF           MOV     A,R7
   \   000049   3400         ADDC    A,#0x0
   \   00004B   F9           MOV     R1,A
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   E8           MOV     A,R0
   \   000052   F0           MOVX    @DPTR,A
   \   000053   A3           INC     DPTR
   \   000054   E9           MOV     A,R1
   \   000055   F0           MOVX    @DPTR,A
   2982          
   2983                // remove device
   2984                ZDSecMgrDeviceRemove( &device );
   \   000056                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   AA82         MOV     R2,DPL
   \   00005E   AB83         MOV     R3,DPH
   \   000060   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2985              }
   2986            }
   2987          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000063   740A         MOV     A,#0xa
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   7F01         MOV     R7,#0x1
   \   00006A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2988          
   2989          /******************************************************************************
   2990           * @fn          ZDSecMgrRequestKeyInd
   2991           *
   2992           * @brief       Process the ZDO_RequestKeyInd_t message.
   2993           *
   2994           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2995           *
   2996           * @return      none
   2997           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2998          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2999          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3000            if ( ind->keyType == KEY_TYPE_NWK )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   6401         XRL     A,#0x1
   \   000014   6014         JZ      ??ZDSecMgrRequestKeyInd_0
   3001            {
   3002            }
   3003            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6402         XRL     A,#0x2
   \   000021   7007         JNZ     ??ZDSecMgrRequestKeyInd_0
   3004            {
   3005              ZDSecMgrAppKeyReq( ind );
   \   000023                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000023   EE           MOV     A,R6
   \   000024   FA           MOV     R2,A
   \   000025   EF           MOV     A,R7
   \   000026   FB           MOV     R3,A
   \   000027   12....       LCALL   ??ZDSecMgrAppKeyReq?relay
   3006            }
   3007            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   3008            {
   3009            }
   3010            //else ignore
   3011          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00002A   7F01         MOV     R7,#0x1
   \   00002C   02....       LJMP    ?BANKED_LEAVE_XDATA
   3012          
   3013          /******************************************************************************
   3014           * @fn          ZDSecMgrSwitchKeyInd
   3015           *
   3016           * @brief       Process the ZDO_SwitchKeyInd_t message.
   3017           *
   3018           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   3019           *
   3020           * @return      none
   3021           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3022          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   3023          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3024            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000009                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   12....       LCALL   ??SSP_SwitchNwkKey?relay
   3025          
   3026            // Save if nv
   3027            ZDApp_NVUpdate();
   \   000016                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000016   12....       LCALL   ??ZDApp_NVUpdate?relay
   3028          }
   \   000019   7F01         MOV     R7,#0x1
   \   00001B   02....       LJMP    ?BANKED_LEAVE_XDATA
   3029          
   3030          /******************************************************************************
   3031           * @fn          ZDSecMgrAuthenticateInd
   3032           *
   3033           * @brief       Process the ZDO_AuthenticateInd_t message.
   3034           *
   3035           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   3036           *
   3037           * @return      none
   3038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3039          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3040          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3041            APSME_AuthenticateReq_t req;
   3042            AddrMgrEntry_t          entry;
   3043          
   3044          
   3045            // update the address manager
   3046            //---------------------------------------------------------------------------
   3047            // note:
   3048            // required for EA processing, but ultimately EA logic could also use the
   3049            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3050            // table is supposed to have authentication states for neighbors
   3051            //---------------------------------------------------------------------------
   3052            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
   3053            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   7408         MOV     A,#0x8
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E8           MOV     A,R0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   E9           MOV     A,R1
   \   00002A   F0           MOVX    @DPTR,A
   3054            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \   00002B                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00002B   EE           MOV     A,R6
   \   00002C   2404         ADD     A,#0x4
   \   00002E   FC           MOV     R4,A
   \   00002F   EF           MOV     A,R7
   \   000030   3400         ADDC    A,#0x0
   \   000032   FD           MOV     R5,A
   \   000033   740A         MOV     A,#0xa
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   AA82         MOV     R2,DPL
   \   00003A   AB83         MOV     R3,DPH
   \   00003C   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3055          
   3056            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00003F                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00003F   7407         MOV     A,#0x7
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   AA82         MOV     R2,DPL
   \   000046   AB83         MOV     R3,DPH
   \   000048   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00004B   E9           MOV     A,R1
   \   00004C   6401         XRL     A,#0x1
   \   00004E   7050         JNZ     ??ZDSecMgrAuthenticateInd_0
   3057            {
   3058              // set request fields
   3059              req.nwkAddr   = ind->aps.initNwkAddr;
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F8           MOV     R0,A
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   F9           MOV     R1,A
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   E8           MOV     A,R0
   \   000062   F0           MOVX    @DPTR,A
   \   000063   A3           INC     DPTR
   \   000064   E9           MOV     A,R1
   \   000065   F0           MOVX    @DPTR,A
   3060              req.extAddr   = ind->aps.initExtAddr;
   \   000066   EE           MOV     A,R6
   \   000067   2404         ADD     A,#0x4
   \   000069   F8           MOV     R0,A
   \   00006A   EF           MOV     A,R7
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F9           MOV     R1,A
   \   00006E   7402         MOV     A,#0x2
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   E8           MOV     A,R0
   \   000074   F0           MOVX    @DPTR,A
   \   000075   A3           INC     DPTR
   \   000076   E9           MOV     A,R1
   \   000077   F0           MOVX    @DPTR,A
   3061              req.action    = APSME_EA_ACCEPT;
   \   000078   7406         MOV     A,#0x6
   \   00007A   12....       LCALL   ?XSTACK_DISP0_8
   \   00007D   7401         MOV     A,#0x1
   \   00007F   F0           MOVX    @DPTR,A
   3062              req.challenge = ind->aps.challenge;
   \   000080   EE           MOV     A,R6
   \   000081   240C         ADD     A,#0xc
   \   000083   F8           MOV     R0,A
   \   000084   EF           MOV     A,R7
   \   000085   3400         ADDC    A,#0x0
   \   000087   F9           MOV     R1,A
   \   000088   7404         MOV     A,#0x4
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   E8           MOV     A,R0
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   A3           INC     DPTR
   \   000090   E9           MOV     A,R1
   \   000091   F0           MOVX    @DPTR,A
   3063          
   3064              // start EA processing
   3065              APSME_AuthenticateReq( &req );
   \   000092                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000092   85..82       MOV     DPL,?XSP + 0
   \   000095   85..83       MOV     DPH,?XSP + 1
   \   000098   AA82         MOV     R2,DPL
   \   00009A   AB83         MOV     R3,DPH
   \   00009C   12....       LCALL   ??APSME_AuthenticateReq?relay
   \   00009F   E9           MOV     A,R1
   3066            }
   3067          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   0000A0   7414         MOV     A,#0x14
   \   0000A2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A5   7F01         MOV     R7,#0x1
   \   0000A7   02....       LJMP    ?BANKED_LEAVE_XDATA
   3068          
   3069          /******************************************************************************
   3070           * @fn          ZDSecMgrAuthenticateCfm
   3071           *
   3072           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3073           *
   3074           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3075           *
   3076           * @return      none
   3077           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3078          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3079          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3080            if ( cfm->aps.status == ZSuccess )
   \   000009   EE           MOV     A,R6
   \   00000A   240B         ADD     A,#0xb
   \   00000C   F582         MOV     DPL,A
   \   00000E   EF           MOV     A,R7
   \   00000F   3400         ADDC    A,#0x0
   \   000011   F583         MOV     DPH,A
   \   000013   E0           MOVX    A,@DPTR
   \   000014   7020         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3081            {
   3082              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6401         XRL     A,#0x1
   \   00001F   7015         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   000021   90....       MOV     DPTR,#devState
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6405         XRL     A,#0x5
   \   000027   700D         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3083              {
   3084                // inform ZDO that device has been authenticated
   3085                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000029                ; Setup parameters for call to function osal_set_event
   \   000029   7A80         MOV     R2,#-0x80
   \   00002B   7B00         MOV     R3,#0x0
   \   00002D   90....       MOV     DPTR,#ZDAppTaskID
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   12....       LCALL   ??osal_set_event?relay
   \   000035   E9           MOV     A,R1
   3086              }
   3087            }
   3088          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   000036   7F01         MOV     R7,#0x1
   \   000038   02....       LJMP    ?BANKED_LEAVE_XDATA
   3089          
   3090          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3091          /******************************************************************************
   3092           * @fn          ZDSecMgrUpdateNwkKey
   3093           *
   3094           * @brief       Load a new NWK key and trigger a network wide update.
   3095           *
   3096           * @param       key       - [in] new NWK key
   3097           * @param       keySeqNum - [in] new NWK key sequence number
   3098           *
   3099           * @return      ZStatus_t
   3100           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3101          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrUpdateNwkKey:
   3102          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 2,R1
   \   000010   8C..         MOV     ?V0 + 0,R4
   \   000012   8D..         MOV     ?V0 + 1,R5
   3103            ZStatus_t               status;
   3104            APSME_TransportKeyReq_t req;
   3105          
   3106            // initialize common elements of local variables
   3107            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3108              req.keyType   = KEY_TYPE_NWK_HIGH;
   3109            else
   3110              req.keyType   = KEY_TYPE_NWK;
   \   000014   7402         MOV     A,#0x2
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   7401         MOV     A,#0x1
   \   00001B   F0           MOVX    @DPTR,A
   3111          
   3112            req.dstAddr   = dstAddr;
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   E5..         MOV     A,?V0 + 0
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   E5..         MOV     A,?V0 + 1
   \   000028   F0           MOVX    @DPTR,A
   3113            req.keySeqNum = keySeqNum;
   \   000029   E5..         MOV     A,?V0 + 2
   \   00002B   7403         MOV     A,#0x3
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E5..         MOV     A,?V0 + 2
   \   000032   F0           MOVX    @DPTR,A
   3114            req.key       = key;
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   EE           MOV     A,R6
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   EF           MOV     A,R7
   \   00003C   F0           MOVX    @DPTR,A
   3115            req.extAddr   = NULL;
   \   00003D   7406         MOV     A,#0x6
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   7400         MOV     A,#0x0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   7400         MOV     A,#0x0
   \   000048   F0           MOVX    @DPTR,A
   3116            req.nwkSecure = TRUE;
   \   000049   740A         MOV     A,#0xa
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   7401         MOV     A,#0x1
   \   000050   F0           MOVX    @DPTR,A
   3117            req.apsSecure = TRUE;
   \   000051   7409         MOV     A,#0x9
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   7401         MOV     A,#0x1
   \   000058   F0           MOVX    @DPTR,A
   3118            req.tunnel    = NULL;
   \   000059   740B         MOV     A,#0xb
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   7400         MOV     A,#0x0
   \   000060   F0           MOVX    @DPTR,A
   \   000061   A3           INC     DPTR
   \   000062   7400         MOV     A,#0x0
   \   000064   F0           MOVX    @DPTR,A
   3119          
   3120            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3121            {
   3122              ZDSecMgrEntry_t*        entry;
   3123              uint16                  index;
   3124              AddrMgrEntry_t          addrEntry;
   3125          
   3126              addrEntry.user = ADDRMGR_USER_SECURITY;
   3127          
   3128              status = ZFailure;
   3129          
   3130              // verify data is available
   3131              if ( ZDSecMgrEntries != NULL )
   3132              {
   3133                // find available entry
   3134                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3135                {
   3136                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3137                  {
   3138                    // return successful result
   3139                    entry = &ZDSecMgrEntries[index];
   3140          
   3141                    // get NWK address
   3142                    addrEntry.index = entry->ami;
   3143                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3144                    {
   3145                      req.dstAddr = addrEntry.nwkAddr;
   3146                      req.extAddr = addrEntry.extAddr;
   3147                      status = APSME_TransportKeyReq( &req );
   3148                    }
   3149                  }
   3150                }
   3151              }
   3152            }
   3153            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3154            {
   3155              status = APSME_TransportKeyReq( &req );
   \   000065                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   AA82         MOV     R2,DPL
   \   00006D   AB83         MOV     R3,DPH
   \   00006F   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   000072   E9           MOV     A,R1
   \   000073   F5..         MOV     ?V0 + 3,A
   3156            }
   3157          
   3158            SSP_UpdateNwkKey( key, keySeqNum );
   \   000075                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000075   A9..         MOV     R1,?V0 + 2
   \   000077   EE           MOV     A,R6
   \   000078   FA           MOV     R2,A
   \   000079   EF           MOV     A,R7
   \   00007A   FB           MOV     R3,A
   \   00007B   12....       LCALL   ??SSP_UpdateNwkKey?relay
   3159          
   3160            // Save if nv
   3161            ZDApp_NVUpdate();
   \   00007E                ; Setup parameters for call to function ZDApp_NVUpdate
   \   00007E   12....       LCALL   ??ZDApp_NVUpdate?relay
   3162          
   3163            return status;
   \   000081   A9..         MOV     R1,?V0 + 3
   \   000083   740D         MOV     A,#0xd
   \   000085   12....       LCALL   ?DEALLOC_XSTACK8
   \   000088   7F04         MOV     R7,#0x4
   \   00008A   02....       LJMP    ?BANKED_LEAVE_XDATA
   3164          }
   3165          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3166          
   3167          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3168          /******************************************************************************
   3169           * @fn          ZDSecMgrSwitchNwkKey
   3170           *
   3171           * @brief       Causes the NWK key to switch via a network wide command.
   3172           *
   3173           * @param       keySeqNum - [in] new NWK key sequence number
   3174           *
   3175           * @return      ZStatus_t
   3176           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3177          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrSwitchNwkKey:
   3178          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
   3179            ZStatus_t            status;
   3180            APSME_SwitchKeyReq_t req;
   3181          
   3182            // initialize common elements of local variables
   3183            req.dstAddr = dstAddr;
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   E5..         MOV     A,?V0 + 0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   E5..         MOV     A,?V0 + 1
   \   00001C   F0           MOVX    @DPTR,A
   3184            req.keySeqNum = keySeqNum;
   \   00001D   EF           MOV     A,R7
   \   00001E   C0E0         PUSH    A
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   D0E0         POP     A
   \   000027   F0           MOVX    @DPTR,A
   3185          
   3186            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3187            {
   3188              ZDSecMgrEntry_t*     entry;
   3189              uint16               index;
   3190              AddrMgrEntry_t       addrEntry;
   3191          
   3192              addrEntry.user = ADDRMGR_USER_SECURITY;
   3193          
   3194              status = ZFailure;
   3195          
   3196              // verify data is available
   3197              if ( ZDSecMgrEntries != NULL )
   3198              {
   3199                // find available entry
   3200                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3201                {
   3202                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3203                  {
   3204                    // return successful result
   3205                    entry = &ZDSecMgrEntries[index];
   3206          
   3207                    // get NWK address
   3208                    addrEntry.index = entry->ami;
   3209          
   3210                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3211                    {
   3212                      req.dstAddr = addrEntry.nwkAddr;
   3213                      status = APSME_SwitchKeyReq( &req );
   3214                    }
   3215                  }
   3216                }
   3217              }
   3218            }
   3219            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3220            {
   3221              status = APSME_SwitchKeyReq( &req );
   \   000028                ; Setup parameters for call to function APSME_SwitchKeyReq
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   AA82         MOV     R2,DPL
   \   000030   AB83         MOV     R3,DPH
   \   000032   12....       LCALL   ??APSME_SwitchKeyReq?relay
   \   000035   E9           MOV     A,R1
   \   000036   FE           MOV     R6,A
   3222            }
   3223          
   3224            SSP_SwitchNwkKey( keySeqNum );
   \   000037                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000037   EF           MOV     A,R7
   \   000038   F9           MOV     R1,A
   \   000039   12....       LCALL   ??SSP_SwitchNwkKey?relay
   3225          
   3226            // Save if nv
   3227            ZDApp_NVUpdate();
   \   00003C                ; Setup parameters for call to function ZDApp_NVUpdate
   \   00003C   12....       LCALL   ??ZDApp_NVUpdate?relay
   3228          
   3229            return status;
   \   00003F   EE           MOV     A,R6
   \   000040   F9           MOV     R1,A
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   7F02         MOV     R7,#0x2
   \   000048   02....       LJMP    ?BANKED_LEAVE_XDATA
   3230          }
   3231          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3232          
   3233          #if ( ZG_BUILD_JOINING_TYPE )
   3234          /******************************************************************************
   3235           * @fn          ZDSecMgrRequestAppKey
   3236           *
   3237           * @brief       Request an application key with partner.
   3238           *
   3239           * @param       partNwkAddr - [in] partner network address
   3240           *
   3241           * @return      ZStatus_t
   3242           */
   3243          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   3244          {
   3245            ZStatus_t             status;
   3246            APSME_RequestKeyReq_t req;
   3247            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3248          
   3249          
   3250            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   3251            {
   3252              req.dstAddr = 0;
   3253              req.keyType = KEY_TYPE_APP_MASTER;
   3254              req.partExtAddr = partExtAddr;
   3255              status = APSME_RequestKeyReq( &req );
   3256            }
   3257            else
   3258            {
   3259              status = ZFailure;
   3260            }
   3261          
   3262            return status;
   3263          }
   3264          #endif // ( ZG_BUILD_JOINING_TYPE )
   3265          
   3266          #if ( ZG_BUILD_JOINING_TYPE )
   3267          /******************************************************************************
   3268           * @fn          ZDSecMgrSetupPartner
   3269           *
   3270           * @brief       Setup for application key partner.
   3271           *
   3272           * @param       partNwkAddr - [in] partner network address
   3273           *
   3274           * @return      ZStatus_t
   3275           */
   3276          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   3277          {
   3278            AddrMgrEntry_t entry;
   3279            ZStatus_t      status;
   3280          
   3281            status = ZFailure;
   3282          
   3283            // update the address manager
   3284            entry.user    = ADDRMGR_USER_SECURITY;
   3285            entry.nwkAddr = partNwkAddr;
   3286            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   3287          
   3288            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   3289            {
   3290              status = ZSuccess;
   3291          
   3292              // check for address discovery
   3293              if ( partNwkAddr == INVALID_NODE_ADDR )
   3294              {
   3295                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   3296              }
   3297              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   3298              {
   3299                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   3300              }
   3301            }
   3302          
   3303            return status;
   3304          }
   3305          #endif // ( ZG_BUILD_JOINING_TYPE )
   3306          
   3307          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3308          /******************************************************************************
   3309           * @fn          ZDSecMgrAppKeyTypeSet
   3310           *
   3311           * @brief       Set application key type.
   3312           *
   3313           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3314           *                                                   KEY_TYPE_APP_LINK@3
   3315           *
   3316           * @return      ZStatus_t
   3317           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3318          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   \                     ZDSecMgrAppKeyTypeSet:
   3319          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   3320            if ( keyType == KEY_TYPE_APP_LINK )
   \   000006   7403         MOV     A,#0x3
   \   000008   68           XRL     A,R0
   \   000009   7008         JNZ     ??ZDSecMgrAppKeyTypeSet_0
   3321            {
   3322              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   \   00000B   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   00000E   7403         MOV     A,#0x3
   \   000010   F0           MOVX    @DPTR,A
   \   000011   8006         SJMP    ??ZDSecMgrAppKeyTypeSet_1
   3323            }
   3324            else
   3325            {
   3326              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   \                     ??ZDSecMgrAppKeyTypeSet_0:
   \   000013   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000016   7402         MOV     A,#0x2
   \   000018   F0           MOVX    @DPTR,A
   3327            }
   3328          
   3329            return ZSuccess;
   \                     ??ZDSecMgrAppKeyTypeSet_1:
   \   000019   7900         MOV     R1,#0x0
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   02....       LJMP    ?BRET
   3330          }
   3331          #endif
   3332          
   3333          /******************************************************************************
   3334           * ZigBee Device Security Manager - Stub Implementations
   3335           */
   3336          /******************************************************************************
   3337           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3338           *
   3339           * @brief       Get MASTER key for specified EXT address.
   3340           *
   3341           * @param       extAddr - [in] EXT address
   3342           * @param       key     - [out] MASTER key
   3343           *
   3344           * @return      ZStatus_t
   3345           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3346          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint8** key )
   \                     APSME_MasterKeyGet:
   3347          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3348            ZStatus_t status;
   3349            uint16    ami;
   3350          
   3351          
   3352            // lookup entry for specified EXT address
   3353            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   000012                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   AA..         MOV     R2,?V0 + 0
   \   00001E   AB..         MOV     R3,?V0 + 1
   \   000020   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000023   E9           MOV     A,R1
   \   000024   F5..         MOV     ?V0 + 2,A
   3354            //status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3355          
   3356            if ( status == ZSuccess )
   \   000026   E5..         MOV     A,?V0 + 2
   \   000028   7015         JNZ     ??APSME_MasterKeyGet_0
   3357            {
   3358              ZDSecMgrMasterKeyLookup( ami, key );
   \   00002A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00002A   EE           MOV     A,R6
   \   00002B   FC           MOV     R4,A
   \   00002C   EF           MOV     A,R7
   \   00002D   FD           MOV     R5,A
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   E0           MOVX    A,@DPTR
   \   000035   FA           MOV     R2,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   00003C   E9           MOV     A,R1
   \   00003D   800B         SJMP    ??APSME_MasterKeyGet_1
   3359            }
   3360            else
   3361            {
   3362              *key = NULL;
   \                     ??APSME_MasterKeyGet_0:
   \   00003F   8E82         MOV     DPL,R6
   \   000041   8F83         MOV     DPH,R7
   \   000043   7400         MOV     A,#0x0
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   7400         MOV     A,#0x0
   \   000049   F0           MOVX    @DPTR,A
   3363            }
   3364          
   3365            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   00004A   A9..         MOV     R1,?V0 + 2
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000051   7F03         MOV     R7,#0x3
   \   000053   02....       LJMP    ?BANKED_LEAVE_XDATA
   3366          }
   3367          
   3368          /******************************************************************************
   3369           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3370           *
   3371           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3372           *
   3373           * @param       extAddr - [in] EXT address
   3374           * @param       data    - [in] APSME_LinkKeyData_t
   3375           *
   3376           * @return      ZStatus_t
   3377           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3378          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3379          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3380            ZStatus_t        status;
   3381            ZDSecMgrEntry_t* entry;
   3382          
   3383          
   3384            // lookup entry index for specified EXT address
   3385            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000012                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   AA..         MOV     R2,?V0 + 2
   \   00001E   AB..         MOV     R3,?V0 + 3
   \   000020   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000023   E9           MOV     A,R1
   \   000024   F5..         MOV     ?V0 + 0,A
   3386          
   3387            if ( status == ZSuccess )
   \   000026   E5..         MOV     A,?V0 + 0
   \   000028   7074         JNZ     ??APSME_LinkKeySet_0
   3388            {
   3389              // setup the link key data reference
   3390              osal_memcpy( entry->lkd.key, key, SEC_KEY_LEN );
   \   00002A                ; Setup parameters for call to function osal_memcpy
   \   00002A   8E..         MOV     ?V0 + 4,R6
   \   00002C   8F..         MOV     ?V0 + 5,R7
   \   00002E   75..00       MOV     ?V0 + 6,#0x0
   \   000031   78..         MOV     R0,#?V0 + 4
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000036   7C10         MOV     R4,#0x10
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   7403         MOV     A,#0x3
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   2402         ADD     A,#0x2
   \   000042   FA           MOV     R2,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   3400         ADDC    A,#0x0
   \   000047   FB           MOV     R3,A
   \   000048   12....       LCALL   ??osal_memcpy?relay
   \   00004B   7403         MOV     A,#0x3
   \   00004D   12....       LCALL   ?DEALLOC_XSTACK8
   3391          
   3392              entry->lkd.apsmelkd.rxFrmCntr = 0;
   \   000050   7A00         MOV     R2,#0x0
   \   000052   7B00         MOV     R3,#0x0
   \   000054   7C00         MOV     R4,#0x0
   \   000056   7D00         MOV     R5,#0x0
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F8           MOV     R0,A
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   C8           XCH     A,R0
   \   000063   2418         ADD     A,#0x18
   \   000065   F582         MOV     DPL,A
   \   000067   E8           MOV     A,R0
   \   000068   3400         ADDC    A,#0x0
   \   00006A   F583         MOV     DPH,A
   \   00006C   EA           MOV     A,R2
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   A3           INC     DPTR
   \   00006F   EB           MOV     A,R3
   \   000070   F0           MOVX    @DPTR,A
   \   000071   A3           INC     DPTR
   \   000072   EC           MOV     A,R4
   \   000073   F0           MOVX    @DPTR,A
   \   000074   A3           INC     DPTR
   \   000075   ED           MOV     A,R5
   \   000076   F0           MOVX    @DPTR,A
   3393              entry->lkd.apsmelkd.txFrmCntr = 0;
   \   000077   7A00         MOV     R2,#0x0
   \   000079   7B00         MOV     R3,#0x0
   \   00007B   7C00         MOV     R4,#0x0
   \   00007D   7D00         MOV     R5,#0x0
   \   00007F   85..82       MOV     DPL,?XSP + 0
   \   000082   85..83       MOV     DPH,?XSP + 1
   \   000085   E0           MOVX    A,@DPTR
   \   000086   F8           MOV     R0,A
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   C8           XCH     A,R0
   \   00008A   2414         ADD     A,#0x14
   \   00008C   F582         MOV     DPL,A
   \   00008E   E8           MOV     A,R0
   \   00008F   3400         ADDC    A,#0x0
   \   000091   F583         MOV     DPH,A
   \   000093   EA           MOV     A,R2
   \   000094   F0           MOVX    @DPTR,A
   \   000095   A3           INC     DPTR
   \   000096   EB           MOV     A,R3
   \   000097   F0           MOVX    @DPTR,A
   \   000098   A3           INC     DPTR
   \   000099   EC           MOV     A,R4
   \   00009A   F0           MOVX    @DPTR,A
   \   00009B   A3           INC     DPTR
   \   00009C   ED           MOV     A,R5
   \   00009D   F0           MOVX    @DPTR,A
   3394            }
   3395          
   3396            return status;
   \                     ??APSME_LinkKeySet_0:
   \   00009E   A9..         MOV     R1,?V0 + 0
   \   0000A0   7402         MOV     A,#0x2
   \   0000A2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A5   7F07         MOV     R7,#0x7
   \   0000A7   02....       LJMP    ?BANKED_LEAVE_XDATA
   3397          }
   3398          
   3399          /******************************************************************************
   3400           * @fn          ZDSecMgrAuthenticationSet
   3401           *
   3402           * @brief       Mark the specific device as authenticated or not
   3403           *
   3404           * @param       extAddr - [in] EXT address
   3405           * @param       option  - [in] authenticated or not
   3406           *
   3407           * @return      ZStatus_t
   3408           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3409          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3410          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 1,R1
   3411            ZStatus_t        status;
   3412            ZDSecMgrEntry_t* entry;
   3413          
   3414          
   3415            // lookup entry index for specified EXT address
   3416            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000010                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AC82         MOV     R4,DPL
   \   000018   AD83         MOV     R5,DPH
   \   00001A   EE           MOV     A,R6
   \   00001B   FA           MOV     R2,A
   \   00001C   EF           MOV     A,R7
   \   00001D   FB           MOV     R3,A
   \   00001E   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000021   E9           MOV     A,R1
   \   000022   F5..         MOV     ?V0 + 0,A
   3417          
   3418            if ( status == ZSuccess )
   \   000024   E5..         MOV     A,?V0 + 0
   \   000026   7019         JNZ     ??ZDSecMgrAuthenticationSet_0
   3419            {
   3420              entry->authenticateOption = option;
   \   000028   E5..         MOV     A,?V0 + 1
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F8           MOV     R0,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   C8           XCH     A,R0
   \   000035   241C         ADD     A,#0x1c
   \   000037   F582         MOV     DPL,A
   \   000039   E8           MOV     A,R0
   \   00003A   3400         ADDC    A,#0x0
   \   00003C   F583         MOV     DPH,A
   \   00003E   E5..         MOV     A,?V0 + 1
   \   000040   F0           MOVX    @DPTR,A
   3421            }
   3422          
   3423            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000041   A9..         MOV     R1,?V0 + 0
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   7F02         MOV     R7,#0x2
   \   00004A   02....       LJMP    ?BANKED_LEAVE_XDATA
   3424          }
   3425          
   3426          /******************************************************************************
   3427           * @fn          ZDSecMgrAuthenticationCheck
   3428           *
   3429           * @brief       Check if the specific device has been authenticated or not
   3430           *              For non-trust center device, always return true
   3431           *
   3432           * @param       shortAddr - [in] short address
   3433           *
   3434           * @return      TRUE @ authenticated with CBKE
   3435           *              FALSE @ not authenticated
   3436           */
   3437          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3438          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3439          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3440          #if defined (TC_LINKKEY_JOIN)
   3441          
   3442            ZDSecMgrEntry_t* entry;
   3443            uint8 extAddr[Z_EXTADDR_LEN];
   3444          
   3445            // If the local device is not the trust center, always return TRUE
   3446            if ( NLME_GetShortAddr() != TCshortAddr )
   3447            {
   3448              return TRUE;
   3449            }
   3450            // Otherwise, check the authentication option
   3451            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3452            {
   3453              // lookup entry index for specified EXT address
   3454              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3455              {
   3456                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3457                {
   3458                  return TRUE;
   3459                }
   3460                else
   3461                {
   3462                  return FALSE;
   3463                }
   3464              }
   3465            }
   3466            return FALSE;
   3467          
   3468          #else
   3469            (void)shortAddr;  // Intentionally unreferenced parameter
   3470            
   3471            // For non AMI/SE Profile, perform no check and always return true.
   3472            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3473          
   3474          #endif // TC_LINKKEY_JOIN
   3475          }
   3476          
   3477          
   3478          /******************************************************************************
   3479           * @fn          ZDSecMgrLinkKeyDataGet (stubs APSME_LinkKeyDataGet)
   3480           *
   3481           * @brief       Get <APSME_LinkKeyData_t> for specified NWK address.
   3482           *
   3483           * @param       extAddr - [in] EXT address
   3484           * @param       data    - [out] APSME_LinkKeyData_t
   3485           *
   3486           * @return      ZStatus_t
   3487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3488          ZStatus_t ZDSecMgrLinkKeyDataGet(uint8* extAddr, APSME_LinkKeyData_t** data)
   \                     APSME_LinkKeyDataGet:
   3489          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   3490            ZStatus_t        status;
   3491            ZDSecMgrEntry_t* entry;
   3492          
   3493          
   3494            // lookup entry index for specified NWK address
   3495            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000012                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000023   E9           MOV     A,R1
   \   000024   F5..         MOV     ?V0 + 2,A
   3496          
   3497            if ( status == ZSuccess )
   \   000026   E5..         MOV     A,?V0 + 2
   \   000028   703E         JNZ     ??APSME_LinkKeyDataGet_0
   3498            {
   3499              // setup the link key data reference
   3500              (*data) = &entry->lkd.apsmelkd;
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   2412         ADD     A,#0x12
   \   000033   F8           MOV     R0,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   3400         ADDC    A,#0x0
   \   000038   F9           MOV     R1,A
   \   000039   85..82       MOV     DPL,?V0 + 0
   \   00003C   85..83       MOV     DPH,?V0 + 1
   \   00003F   E8           MOV     A,R0
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   E9           MOV     A,R1
   \   000043   F0           MOVX    @DPTR,A
   3501              (*data)->key = entry->lkd.key;
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   2402         ADD     A,#0x2
   \   00004D   F8           MOV     R0,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   3400         ADDC    A,#0x0
   \   000052   F9           MOV     R1,A
   \   000053   85..82       MOV     DPL,?V0 + 0
   \   000056   85..83       MOV     DPH,?V0 + 1
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   FA           MOV     R2,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F583         MOV     DPH,A
   \   00005F   8A82         MOV     DPL,R2
   \   000061   E8           MOV     A,R0
   \   000062   F0           MOVX    @DPTR,A
   \   000063   A3           INC     DPTR
   \   000064   E9           MOV     A,R1
   \   000065   F0           MOVX    @DPTR,A
   \   000066   800D         SJMP    ??APSME_LinkKeyDataGet_1
   3502            }
   3503            else
   3504            {
   3505              *data = NULL;
   \                     ??APSME_LinkKeyDataGet_0:
   \   000068   85..82       MOV     DPL,?V0 + 0
   \   00006B   85..83       MOV     DPH,?V0 + 1
   \   00006E   7400         MOV     A,#0x0
   \   000070   F0           MOVX    @DPTR,A
   \   000071   A3           INC     DPTR
   \   000072   7400         MOV     A,#0x0
   \   000074   F0           MOVX    @DPTR,A
   3506            }
   3507          
   3508            return status;
   \                     ??APSME_LinkKeyDataGet_1:
   \   000075   A9..         MOV     R1,?V0 + 2
   \   000077   7402         MOV     A,#0x2
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007C   7F03         MOV     R7,#0x3
   \   00007E   02....       LJMP    ?BANKED_LEAVE_XDATA
   3509          }
   3510          
   3511          /******************************************************************************
   3512           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3513           *
   3514           * @brief       Verify and process key transportation to child.
   3515           *
   3516           * @param       ind - [in] APSME_TransportKeyInd_t
   3517           *
   3518           * @return      uint8 - success(TRUE:FALSE)
   3519           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3520          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3521          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3522            uint8 success;
   3523          
   3524            success = FALSE;
   \   000009   75..00       MOV     ?V0 + 0,#0x0
   3525          
   3526            // verify from Trust Center
   3527            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000C   8E82         MOV     DPL,R6
   \   00000E   8F83         MOV     DPH,R7
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F8           MOV     R0,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   49           ORL     A,R1
   \   000017   7039         JNZ     ??APSME_KeyFwdToChild_0
   3528            {
   3529              success = TRUE;
   \   000019   75..01       MOV     ?V0 + 0,#0x1
   3530          
   3531              // check for initial NWK key
   3532              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3533                   ( ind->keyType == 6                 ) ||
   3534                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6401         XRL     A,#0x1
   \   000025   6016         JZ      ??APSME_KeyFwdToChild_1
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6406         XRL     A,#0x6
   \   000030   600B         JZ      ??APSME_KeyFwdToChild_1
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   6405         XRL     A,#0x5
   \   00003B   7015         JNZ     ??APSME_KeyFwdToChild_0
   3535              {
   3536                // set association status to authenticated
   3537                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   00003D                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00003D                ; Setup parameters for call to function AssocGetWithExt
   \   00003D   8E82         MOV     DPL,R6
   \   00003F   8F83         MOV     DPH,R7
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   FA           MOV     R2,A
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   FB           MOV     R3,A
   \   00004C   12....       LCALL   ??AssocGetWithExt?relay
   \   00004F   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   3538              }
   3539            }
   3540          
   3541            return success;
   \                     ??APSME_KeyFwdToChild_0:
   \   000052   A9..         MOV     R1,?V0 + 0
   \   000054   7F01         MOV     R7,#0x1
   \   000056   02....       LJMP    ?BANKED_LEAVE_XDATA
   3542          }
   3543          
   3544          /******************************************************************************
   3545           * @fn          ZDSecMgrAddLinkKey
   3546           *
   3547           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3548           *              as authenticated in the authenticateOption. Note that this function
   3549           *              is hardwared to CBKE right now.
   3550           *
   3551           * @param       shortAddr - short address of the partner device
   3552           * @param       extAddr - extended address of the partner device
   3553           * @param       key - link key
   3554           *
   3555           * @return      ZStatus_t
   3556           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3557          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3558          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   7412         MOV     A,#0x12
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
   3559            uint16           ami;
   3560            ZDSecMgrEntry_t* entry;
   3561          
   3562            /* Store the device address in the addr manager */
   3563            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00001E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   8582..       MOV     ?V0 + 4,DPL
   \   000026   8583..       MOV     ?V0 + 5,DPH
   \   000029   78..         MOV     R0,#?V0 + 4
   \   00002B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002E   EE           MOV     A,R6
   \   00002F   FC           MOV     R4,A
   \   000030   EF           MOV     A,R7
   \   000031   FD           MOV     R5,A
   \   000032   AA..         MOV     R2,?V0 + 2
   \   000034   AB..         MOV     R3,?V0 + 3
   \   000036   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000039   7402         MOV     A,#0x2
   \   00003B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003E   E9           MOV     A,R1
   \   00003F   6004         JZ      ??ZDSecMgrAddLinkKey_0
   3564            {
   3565              /* Adding to Addr Manager fails */
   3566              return ZFailure;
   \   000041   7901         MOV     R1,#0x1
   \   000043   8068         SJMP    ??ZDSecMgrAddLinkKey_1
   3567            }
   3568          
   3569            /* Lookup entry using specified address index */
   3570            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000045                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   AC82         MOV     R4,DPL
   \   00004D   AD83         MOV     R5,DPH
   \   00004F   7402         MOV     A,#0x2
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FA           MOV     R2,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FB           MOV     R3,A
   \   000059   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   00005C   E9           MOV     A,R1
   3571          
   3572            // If no existing entry, create one
   3573            if ( entry == NULL )
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F8           MOV     R0,A
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   F9           MOV     R1,A
   \   000068   E8           MOV     A,R0
   \   000069   49           ORL     A,R1
   \   00006A   7033         JNZ     ??ZDSecMgrAddLinkKey_2
   3574            {
   3575              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00006C                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00006C   85..82       MOV     DPL,?XSP + 0
   \   00006F   85..83       MOV     DPH,?XSP + 1
   \   000072   AA82         MOV     R2,DPL
   \   000074   AB83         MOV     R3,DPH
   \   000076   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000079   E9           MOV     A,R1
   \   00007A   701F         JNZ     ??ZDSecMgrAddLinkKey_3
   3576              {
   3577                entry->ami = ami;
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E0           MOVX    A,@DPTR
   \   000082   FA           MOV     R2,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   FB           MOV     R3,A
   \   000086   85..82       MOV     DPL,?XSP + 0
   \   000089   85..83       MOV     DPH,?XSP + 1
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F8           MOV     R0,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F583         MOV     DPH,A
   \   000092   8882         MOV     DPL,R0
   \   000094   EA           MOV     A,R2
   \   000095   F0           MOVX    @DPTR,A
   \   000096   A3           INC     DPTR
   \   000097   EB           MOV     A,R3
   \   000098   F0           MOVX    @DPTR,A
   \   000099   8004         SJMP    ??ZDSecMgrAddLinkKey_2
   3578              }
   3579              else
   3580              {
   3581                /* Security Manager full */
   3582                return ZBufferFull;
   \                     ??ZDSecMgrAddLinkKey_3:
   \   00009B   7911         MOV     R1,#0x11
   \   00009D   800E         SJMP    ??ZDSecMgrAddLinkKey_1
   3583              }
   3584            }
   3585            // Write the link key
   3586            APSME_LinkKeySet( extAddr, key );
   \                     ??ZDSecMgrAddLinkKey_2:
   \   00009F                ; Setup parameters for call to function APSME_LinkKeySet
   \   00009F   AC..         MOV     R4,?V0 + 0
   \   0000A1   AD..         MOV     R5,?V0 + 1
   \   0000A3   EE           MOV     A,R6
   \   0000A4   FA           MOV     R2,A
   \   0000A5   EF           MOV     A,R7
   \   0000A6   FB           MOV     R3,A
   \   0000A7   12....       LCALL   ??APSME_LinkKeySet?relay
   \   0000AA   E9           MOV     A,R1
   3587          
   3588          #if defined (TC_LINKKEY_JOIN)
   3589            // Mark the device as authenticated.
   3590            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3591          #endif
   3592          
   3593          #if defined NV_RESTORE
   3594            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3595          #endif
   3596            
   3597            return ZSuccess;
   \   0000AB   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   0000AD   7404         MOV     A,#0x4
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B2   7F06         MOV     R7,#0x6
   \   0000B4   02....       LJMP    ?BANKED_LEAVE_XDATA
   3598          }
   3599          
   3600          #if defined ( NV_RESTORE )
   3601          /******************************************************************************
   3602           * @fn          ZDSecMgrInitNV
   3603           *
   3604           * @brief       Initialize the SecMgr entry data in NV.
   3605           *
   3606           * @param       none
   3607           *
   3608           * @return      uint8 - <osal_nv_item_init> return codes
   3609           */
   3610          uint8 ZDSecMgrInitNV(void)
   3611          {
   3612            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE, 
   3613                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3614            if (rtrn != ZSUCCESS)  // If the item does not already exist.
   3615            {
   3616              nvDeviceListHdr_t hdr;
   3617              hdr.numRecs = 0;
   3618              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3619            }
   3620          
   3621            return rtrn;
   3622          }
   3623          #endif // NV_RESTORE
   3624          
   3625          #if defined ( NV_RESTORE )
   3626          /*********************************************************************
   3627           * @fn      ZDSecMgrWriteNV()
   3628           *
   3629           * @brief   Save off the link key list to NV
   3630           *
   3631           * @param   none
   3632           *
   3633           * @return  none
   3634           */
   3635          static void ZDSecMgrWriteNV( void )
   3636          {
   3637            uint16 i;
   3638            nvDeviceListHdr_t hdr;
   3639          
   3640            hdr.numRecs = 0;
   3641          
   3642            if (ZDSecMgrEntries != NULL)
   3643            {
   3644              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3645              {
   3646                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3647                {
   3648                  // Save off the record
   3649                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3650                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3651                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3652                  hdr.numRecs++;
   3653                }
   3654              }
   3655            }
   3656          
   3657            // Save off the header
   3658            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3659          }
   3660          #endif // NV_RESTORE
   3661          
   3662          #if defined ( NV_RESTORE )
   3663          /******************************************************************************
   3664           * @fn          ZDSecMgrRestoreFromNV
   3665           *
   3666           * @brief       Restore the SecMgr entry data from NV.
   3667           *
   3668           * @param       none
   3669           *
   3670           * @return      None.
   3671           */
   3672          static void ZDSecMgrRestoreFromNV( void )
   3673          {
   3674            nvDeviceListHdr_t hdr;
   3675          
   3676            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3677                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3678            {
   3679              uint8 x;
   3680          
   3681              for (x = 0; x < hdr.numRecs; x++)
   3682              {
   3683                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3684                          (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3685                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == ZSUCCESS )
   3686                {
   3687                  ZDSecMgrEntries[x].lkd.apsmelkd.txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3688                }
   3689              }
   3690            }
   3691          }
   3692          #endif // NV_RESTORE
   3693          
   3694          /******************************************************************************
   3695           * @fn          ZDSecMgrAPSRemove
   3696           *
   3697           * @brief       Remove device from network.
   3698           *
   3699           * @param       nwkAddr - device's NWK address
   3700           * @param       extAddr - device's Extended address
   3701           * @param       parentAddr - parent's NWK address
   3702           *
   3703           * @return      ZStatus_t
   3704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3705          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3706          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   7416         MOV     A,#0x16
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 3,A
   3707            ZDSecMgrDevice_t device;
   3708          
   3709            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3710                 ( extAddr == NULL )              ||
   3711                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   00001E   74FE         MOV     A,#-0x2
   \   000020   65..         XRL     A,?V0 + 0
   \   000022   7004         JNZ     ??ZDSecMgrAPSRemove_0
   \   000024   74FF         MOV     A,#-0x1
   \   000026   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrAPSRemove_0:
   \   000028   6010         JZ      ??ZDSecMgrAPSRemove_1
   \   00002A   EE           MOV     A,R6
   \   00002B   4F           ORL     A,R7
   \   00002C   600C         JZ      ??ZDSecMgrAPSRemove_1
   \   00002E   74FE         MOV     A,#-0x2
   \   000030   65..         XRL     A,?V0 + 2
   \   000032   7004         JNZ     ??ZDSecMgrAPSRemove_2
   \   000034   74FF         MOV     A,#-0x1
   \   000036   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrAPSRemove_2:
   \   000038   7004         JNZ     ??ZDSecMgrAPSRemove_3
   3712            {
   3713              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   00003A   7901         MOV     R1,#0x1
   \   00003C   8032         SJMP    ??ZDSecMgrAPSRemove_4
   3714            }
   3715          
   3716            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   E5..         MOV     A,?V0 + 0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E5..         MOV     A,?V0 + 1
   \   00004A   F0           MOVX    @DPTR,A
   3717            device.extAddr = extAddr;
   \   00004B   7402         MOV     A,#0x2
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   EE           MOV     A,R6
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A3           INC     DPTR
   \   000053   EF           MOV     A,R7
   \   000054   F0           MOVX    @DPTR,A
   3718            device.parentAddr = parentAddr;
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E5..         MOV     A,?V0 + 2
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   E5..         MOV     A,?V0 + 3
   \   000060   F0           MOVX    @DPTR,A
   3719          
   3720            // remove device
   3721            ZDSecMgrDeviceRemove( &device );
   \   000061                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   AA82         MOV     R2,DPL
   \   000069   AB83         MOV     R3,DPH
   \   00006B   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   3722          
   3723            return ( ZSuccess );
   \   00006E   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000070   740A         MOV     A,#0xa
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
   \   000075   7F04         MOV     R7,#0x4
   \   000077   02....       LJMP    ?BANKED_LEAVE_XDATA
   3724          }
   3725          
   3726          /******************************************************************************
   3727           * @fn          APSME_TCLinkKeyInit
   3728           *
   3729           * @brief       Initialize the NV table for preconfigured TC link key
   3730           *               
   3731           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3732           *              Trust Center Link Key is written to NV. A single tclk is used   
   3733           *              by all devices joining the network.
   3734           *              
   3735           * @param       none
   3736           *
   3737           * @return      none
   3738           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3739          void APSME_TCLinkKeyInit(void)
   \                     APSME_TCLinkKeyInit:
   3740          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3741            uint8             i;
   3742            APSME_TCLinkKey_t tcLinkKey;
   3743            
   3744            // Initialize all NV items for preconfigured tclk with 
   3745            // extended address all zero, if not exist already.
   3746            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C20         MOV     R4,#0x20
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   12....       LCALL   ??osal_memset?relay
   3747            for( i = 1; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00001D   7E01         MOV     R6,#0x1
   \                     ??APSME_TCLinkKeyInit_0:
   \   00001F   EE           MOV     A,R6
   \   000020   C3           CLR     C
   \   000021   9401         SUBB    A,#0x1
   \   000023   5030         JNC     ??APSME_TCLinkKeyInit_1
   3748            {
   3749              osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i), 
   3750                                 sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   \   000025                ; Setup parameters for call to function osal_nv_item_init
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   8582..       MOV     ?V0 + 0,DPL
   \   00002E   8583..       MOV     ?V0 + 1,DPH
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   7C20         MOV     R4,#0x20
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   8E..         MOV     ?V0 + 0,R6
   \   00003C   75..00       MOV     ?V0 + 1,#0x0
   \   00003F   E5..         MOV     A,?V0 + 0
   \   000041   2401         ADD     A,#0x1
   \   000043   FA           MOV     R2,A
   \   000044   E5..         MOV     A,?V0 + 1
   \   000046   3401         ADDC    A,#0x1
   \   000048   FB           MOV     R3,A
   \   000049   12....       LCALL   ??osal_nv_item_init?relay
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000051   E9           MOV     A,R1
   3751            }
   \   000052   0E           INC     R6
   \   000053   80CA         SJMP    ??APSME_TCLinkKeyInit_0
   3752            
   3753            // Initialize the default tclk
   3754            if( zgUseDefaultTCLK == TRUE )
   \                     ??APSME_TCLinkKeyInit_1:
   \   000055   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   000058   E0           MOVX    A,@DPTR
   \   000059   6401         XRL     A,#0x1
   \   00005B   705A         JNZ     ??APSME_TCLinkKeyInit_2
   3755            {
   3756              osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00005D                ; Setup parameters for call to function osal_memset
   \   00005D   7C08         MOV     R4,#0x8
   \   00005F   7D00         MOV     R5,#0x0
   \   000061   79FF         MOV     R1,#-0x1
   \   000063   85..82       MOV     DPL,?XSP + 0
   \   000066   85..83       MOV     DPH,?XSP + 1
   \   000069   AA82         MOV     R2,DPL
   \   00006B   AB83         MOV     R3,DPH
   \   00006D   12....       LCALL   ??osal_memset?relay
   3757              osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   000070                ; Setup parameters for call to function osal_memcpy
   \   000070   75....       MOV     ?V0 + 0,#defaultTCLinkKey & 0xff
   \   000073   75....       MOV     ?V0 + 1,#(defaultTCLinkKey >> 8) & 0xff
   \   000076   75..80       MOV     ?V0 + 2,#-0x80
   \   000079   78..         MOV     R0,#?V0 + 0
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00007E   7C10         MOV     R4,#0x10
   \   000080   7D00         MOV     R5,#0x0
   \   000082   740B         MOV     A,#0xb
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   AA82         MOV     R2,DPL
   \   000089   AB83         MOV     R3,DPH
   \   00008B   12....       LCALL   ??osal_memcpy?relay
   \   00008E   7403         MOV     A,#0x3
   \   000090   12....       LCALL   ?DEALLOC_XSTACK8
   3758              
   3759              // If the item doesn't exist in NV memory, create and initialize
   3760              // it with the default value passed in.
   3761              osal_nv_item_init( ZCD_NV_TCLK_TABLE_START, sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000093                ; Setup parameters for call to function osal_nv_item_init
   \   000093   85..82       MOV     DPL,?XSP + 0
   \   000096   85..83       MOV     DPH,?XSP + 1
   \   000099   8582..       MOV     ?V0 + 0,DPL
   \   00009C   8583..       MOV     ?V0 + 1,DPH
   \   00009F   78..         MOV     R0,#?V0 + 0
   \   0000A1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A4   7C20         MOV     R4,#0x20
   \   0000A6   7D00         MOV     R5,#0x0
   \   0000A8   7A01         MOV     R2,#0x1
   \   0000AA   7B01         MOV     R3,#0x1
   \   0000AC   12....       LCALL   ??osal_nv_item_init?relay
   \   0000AF   7402         MOV     A,#0x2
   \   0000B1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B4   E9           MOV     A,R1
   \   0000B5   8022         SJMP    ??APSME_TCLinkKeyInit_3
   3762            }
   3763            else
   3764            {
   3765              osal_nv_item_init( ZCD_NV_TCLK_TABLE_START, sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   \                     ??APSME_TCLinkKeyInit_2:
   \   0000B7                ; Setup parameters for call to function osal_nv_item_init
   \   0000B7   85..82       MOV     DPL,?XSP + 0
   \   0000BA   85..83       MOV     DPH,?XSP + 1
   \   0000BD   8582..       MOV     ?V0 + 0,DPL
   \   0000C0   8583..       MOV     ?V0 + 1,DPH
   \   0000C3   78..         MOV     R0,#?V0 + 0
   \   0000C5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C8   7C20         MOV     R4,#0x20
   \   0000CA   7D00         MOV     R5,#0x0
   \   0000CC   7A01         MOV     R2,#0x1
   \   0000CE   7B01         MOV     R3,#0x1
   \   0000D0   12....       LCALL   ??osal_nv_item_init?relay
   \   0000D3   7402         MOV     A,#0x2
   \   0000D5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D8   E9           MOV     A,R1
   3766            }
   3767          }
   \                     ??APSME_TCLinkKeyInit_3:
   \   0000D9   7420         MOV     A,#0x20
   \   0000DB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DE   7F03         MOV     R7,#0x3
   \   0000E0   02....       LJMP    ?BANKED_LEAVE_XDATA
   3768          
   3769          /******************************************************************************
   3770           * @fn          APSME_TCLinkKeySync
   3771           *
   3772           * @brief       Sync Trust Center LINK key data.
   3773           *
   3774           * @param       srcAddr - [in] srcAddr
   3775           * @param       si      - [in, out] SSP_Info_t
   3776           *
   3777           * @return      ZStatus_t
   3778           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3779          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3780          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 8,R2
   \   00000C   8B..         MOV     ?V0 + 9,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   3781            ZStatus_t          status = ZSecNoKey;
   \   000012   75..A1       MOV     ?V0 + 0,#-0x5f
   3782            uint8              i;
   3783            APSME_TCLinkKey_t  tcLinkKey;       
   3784            
   3785            // Look up the IEEE address of the trust center if it's available
   3786            if ( AddrMgrExtAddrValid( si->extAddr ) == false )
   \   000015                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000015   E5..         MOV     A,?V0 + 2
   \   000017   2406         ADD     A,#0x6
   \   000019   FA           MOV     R2,A
   \   00001A   E5..         MOV     A,?V0 + 3
   \   00001C   3400         ADDC    A,#0x0
   \   00001E   FB           MOV     R3,A
   \   00001F   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000022   E9           MOV     A,R1
   \   000023   7012         JNZ     ??APSME_TCLinkKeySync_0
   3787            {
   3788              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   000025                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000025   E5..         MOV     A,?V0 + 2
   \   000027   2406         ADD     A,#0x6
   \   000029   FC           MOV     R4,A
   \   00002A   E5..         MOV     A,?V0 + 3
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FD           MOV     R5,A
   \   00002F   AA..         MOV     R2,?V0 + 8
   \   000031   AB..         MOV     R3,?V0 + 9
   \   000033   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   000036   E9           MOV     A,R1
   3789            }
   3790            
   3791            // Look up the TC link key associated with the device
   3792            // or the default TC link key (extAddr is all FFs), whichever is found
   3793            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \                     ??APSME_TCLinkKeySync_0:
   \   000037   75..00       MOV     ?V0 + 1,#0x0
   \                     ??APSME_TCLinkKeySync_1:
   \   00003A   E5..         MOV     A,?V0 + 1
   \   00003C   C3           CLR     C
   \   00003D   9401         SUBB    A,#0x1
   \   00003F   4003         JC      $+5
   \   000041   02....       LJMP    ??APSME_TCLinkKeySync_2 & 0xFFFF
   3794            {
   3795              // Read entry i of the TC link key table from NV
   3796              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3797                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000044                ; Setup parameters for call to function osal_nv_read
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   8582..       MOV     ?V0 + 4,DPL
   \   00004D   8583..       MOV     ?V0 + 5,DPH
   \   000050   78..         MOV     R0,#?V0 + 4
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   75..20       MOV     ?V0 + 4,#0x20
   \   000058   75..00       MOV     ?V0 + 5,#0x0
   \   00005B   78..         MOV     R0,#?V0 + 4
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   7C00         MOV     R4,#0x0
   \   000062   7D00         MOV     R5,#0x0
   \   000064   85....       MOV     ?V0 + 4,?V0 + 1
   \   000067   75..00       MOV     ?V0 + 5,#0x0
   \   00006A   E5..         MOV     A,?V0 + 4
   \   00006C   2401         ADD     A,#0x1
   \   00006E   FA           MOV     R2,A
   \   00006F   E5..         MOV     A,?V0 + 5
   \   000071   3401         ADDC    A,#0x1
   \   000073   FB           MOV     R3,A
   \   000074   12....       LCALL   ??osal_nv_read?relay
   \   000077   7404         MOV     A,#0x4
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007C   E9           MOV     A,R1
   3798              
   3799              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3800                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   00007D                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00007D   85..82       MOV     DPL,?XSP + 0
   \   000080   85..83       MOV     DPH,?XSP + 1
   \   000083   AC82         MOV     R4,DPL
   \   000085   AD83         MOV     R5,DPH
   \   000087   E5..         MOV     A,?V0 + 2
   \   000089   2406         ADD     A,#0x6
   \   00008B   FA           MOV     R2,A
   \   00008C   E5..         MOV     A,?V0 + 3
   \   00008E   3400         ADDC    A,#0x0
   \   000090   FB           MOV     R3,A
   \   000091   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000094   E9           MOV     A,R1
   \   000095   7013         JNZ     ??APSME_TCLinkKeySync_3
   \   000097                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000097   85..82       MOV     DPL,?XSP + 0
   \   00009A   85..83       MOV     DPH,?XSP + 1
   \   00009D   AA82         MOV     R2,DPL
   \   00009F   AB83         MOV     R3,DPH
   \   0000A1   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   0000A4   E9           MOV     A,R1
   \   0000A5   7003         JNZ     $+5
   \   0000A7   02....       LJMP    ??APSME_TCLinkKeySync_4 & 0xFFFF
   3801              {
   3802                // verify that the incoming frame counter is valid
   3803                if ( si->frmCntr >= tcLinkKey.rxFrmCntr )
   \                     ??APSME_TCLinkKeySync_3:
   \   0000AA   741C         MOV     A,#0x1c
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   78..         MOV     R0,#?V0 + 4
   \   0000B1   12....       LCALL   ?L_MOV_X
   \   0000B4   E5..         MOV     A,?V0 + 2
   \   0000B6   2412         ADD     A,#0x12
   \   0000B8   F582         MOV     DPL,A
   \   0000BA   E5..         MOV     A,?V0 + 3
   \   0000BC   3400         ADDC    A,#0x0
   \   0000BE   F583         MOV     DPH,A
   \   0000C0   78..         MOV     R0,#?V0 + 4
   \   0000C2   12....       LCALL   ?UL_GT_X
   \   0000C5   5003         JNC     $+5
   \   0000C7   02....       LJMP    ??APSME_TCLinkKeySync_5 & 0xFFFF
   3804                {
   3805                  // set the key to use
   3806                  osal_memcpy( si->key, tcLinkKey.key, SEC_KEY_LEN );
   \   0000CA                ; Setup parameters for call to function osal_memcpy
   \   0000CA   7408         MOV     A,#0x8
   \   0000CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CF   A982         MOV     R1,DPL
   \   0000D1   AA83         MOV     R2,DPH
   \   0000D3   7B00         MOV     R3,#0x0
   \   0000D5   89..         MOV     ?V0 + 4,R1
   \   0000D7   8A..         MOV     ?V0 + 5,R2
   \   0000D9   8B..         MOV     ?V0 + 6,R3
   \   0000DB   78..         MOV     R0,#?V0 + 4
   \   0000DD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E0   7C10         MOV     R4,#0x10
   \   0000E2   7D00         MOV     R5,#0x0
   \   0000E4   E5..         MOV     A,?V0 + 2
   \   0000E6   240F         ADD     A,#0xf
   \   0000E8   F582         MOV     DPL,A
   \   0000EA   E5..         MOV     A,?V0 + 3
   \   0000EC   3400         ADDC    A,#0x0
   \   0000EE   F583         MOV     DPH,A
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   FA           MOV     R2,A
   \   0000F2   A3           INC     DPTR
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   FB           MOV     R3,A
   \   0000F5   12....       LCALL   ??osal_memcpy?relay
   \   0000F8   7403         MOV     A,#0x3
   \   0000FA   12....       LCALL   ?DEALLOC_XSTACK8
   3807                  
   3808                  // update the rx frame counter
   3809                  tcLinkKey.rxFrmCntr = si->frmCntr + 1;
   \   0000FD   E5..         MOV     A,?V0 + 2
   \   0000FF   2412         ADD     A,#0x12
   \   000101   F582         MOV     DPL,A
   \   000103   E5..         MOV     A,?V0 + 3
   \   000105   3400         ADDC    A,#0x0
   \   000107   F583         MOV     DPH,A
   \   000109   78..         MOV     R0,#?V0 + 4
   \   00010B   12....       LCALL   ?L_MOV_X
   \   00010E   90....       MOV     DPTR,#__Constant_1
   \   000111   78..         MOV     R0,#?V0 + 4
   \   000113   12....       LCALL   ?L_ADD_X
   \   000116   AC..         MOV     R4,?V0 + 4
   \   000118   AD..         MOV     R5,?V0 + 5
   \   00011A   AE..         MOV     R6,?V0 + 6
   \   00011C   AF..         MOV     R7,?V0 + 7
   \   00011E   741C         MOV     A,#0x1c
   \   000120   12....       LCALL   ?XSTACK_DISP0_8
   \   000123   E5..         MOV     A,?V0 + 4
   \   000125   F0           MOVX    @DPTR,A
   \   000126   A3           INC     DPTR
   \   000127   E5..         MOV     A,?V0 + 5
   \   000129   F0           MOVX    @DPTR,A
   \   00012A   A3           INC     DPTR
   \   00012B   E5..         MOV     A,?V0 + 6
   \   00012D   F0           MOVX    @DPTR,A
   \   00012E   A3           INC     DPTR
   \   00012F   E5..         MOV     A,?V0 + 7
   \   000131   F0           MOVX    @DPTR,A
   3810                  
   3811                  // Write the tc link key back to the NV
   3812                  osal_nv_write( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3813                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000132                ; Setup parameters for call to function osal_nv_write
   \   000132   85..82       MOV     DPL,?XSP + 0
   \   000135   85..83       MOV     DPH,?XSP + 1
   \   000138   8582..       MOV     ?V0 + 4,DPL
   \   00013B   8583..       MOV     ?V0 + 5,DPH
   \   00013E   78..         MOV     R0,#?V0 + 4
   \   000140   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000143   75..20       MOV     ?V0 + 4,#0x20
   \   000146   75..00       MOV     ?V0 + 5,#0x0
   \   000149   78..         MOV     R0,#?V0 + 4
   \   00014B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014E   7C00         MOV     R4,#0x0
   \   000150   7D00         MOV     R5,#0x0
   \   000152   85....       MOV     ?V0 + 4,?V0 + 1
   \   000155   75..00       MOV     ?V0 + 5,#0x0
   \   000158   E5..         MOV     A,?V0 + 4
   \   00015A   2401         ADD     A,#0x1
   \   00015C   FA           MOV     R2,A
   \   00015D   E5..         MOV     A,?V0 + 5
   \   00015F   3401         ADDC    A,#0x1
   \   000161   FB           MOV     R3,A
   \   000162   12....       LCALL   ??osal_nv_write?relay
   \   000165   7404         MOV     A,#0x4
   \   000167   12....       LCALL   ?DEALLOC_XSTACK8
   \   00016A   E9           MOV     A,R1
   3814                  
   3815                  status = ZSuccess;
   \   00016B   75..00       MOV     ?V0 + 0,#0x0
   \   00016E   8003         SJMP    ??APSME_TCLinkKeySync_6
   3816                  
   3817                }
   3818                else
   3819                {
   3820                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_5:
   \   000170   75..A2       MOV     ?V0 + 0,#-0x5e
   3821                }
   3822                
   3823                return status;
   \                     ??APSME_TCLinkKeySync_6:
   \   000173   A9..         MOV     R1,?V0 + 0
   \   000175   8007         SJMP    ??APSME_TCLinkKeySync_7
   3824              }
   3825            }
   \                     ??APSME_TCLinkKeySync_4:
   \   000177   05..         INC     ?V0 + 1
   \   000179   02....       LJMP    ??APSME_TCLinkKeySync_1 & 0xFFFF
   3826            
   3827            
   3828            return status;
   \                     ??APSME_TCLinkKeySync_2:
   \   00017C   A9..         MOV     R1,?V0 + 0
   \                     ??APSME_TCLinkKeySync_7:
   \   00017E   7420         MOV     A,#0x20
   \   000180   12....       LCALL   ?DEALLOC_XSTACK8
   \   000183   7F0A         MOV     R7,#0xa
   \   000185   02....       LJMP    ?BANKED_LEAVE_XDATA
   3829          }
   3830          
   3831          /******************************************************************************
   3832           * @fn          APSME_TCLinkKeyLoad
   3833           *
   3834           * @brief       Load Trust Center LINK key data.
   3835           *
   3836           * @param       dstAddr - [in] dstAddr
   3837           * @param       si      - [in, out] SSP_Info_t
   3838           *
   3839           * @return      ZStatus_t
   3840           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3841          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3842          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV     A,#-0x2d
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3843            uint8              i;
   3844            APSME_TCLinkKey_t  tcLinkKey;
   3845            AddrMgrEntry_t     addrEntry;  
   3846            
   3847            // Look up the ami of the srcAddr if available
   3848            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7400         MOV     A,#0x0
   \   00001A   F0           MOVX    @DPTR,A
   3849            addrEntry.nwkAddr = dstAddr;
   \   00001B   7401         MOV     A,#0x1
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E5..         MOV     A,?V0 + 2
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E5..         MOV     A,?V0 + 3
   \   000026   F0           MOVX    @DPTR,A
   3850          
   3851            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \   000027                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000027   EE           MOV     A,R6
   \   000028   2406         ADD     A,#0x6
   \   00002A   FC           MOV     R4,A
   \   00002B   EF           MOV     A,R7
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FD           MOV     R5,A
   \   00002F   AA..         MOV     R2,?V0 + 2
   \   000031   AB..         MOV     R3,?V0 + 3
   \   000033   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   000036   E9           MOV     A,R1
   3852          
   3853            if ( AddrMgrExtAddrValid( si->extAddr ) == TRUE )
   \   000037                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000037   EE           MOV     A,R6
   \   000038   2406         ADD     A,#0x6
   \   00003A   FA           MOV     R2,A
   \   00003B   EF           MOV     A,R7
   \   00003C   3400         ADDC    A,#0x0
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000042   E9           MOV     A,R1
   \   000043   6401         XRL     A,#0x1
   \   000045   6003         JZ      $+5
   \   000047   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   3854            {
   3855              // Look up the TC link key associated with the device
   3856              // or the master TC link key (ami = 0xFFFF), whichever is found
   3857              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00004A   75..00       MOV     ?V0 + 0,#0x0
   \                     ??APSME_TCLinkKeyLoad_1:
   \   00004D   E5..         MOV     A,?V0 + 0
   \   00004F   C3           CLR     C
   \   000050   9401         SUBB    A,#0x1
   \   000052   4003         JC      $+5
   \   000054   02....       LJMP    ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   3858              {
   3859                // Read entry i of the TC link key table from NV
   3860                osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3861                             sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000057                ; Setup parameters for call to function osal_nv_read
   \   000057   740D         MOV     A,#0xd
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   8582..       MOV     ?V0 + 4,DPL
   \   00005F   8583..       MOV     ?V0 + 5,DPH
   \   000062   78..         MOV     R0,#?V0 + 4
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   75..20       MOV     ?V0 + 4,#0x20
   \   00006A   75..00       MOV     ?V0 + 5,#0x0
   \   00006D   78..         MOV     R0,#?V0 + 4
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   7C00         MOV     R4,#0x0
   \   000074   7D00         MOV     R5,#0x0
   \   000076   85....       MOV     ?V0 + 4,?V0 + 0
   \   000079   75..00       MOV     ?V0 + 5,#0x0
   \   00007C   E5..         MOV     A,?V0 + 4
   \   00007E   2401         ADD     A,#0x1
   \   000080   FA           MOV     R2,A
   \   000081   E5..         MOV     A,?V0 + 5
   \   000083   3401         ADDC    A,#0x1
   \   000085   FB           MOV     R3,A
   \   000086   12....       LCALL   ??osal_nv_read?relay
   \   000089   7404         MOV     A,#0x4
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008E   E9           MOV     A,R1
   3862                
   3863                if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3864                   APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   00008F                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00008F   740D         MOV     A,#0xd
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   AC82         MOV     R4,DPL
   \   000096   AD83         MOV     R5,DPH
   \   000098   EE           MOV     A,R6
   \   000099   2406         ADD     A,#0x6
   \   00009B   FA           MOV     R2,A
   \   00009C   EF           MOV     A,R7
   \   00009D   3400         ADDC    A,#0x0
   \   00009F   FB           MOV     R3,A
   \   0000A0   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   0000A3   E9           MOV     A,R1
   \   0000A4   7012         JNZ     ??APSME_TCLinkKeyLoad_2
   \   0000A6                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   0000A6   740D         MOV     A,#0xd
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   AA82         MOV     R2,DPL
   \   0000AD   AB83         MOV     R3,DPH
   \   0000AF   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   0000B2   E9           MOV     A,R1
   \   0000B3   7003         JNZ     $+5
   \   0000B5   02....       LJMP    ??APSME_TCLinkKeyLoad_3 & 0xFFFF
   3865                {
   3866                  // set the key to use
   3867                  osal_memcpy( si->key, tcLinkKey.key, SEC_KEY_LEN);  
   \                     ??APSME_TCLinkKeyLoad_2:
   \   0000B8                ; Setup parameters for call to function osal_memcpy
   \   0000B8   7415         MOV     A,#0x15
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   A982         MOV     R1,DPL
   \   0000BF   AA83         MOV     R2,DPH
   \   0000C1   7B00         MOV     R3,#0x0
   \   0000C3   89..         MOV     ?V0 + 4,R1
   \   0000C5   8A..         MOV     ?V0 + 5,R2
   \   0000C7   8B..         MOV     ?V0 + 6,R3
   \   0000C9   78..         MOV     R0,#?V0 + 4
   \   0000CB   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000CE   7C10         MOV     R4,#0x10
   \   0000D0   7D00         MOV     R5,#0x0
   \   0000D2   EE           MOV     A,R6
   \   0000D3   240F         ADD     A,#0xf
   \   0000D5   F582         MOV     DPL,A
   \   0000D7   EF           MOV     A,R7
   \   0000D8   3400         ADDC    A,#0x0
   \   0000DA   F583         MOV     DPH,A
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   FA           MOV     R2,A
   \   0000DE   A3           INC     DPTR
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   FB           MOV     R3,A
   \   0000E1   12....       LCALL   ??osal_memcpy?relay
   \   0000E4   7403         MOV     A,#0x3
   \   0000E6   12....       LCALL   ?DEALLOC_XSTACK8
   3868                  
   3869                  // update link key related fields
   3870                  si->keyID   = SEC_KEYID_LINK;
   \   0000E9   EE           MOV     A,R6
   \   0000EA   240E         ADD     A,#0xe
   \   0000EC   F582         MOV     DPL,A
   \   0000EE   EF           MOV     A,R7
   \   0000EF   3400         ADDC    A,#0x0
   \   0000F1   F583         MOV     DPH,A
   \   0000F3   7400         MOV     A,#0x0
   \   0000F5   F0           MOVX    @DPTR,A
   3871                  si->frmCntr = tcLinkKey.txFrmCntr;
   \   0000F6   7425         MOV     A,#0x25
   \   0000F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FB   12....       LCALL   ?XLOAD_R2345
   \   0000FE   EE           MOV     A,R6
   \   0000FF   2412         ADD     A,#0x12
   \   000101   F582         MOV     DPL,A
   \   000103   EF           MOV     A,R7
   \   000104   3400         ADDC    A,#0x0
   \   000106   F583         MOV     DPH,A
   \   000108   12....       LCALL   ?XSTORE_R2345
   3872                
   3873                  // update outgoing frame counter
   3874                  tcLinkKey.txFrmCntr++;
   \   00010B   90....       MOV     DPTR,#__Constant_1
   \   00010E   78..         MOV     R0,#?V0 + 4
   \   000110   12....       LCALL   ?L_MOV_X
   \   000113   7425         MOV     A,#0x25
   \   000115   12....       LCALL   ?XSTACK_DISP0_8
   \   000118   78..         MOV     R0,#?V0 + 4
   \   00011A   12....       LCALL   ?L_ADD_TO_X
   3875                  
   3876                  // Write the tc link key back to the NV
   3877                  osal_nv_write( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3878                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00011D                ; Setup parameters for call to function osal_nv_write
   \   00011D   740D         MOV     A,#0xd
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   8582..       MOV     ?V0 + 4,DPL
   \   000125   8583..       MOV     ?V0 + 5,DPH
   \   000128   78..         MOV     R0,#?V0 + 4
   \   00012A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00012D   75..20       MOV     ?V0 + 4,#0x20
   \   000130   75..00       MOV     ?V0 + 5,#0x0
   \   000133   78..         MOV     R0,#?V0 + 4
   \   000135   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000138   7C00         MOV     R4,#0x0
   \   00013A   7D00         MOV     R5,#0x0
   \   00013C   85....       MOV     ?V0 + 4,?V0 + 0
   \   00013F   75..00       MOV     ?V0 + 5,#0x0
   \   000142   E5..         MOV     A,?V0 + 4
   \   000144   2401         ADD     A,#0x1
   \   000146   FA           MOV     R2,A
   \   000147   E5..         MOV     A,?V0 + 5
   \   000149   3401         ADDC    A,#0x1
   \   00014B   FB           MOV     R3,A
   \   00014C   12....       LCALL   ??osal_nv_write?relay
   \   00014F   7404         MOV     A,#0x4
   \   000151   12....       LCALL   ?DEALLOC_XSTACK8
   \   000154   E9           MOV     A,R1
   3879                  
   3880                  return ZSuccess;
   \   000155   7900         MOV     R1,#0x0
   \   000157   8027         SJMP    ??APSME_TCLinkKeyLoad_4
   3881                }
   3882              }
   \                     ??APSME_TCLinkKeyLoad_3:
   \   000159   05..         INC     ?V0 + 0
   \   00015B   02....       LJMP    ??APSME_TCLinkKeyLoad_1 & 0xFFFF
   3883            }
   3884              
   3885            // If no TC link key found, remove the device from the address manager
   3886            if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   00015E                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   00015E   85..82       MOV     DPL,?XSP + 0
   \   000161   85..83       MOV     DPH,?XSP + 1
   \   000164   AA82         MOV     R2,DPL
   \   000166   AB83         MOV     R3,DPH
   \   000168   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   00016B   E9           MOV     A,R1
   \   00016C   6401         XRL     A,#0x1
   \   00016E   700E         JNZ     ??APSME_TCLinkKeyLoad_5
   3887            {
   3888              AddrMgrEntryRelease( &addrEntry );
   \   000170                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000170   85..82       MOV     DPL,?XSP + 0
   \   000173   85..83       MOV     DPH,?XSP + 1
   \   000176   AA82         MOV     R2,DPL
   \   000178   AB83         MOV     R3,DPH
   \   00017A   12....       LCALL   ??AddrMgrEntryRelease?relay
   \   00017D   E9           MOV     A,R1
   3889            }
   3890          
   3891            return ZSecNoKey;
   \                     ??APSME_TCLinkKeyLoad_5:
   \   00017E   79A1         MOV     R1,#-0x5f
   \                     ??APSME_TCLinkKeyLoad_4:
   \   000180   742D         MOV     A,#0x2d
   \   000182   12....       LCALL   ?DEALLOC_XSTACK8
   \   000185   7F08         MOV     R7,#0x8
   \   000187   02....       LJMP    ?BANKED_LEAVE_XDATA
   3892          }
   3893          
   3894          /******************************************************************************
   3895           * @fn          APSME_IsDefaultTCLK
   3896           *
   3897           * @brief       Return true or false based on the extended address.  If the 
   3898           *              input ext address is all FFs, it means the trust center link
   3899           *              assoiciated with the address is the default trust center link key
   3900           *
   3901           * @param       extAddr - [in] extended address
   3902           *
   3903           * @return      uint8 TRUE/FALSE
   3904           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3905          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   3906          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3907            uint8 i = 0;
   \   000005   7C00         MOV     R4,#0x0
   3908            
   3909            if( extAddr == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   4B           ORL     A,R3
   \   000009   7004         JNZ     ??APSME_IsDefaultTCLK_0
   3910            {
   3911              return FALSE;
   \   00000B   7900         MOV     R1,#0x0
   \   00000D   8028         SJMP    ??APSME_IsDefaultTCLK_1
   3912            }
   3913            
   3914            while( i++ < Z_EXTADDR_LEN )
   \                     ??APSME_IsDefaultTCLK_0:
   \   00000F   EC           MOV     A,R4
   \   000010   FD           MOV     R5,A
   \   000011   7401         MOV     A,#0x1
   \   000013   2D           ADD     A,R5
   \   000014   FC           MOV     R4,A
   \   000015   ED           MOV     A,R5
   \   000016   C3           CLR     C
   \   000017   9408         SUBB    A,#0x8
   \   000019   501A         JNC     ??APSME_IsDefaultTCLK_2
   3915            {
   3916              if( *extAddr++ != 0xFF )
   \   00001B   EA           MOV     A,R2
   \   00001C   F8           MOV     R0,A
   \   00001D   EB           MOV     A,R3
   \   00001E   F9           MOV     R1,A
   \   00001F   8882         MOV     DPL,R0
   \   000021   8983         MOV     DPH,R1
   \   000023   A3           INC     DPTR
   \   000024   AA82         MOV     R2,DPL
   \   000026   AB83         MOV     R3,DPH
   \   000028   8882         MOV     DPL,R0
   \   00002A   8983         MOV     DPH,R1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   64FF         XRL     A,#0xff
   \   00002F   60DE         JZ      ??APSME_IsDefaultTCLK_0
   3917              {
   3918                return FALSE;
   \   000031   7900         MOV     R1,#0x0
   \   000033   8002         SJMP    ??APSME_IsDefaultTCLK_1
   3919              }
   3920            }
   3921            
   3922            return TRUE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   000035   7901         MOV     R1,#0x1
   \                     ??APSME_IsDefaultTCLK_1:
   \   000037   7F01         MOV     R7,#0x1
   \   000039   02....       LJMP    ?BANKED_LEAVE_XDATA
   3923          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrTCMasterKey>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlRelease?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlTerm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendMasterKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemoveByExtAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrMgrUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlSetup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_SKA_TimerExpired?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateSKKE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateCM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthInitiate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyTypeSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyTypeSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_MasterKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyDataGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyDataGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeySync?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsDefaultTCLK?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK
   3924          
   3925          
   3926          /******************************************************************************
   3927          ******************************************************************************/
   3928          

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0     70  APSME_IsDefaultTCLK
       0      0      9  APSME_KeyFwdToChild
                          0 0  9 -> AssocGetWithExt
                          0 0  9 -> ZDSecMgrAssocDeviceAuth
       0      0     13  APSME_LinkKeyDataGet
                          0 0 13 -> ZDSecMgrEntryLookupExt
       0      0     38  APSME_LinkKeySet
                          0 0 17 -> ZDSecMgrEntryLookupExt
                          0 0 20 -> osal_memcpy
       0      0     13  APSME_MasterKeyGet
                          0 0 13 -> ZDSecMgrExtAddrLookup
                          0 0 13 -> ZDSecMgrMasterKeyLookup
       0      0      9  APSME_SKA_TimerExpired
                          0 0  9 -> ZDSecMgrDeviceCtrlUpdate
       0      0     46  APSME_TCLinkKeyInit
                          0 0 46 -> osal_memcpy
                          0 0 43 -> osal_memset
                          0 0 45 -> osal_nv_item_init
       0      0     65  APSME_TCLinkKeyLoad
                          0 0 61 -> APSME_IsDefaultTCLK
                          0 0 61 -> APSME_LookupExtAddr
                          0 0 61 -> AddrMgrEntryLookupNwk
                          0 0 61 -> AddrMgrEntryRelease
                          0 0 61 -> AddrMgrExtAddrEqual
                          0 0 61 -> AddrMgrExtAddrValid
                          0 0 64 -> osal_memcpy
                          0 0 65 -> osal_nv_read
                          0 0 65 -> osal_nv_write
       0      0     54  APSME_TCLinkKeySync
                          0 0 50 -> APSME_IsDefaultTCLK
                          0 0 50 -> APSME_LookupExtAddr
                          0 0 50 -> AddrMgrExtAddrEqual
                          0 0 50 -> AddrMgrExtAddrValid
                          0 0 53 -> osal_memcpy
                          0 0 54 -> osal_nv_read
                          0 0 54 -> osal_nv_write
       0      0     24  ZDSecMgrAPSRemove
                          0 0 22 -> ZDSecMgrDeviceRemove
       0      0     22  ZDSecMgrAddLinkKey
                          0 0 18 -> APSME_LinkKeySet
                          0 0 20 -> ZDSecMgrAddrStore
                          0 0 18 -> ZDSecMgrEntryLookupAMI
                          0 0 18 -> ZDSecMgrEntryNew
       0      0     36  ZDSecMgrAddrMgrUpdate
                          0 0 23 -> AddrMgrEntryGet
                          0 0 23 -> AddrMgrEntryUpdate
       0      0     46  ZDSecMgrAddrStore
                          0 0 26 -> AddrMgrEntryUpdate
                          0 0 26 -> AddrMgrExtAddrSet
       1      0     75  ZDSecMgrAppKeyGet
                          0 0 18 -> SSP_GetTrueRand
       0      0     66  ZDSecMgrAppKeyReq
                          0 0 49 -> APSME_LookupExtAddr
                          0 0 49 -> APSME_LookupNwkAddr
                          0 0 49 -> APSME_TransportKeyReq
                          0 0 57 -> ZDSecMgrAppKeyGet
       2      0      0  ZDSecMgrAppKeyTypeSet
       2      0     35  ZDSecMgrAssocDeviceAuth
       0      0     16  ZDSecMgrAuthInitiate
                          0 0 16 -> APSME_AuthenticateReq
                          0 0 16 -> APSME_LookupNwkAddr
       2      0     11  ZDSecMgrAuthNwkKey
                          2 0  0 -> osal_set_event
       0      0      9  ZDSecMgrAuthenticateCfm
                          0 0  9 -> osal_set_event
       0      0     29  ZDSecMgrAuthenticateInd
                          0 0 29 -> APSME_AuthenticateReq
                          0 0 29 -> AddrMgrEntryUpdate
                          0 0 29 -> AddrMgrExtAddrSet
       0      0      0  ZDSecMgrAuthenticationCheck
       1      0     12  ZDSecMgrAuthenticationSet
                          0 0 12 -> ZDSecMgrEntryLookupExt
       2      0      9  ZDSecMgrConfig
                          2 0  0 -> APSME_SecurityNM
       0      0     31  ZDSecMgrCtrlAdd
                          0 0 18 -> ZDSecMgrCtrlSet
       0      0     10  ZDSecMgrCtrlInit
                          0 0 10 -> osal_mem_alloc
       0      0     22  ZDSecMgrCtrlLookup
       2      0     11  ZDSecMgrCtrlRelease
       0      0     28  ZDSecMgrCtrlReset
                          0 0 13 -> ZDSecMgrCtrlAdd
                          0 0 13 -> ZDSecMgrCtrlLookup
                          0 0 15 -> ZDSecMgrCtrlSet
       1      0     27  ZDSecMgrCtrlSet
       0      0     20  ZDSecMgrCtrlTerm
                          0 0 11 -> ZDSecMgrCtrlLookup
                          0 0 11 -> ZDSecMgrCtrlRelease
       1      0     43  ZDSecMgrDeviceCtrlHandler
                          0 0 10 -> ZDSecMgrCtrlRelease
                          0 0 10 -> ZDSecMgrEstablishKey
                          0 0 10 -> ZDSecMgrSendMasterKey
                          0 0 10 -> ZDSecMgrSendNwkKey
                          0 0 10 -> osal_start_timerEx
       0      0      9  ZDSecMgrDeviceCtrlSetup
                          0 0  9 -> ZDSecMgrDeviceCtrlHandler
       0      0     22  ZDSecMgrDeviceCtrlUpdate
                          0 0 13 -> ZDSecMgrCtrlLookup
                          0 0 13 -> ZDSecMgrEntryLookupExt
       0      0     28  ZDSecMgrDeviceEntryAdd
                          0 0 13 -> ZDSecMgrAddrMgrUpdate
                          0 0 13 -> ZDSecMgrCtrlAdd
                          0 0 13 -> ZDSecMgrCtrlReset
                          0 0 13 -> ZDSecMgrDeviceEntryRemove
                          0 0 13 -> ZDSecMgrEntryLookup
                          0 0 13 -> ZDSecMgrEntryLookupAMI
                          0 0 13 -> ZDSecMgrEntryNew
       0      0     22  ZDSecMgrDeviceEntryRemove
                          0 0  9 -> ZDSecMgrCtrlTerm
                          0 0  9 -> ZDSecMgrEntryFree
       0      0     34  ZDSecMgrDeviceJoin
                          0 0 15 -> ZDSecMgrAddrStore
                          0 0 13 -> ZDSecMgrDeviceRemove
                          0 0 13 -> ZDSecMgrDeviceValidate
                          0 0 13 -> ZDSecMgrSendNwkKey
       0      0     18  ZDSecMgrDeviceJoinDirect
                          0 0  9 -> AssocGetWithShort
                          0 0  9 -> ZDSecMgrAssocDeviceAuth
                          0 0  9 -> ZDSecMgrDeviceJoin
       0      0     17  ZDSecMgrDeviceJoinFwd
                          0 0 17 -> APSME_UpdateDeviceReq
       0      0     44  ZDSecMgrDeviceNew
                          0 0  9 -> ZDSecMgrDeviceJoinDirect
       2      0     43  ZDSecMgrDeviceRemove
                          0 0 21 -> APSME_RemoveDeviceReq
                          0 0 21 -> AssocGetWithExt
                          2 0 21 -> NLME_GetShortAddr
                          0 0 21 -> NLME_LeaveReq
       0      0     11  ZDSecMgrDeviceRemoveByExtAddr
                          0 0 11 -> ZDSecMgrDeviceEntryRemove
                          0 0 11 -> ZDSecMgrEntryLookupExt
       0      0     22  ZDSecMgrDeviceValidate
                          0 0  9 -> ZDSecMgrDeviceValidateRM
       0      0     17  ZDSecMgrDeviceValidateCM
                          0 0 17 -> ZDSecMgrAddrStore
                          0 0 15 -> ZDSecMgrDeviceEntryAdd
                          0 0 15 -> ZDSecMgrMasterKeyLoad
       2      0      9  ZDSecMgrDeviceValidateRM
       0      0     39  ZDSecMgrDeviceValidateSKKE
                          0 0 13 -> ZDSecMgrDeviceEntryAdd
                          0 0 13 -> ZDSecMgrExtAddrLookup
                          0 0 13 -> ZDSecMgrMasterKeyLookup
       2      0      9  ZDSecMgrEntryFree
       0      0     12  ZDSecMgrEntryInit
                          0 0 12 -> osal_mem_alloc
       0      0     39  ZDSecMgrEntryLookup
                          0 0 26 -> AddrMgrEntryLookupNwk
       0      0     28  ZDSecMgrEntryLookupAMI
       0      0     30  ZDSecMgrEntryLookupExt
                          0 0 13 -> ZDSecMgrEntryLookupAMI
                          0 0 13 -> ZDSecMgrExtAddrLookup
       0      0     27  ZDSecMgrEntryNew
       2      0     29  ZDSecMgrEstablishKey
                          0 0 19 -> APSME_EstablishKeyReq
                          2 0 19 -> NLME_GetShortAddr
       0      0      9  ZDSecMgrEstablishKeyCfm
                          0 0  9 -> ZDSecMgrDeviceCtrlUpdate
       1      0     26  ZDSecMgrEstablishKeyInd
                          0 0 26 -> APSME_EstablishKeyRsp
                          0 0 26 -> ZDSecMgrDeviceValidateSKKE
                          0 0 26 -> ZDSecMgrTCDataLoad
                          0 0 26 -> ZDSecMgrTCExtAddrCheck
       1      0     33  ZDSecMgrEvent
                          0 0 33 -> AddrMgrEntryGet
                          0 0 33 -> ZDSecMgrDeviceCtrlHandler
                          0 0 33 -> osal_start_timerEx
       0      0     43  ZDSecMgrExtAddrLookup
                          0 0 24 -> AddrMgrEntryLookupExt
                          0 0 24 -> AddrMgrExtAddrSet
       0      0     28  ZDSecMgrExtAddrStore
                          0 0 26 -> AddrMgrEntryUpdate
                          0 0 26 -> AddrMgrExtAddrSet
       0      0      9  ZDSecMgrInit
                          0 0  9 -> ZDSecMgrConfig
       0      0     10  ZDSecMgrMasterKeyInit
                          0 0 10 -> osal_mem_alloc
       0      0     37  ZDSecMgrMasterKeyLoad
                          0 0 19 -> ZDSecMgrExtAddrLookup
                          0 0 19 -> ZDSecMgrMasterKeyLookup
                          0 0 19 -> ZDSecMgrMasterKeyStore
                          0 0 22 -> osal_memcpy
       0      0     35  ZDSecMgrMasterKeyLookup
       0      0     40  ZDSecMgrMasterKeyStore
                          0 0 21 -> osal_memcpy
                          0 0 18 -> osal_memset
       1      0     35  ZDSecMgrNewDeviceEvent
                          0 0 35 -> AddrMgrEntryGet
                          0 0 35 -> AssocMatchDeviceStatus
                          0 0 35 -> AssocRemove
                          0 0 35 -> NLME_GetShortAddr
                          0 0 35 -> ZDSecMgrAssocDeviceAuth
                          0 0 35 -> ZDSecMgrDeviceNew
       2      0      0  ZDSecMgrPermitJoining
       2      0      0  ZDSecMgrPermitJoiningTimeout
       0      0     19  ZDSecMgrRemoveDeviceInd
                          0 0 19 -> APSME_LookupNwkAddr
                          0 0 19 -> NLME_GetShortAddr
                          0 0 19 -> ZDSecMgrDeviceRemove
       0      0      9  ZDSecMgrRequestKeyInd
                          0 0  9 -> ZDSecMgrAppKeyReq
       2      0     35  ZDSecMgrSendMasterKey
                          0 0 25 -> APSME_TransportKeyReq
                          2 0 25 -> NLME_GetShortAddr
                          0 0 25 -> ZDSecMgrMasterKeyLookup
       2      0     38  ZDSecMgrSendNwkKey
                          0 0 25 -> APSME_TransportKeyReq
                          2 0 25 -> NLME_GetShortAddr
       0      0      9  ZDSecMgrSwitchKeyInd
                          0 0  9 -> SSP_SwitchNwkKey
                          0 0  9 -> ZDApp_NVUpdate
       1      0     13  ZDSecMgrSwitchNwkKey
                          0 0 13 -> APSME_SwitchKeyReq
                          0 0 13 -> SSP_SwitchNwkKey
                          0 0 13 -> ZDApp_NVUpdate
       0      0     42  ZDSecMgrTCDataLoad
                          0 0 16 -> ZDSecMgrAddrStore
                          0 0 14 -> ZDSecMgrMasterKeyLookup
                          0 0 14 -> ZDSecMgrMasterKeyStore
       0      0     43  ZDSecMgrTCExtAddrCheck
                          0 0 17 -> AddrMgrExtAddrEqual
                          0 0 17 -> AddrMgrExtAddrLookup
       0      0     11  ZDSecMgrTransportKeyInd
                          0 0 11 -> SSP_SwitchNwkKey
                          0 0 11 -> SSP_UpdateNwkKey
                          0 0 11 -> ZDSecMgrAuthNwkKey
                          0 0 11 -> ZDSecMgrTCDataLoad
       0      0     19  ZDSecMgrUpdateDeviceInd
                          0 0 19 -> ZDSecMgrDeviceJoin
       1      0     25  ZDSecMgrUpdateNwkKey
                          0 0 25 -> APSME_TransportKeyReq
                          0 0 25 -> SSP_UpdateNwkKey
                          0 0 25 -> ZDApp_NVUpdate


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for ZDSecMgrAppKeyType>
      16  ?<Initializer for ZDSecMgrTCMasterKey>
       6  ??APSME_IsDefaultTCLK?relay
       6  ??APSME_KeyFwdToChild?relay
       6  ??APSME_LinkKeyDataGet?relay
       6  ??APSME_LinkKeySet?relay
       6  ??APSME_MasterKeyGet?relay
       6  ??APSME_SKA_TimerExpired?relay
       6  ??APSME_TCLinkKeyInit?relay
       6  ??APSME_TCLinkKeyLoad?relay
       6  ??APSME_TCLinkKeySync?relay
       6  ??ZDSecMgrAPSRemove?relay
       6  ??ZDSecMgrAddLinkKey?relay
       6  ??ZDSecMgrAddrMgrUpdate?relay
       6  ??ZDSecMgrAddrStore?relay
       6  ??ZDSecMgrAppKeyGet?relay
       6  ??ZDSecMgrAppKeyReq?relay
       6  ??ZDSecMgrAppKeyTypeSet?relay
       6  ??ZDSecMgrAssocDeviceAuth?relay
       6  ??ZDSecMgrAuthInitiate?relay
       6  ??ZDSecMgrAuthNwkKey?relay
       6  ??ZDSecMgrAuthenticateCfm?relay
       6  ??ZDSecMgrAuthenticateInd?relay
       6  ??ZDSecMgrAuthenticationCheck?relay
       6  ??ZDSecMgrAuthenticationSet?relay
       6  ??ZDSecMgrConfig?relay
       6  ??ZDSecMgrCtrlAdd?relay
       6  ??ZDSecMgrCtrlInit?relay
       6  ??ZDSecMgrCtrlLookup?relay
       6  ??ZDSecMgrCtrlRelease?relay
       6  ??ZDSecMgrCtrlReset?relay
       6  ??ZDSecMgrCtrlSet?relay
       6  ??ZDSecMgrCtrlTerm?relay
       6  ??ZDSecMgrDeviceCtrlHandler?relay
       6  ??ZDSecMgrDeviceCtrlSetup?relay
       6  ??ZDSecMgrDeviceCtrlUpdate?relay
       6  ??ZDSecMgrDeviceEntryAdd?relay
       6  ??ZDSecMgrDeviceEntryRemove?relay
       6  ??ZDSecMgrDeviceJoin?relay
       6  ??ZDSecMgrDeviceJoinDirect?relay
       6  ??ZDSecMgrDeviceJoinFwd?relay
       6  ??ZDSecMgrDeviceNew?relay
       6  ??ZDSecMgrDeviceRemove?relay
       6  ??ZDSecMgrDeviceRemoveByExtAddr?relay
       6  ??ZDSecMgrDeviceValidate?relay
       6  ??ZDSecMgrDeviceValidateCM?relay
       6  ??ZDSecMgrDeviceValidateRM?relay
       6  ??ZDSecMgrDeviceValidateSKKE?relay
       6  ??ZDSecMgrEntryFree?relay
       6  ??ZDSecMgrEntryInit?relay
       6  ??ZDSecMgrEntryLookup?relay
       6  ??ZDSecMgrEntryLookupAMI?relay
       6  ??ZDSecMgrEntryLookupExt?relay
       6  ??ZDSecMgrEntryNew?relay
       6  ??ZDSecMgrEstablishKey?relay
       6  ??ZDSecMgrEstablishKeyCfm?relay
       6  ??ZDSecMgrEstablishKeyInd?relay
       6  ??ZDSecMgrEvent?relay
       6  ??ZDSecMgrExtAddrLookup?relay
       6  ??ZDSecMgrExtAddrStore?relay
       6  ??ZDSecMgrInit?relay
       6  ??ZDSecMgrMasterKeyInit?relay
       6  ??ZDSecMgrMasterKeyLoad?relay
       6  ??ZDSecMgrMasterKeyLookup?relay
       6  ??ZDSecMgrMasterKeyStore?relay
       6  ??ZDSecMgrNewDeviceEvent?relay
       6  ??ZDSecMgrPermitJoining?relay
       6  ??ZDSecMgrPermitJoiningTimeout?relay
       6  ??ZDSecMgrRemoveDeviceInd?relay
       6  ??ZDSecMgrRequestKeyInd?relay
       6  ??ZDSecMgrSendMasterKey?relay
       6  ??ZDSecMgrSendNwkKey?relay
       6  ??ZDSecMgrSwitchKeyInd?relay
       6  ??ZDSecMgrSwitchNwkKey?relay
       6  ??ZDSecMgrTCDataLoad?relay
       6  ??ZDSecMgrTCExtAddrCheck?relay
       6  ??ZDSecMgrTransportKeyInd?relay
       6  ??ZDSecMgrUpdateDeviceInd?relay
       6  ??ZDSecMgrUpdateNwkKey?relay
      60  APSME_IsDefaultTCLK
      89  APSME_KeyFwdToChild
     129  APSME_LinkKeyDataGet
     170  APSME_LinkKeySet
      86  APSME_MasterKeyGet
      31  APSME_SKA_TimerExpired
     227  APSME_TCLinkKeyInit
     394  APSME_TCLinkKeyLoad
     392  APSME_TCLinkKeySync
      32  TrustCenterLinkKey
     122  ZDSecMgrAPSRemove
     183  ZDSecMgrAddLinkKey
     101  ZDSecMgrAddrMgrUpdate
     147  ZDSecMgrAddrStore
      95  ZDSecMgrAppKeyGet
     341  ZDSecMgrAppKeyReq
       1  ZDSecMgrAppKeyType
      34  ZDSecMgrAppKeyTypeSet
      28  ZDSecMgrAssocDeviceAuth
      88  ZDSecMgrAuthInitiate
      32  ZDSecMgrAuthNwkKey
      59  ZDSecMgrAuthenticateCfm
     170  ZDSecMgrAuthenticateInd
       5  ZDSecMgrAuthenticationCheck
      77  ZDSecMgrAuthenticationSet
      14  ZDSecMgrConfig
     173  ZDSecMgrCtrlAdd
       2  ZDSecMgrCtrlData
     112  ZDSecMgrCtrlInit
     228  ZDSecMgrCtrlLookup
      23  ZDSecMgrCtrlRelease
     109  ZDSecMgrCtrlReset
     115  ZDSecMgrCtrlSet
      70  ZDSecMgrCtrlTerm
     218  ZDSecMgrDeviceCtrlHandler
     113  ZDSecMgrDeviceCtrlSetup
     229  ZDSecMgrDeviceCtrlUpdate
     308  ZDSecMgrDeviceEntryAdd
      28  ZDSecMgrDeviceEntryRemove
     105  ZDSecMgrDeviceJoin
      45  ZDSecMgrDeviceJoinDirect
     242  ZDSecMgrDeviceJoinFwd
      26  ZDSecMgrDeviceNew
     271  ZDSecMgrDeviceRemove
      64  ZDSecMgrDeviceRemoveByExtAddr
      75  ZDSecMgrDeviceValidate
     127  ZDSecMgrDeviceValidateCM
      21  ZDSecMgrDeviceValidateRM
     108  ZDSecMgrDeviceValidateSKKE
       2  ZDSecMgrEntries
      22  ZDSecMgrEntryFree
     119  ZDSecMgrEntryInit
     237  ZDSecMgrEntryLookup
     167  ZDSecMgrEntryLookupAMI
      85  ZDSecMgrEntryLookupExt
     216  ZDSecMgrEntryNew
     183  ZDSecMgrEstablishKey
      27  ZDSecMgrEstablishKeyCfm
     285  ZDSecMgrEstablishKeyInd
     588  ZDSecMgrEvent
     123  ZDSecMgrExtAddrLookup
     147  ZDSecMgrExtAddrStore
      15  ZDSecMgrInit
       2  ZDSecMgrMasterKeyData
     111  ZDSecMgrMasterKeyInit
     139  ZDSecMgrMasterKeyLoad
     179  ZDSecMgrMasterKeyLookup
     266  ZDSecMgrMasterKeyStore
     239  ZDSecMgrNewDeviceEvent
      52  ZDSecMgrPermitJoining
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      31  ZDSecMgrPermitJoiningTimeout
     109  ZDSecMgrRemoveDeviceInd
      47  ZDSecMgrRequestKeyInd
     241  ZDSecMgrSendMasterKey
     280  ZDSecMgrSendNwkKey
      30  ZDSecMgrSwitchKeyInd
      75  ZDSecMgrSwitchNwkKey
       1  ZDSecMgrTCAuthenticated
     125  ZDSecMgrTCDataLoad
       1  ZDSecMgrTCDataLoaded
       8  ZDSecMgrTCExtAddr
      69  ZDSecMgrTCExtAddrCheck
      16  ZDSecMgrTCMasterKey
     229  ZDSecMgrTransportKeyInd
     103  ZDSecMgrUpdateDeviceInd
     141  ZDSecMgrUpdateNwkKey
       4  __Constant_1

 
 10 564 bytes in segment BANKED_CODE
    462 bytes in segment BANK_RELAYS
     17 bytes in segment XDATA_I
     17 bytes in segment XDATA_ID
      4 bytes in segment XDATA_ROM_C
     50 bytes in segment XDATA_Z
 
 11 043 bytes of CODE  memory
      0 bytes of CONST memory (+ 4 bytes shared)
     67 bytes of XDATA memory

Errors: none
Warnings: none
